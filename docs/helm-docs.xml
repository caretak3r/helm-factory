This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
chart_best_practices/
  conventions.md
  custom_resource_definitions.md
  dependencies.mdx
  index.mdx
  labels.md
  pods.md
  rbac.md
  templates.md
  values.md
chart_template_guide/
  accessing_files.md
  builtin_objects.md
  control_structures.md
  data_types.md
  debugging.md
  function_list.mdx
  functions_and_pipelines.mdx
  getting_started.md
  helm_ignore_file.md
  index.mdx
  named_templates.md
  notes_files.md
  subcharts_and_globals.md
  values_files.mdx
  variables.md
  wrapping_up.md
  yaml_techniques.md
faq/
  index.mdx
  installing.mdx
  uninstalling.mdx
glossary/
  index.mdx
helm/
  _category_.json
  helm_completion_bash.md
  helm_completion_fish.md
  helm_completion_powershell.md
  helm_completion_zsh.md
  helm_completion.md
  helm_create.md
  helm_dependency_build.md
  helm_dependency_list.md
  helm_dependency_update.md
  helm_dependency.md
  helm_env.md
  helm_get_all.md
  helm_get_hooks.md
  helm_get_manifest.md
  helm_get_metadata.md
  helm_get_notes.md
  helm_get_values.md
  helm_get.md
  helm_history.md
  helm_install.md
  helm_lint.md
  helm_list.md
  helm_package.md
  helm_plugin_install.md
  helm_plugin_list.md
  helm_plugin_package.md
  helm_plugin_uninstall.md
  helm_plugin_update.md
  helm_plugin_verify.md
  helm_plugin.md
  helm_pull.md
  helm_push.md
  helm_registry_login.md
  helm_registry_logout.md
  helm_registry.md
  helm_repo_add.md
  helm_repo_index.md
  helm_repo_list.md
  helm_repo_remove.md
  helm_repo_update.md
  helm_repo.md
  helm_rollback.md
  helm_search_hub.md
  helm_search_repo.md
  helm_search.md
  helm_show_all.md
  helm_show_chart.md
  helm_show_crds.md
  helm_show_readme.md
  helm_show_values.md
  helm_show.md
  helm_status.md
  helm_template.md
  helm_test.md
  helm_uninstall.md
  helm_upgrade.md
  helm_verify.md
  helm_version.md
  helm.md
  index.mdx
howto/
  chart_releaser_action.md
  chart_repository_sync_example.md
  charts_tips_and_tricks.md
  index.mdx
images/
  create-a-bucket.png
  create-a-gh-page-button.png
  edit-permissions.png
  make-bucket-public.png
  set-a-gh-page.png
intro/
  CheatSheet.mdx
  index.mdx
  install.mdx
  quickstart.md
  using_helm.mdx
logos/
  helm_logo_transparent.png
  helm-blue-vector.svg
  helm-white-vector.svg
  helm.svg
plugins/
  developer/
    index.mdx
    tutorial-cli-plugin.mdx
    tutorial-getter-plugin.mdx
    tutorial-postrenderer-plugin.mdx
  user/
    index.md
  index.mdx
  overview.md
sdk/
  examples.mdx
  gosdk.mdx
  index.mdx
topics/
  advanced.mdx
  architecture.md
  chart_repository.md
  chart_tests.md
  charts_hooks.md
  charts.mdx
  index.mdx
  kubernetes_apis.md
  kubernetes_distros.md
  library_charts.md
  permissions_sql_storage_backend.md
  plugins.mdx
  provenance.mdx
  rbac.md
  registries.mdx
  release_policy.md
  version_skew.mdx
_v4-in-progress.mdx
changelog.md
index.mdx
overview.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="chart_best_practices/conventions.md">
---
title: General Conventions
description: General conventions for charts.
sidebar_position: 1
---

This part of the Best Practices Guide explains general conventions.

## Chart Names

Chart names must be lower case letters and numbers. Words _may_ be separated
with dashes (-):

Examples:

```
drupal
nginx-lego
aws-cluster-autoscaler
```

Neither uppercase letters nor underscores can be used in chart names. Dots
should not be used in chart names.

## Version Numbers

Wherever possible, Helm uses [SemVer 2](https://semver.org) to represent version
numbers. (Note that Docker image tags do not necessarily follow SemVer, and are
thus considered an unfortunate exception to the rule.)

When SemVer versions are stored in Kubernetes labels, we conventionally alter
the `+` character to an `_` character, as labels do not allow the `+` sign as a
value.

## Formatting YAML

YAML files should be indented using _two spaces_ (and never tabs).

## Usage of the Words Helm and Chart

There are a few conventions for using the words _Helm_ and _helm_.

- _Helm_ refers to the project as a whole
- `helm` refers to the client-side command
- The term `chart` does not need to be capitalized, as it is not a proper noun
- However, `Chart.yaml` does need to be capitalized because the file name is
  case sensitive

When in doubt, use _Helm_ (with an uppercase 'H').
</file>

<file path="chart_best_practices/custom_resource_definitions.md">
---
title: Custom Resource Definitions
description: How to handle creating and using CRDs.
sidebar_position: 7
---

This section of the Best Practices Guide deals with creating and using Custom
Resource Definition objects.

When working with Custom Resource Definitions (CRDs), it is important to
distinguish two different pieces:

- There is a declaration of a CRD. This is the YAML file that has the kind
  `CustomResourceDefinition`
- Then there are resources that _use_ the CRD. Say a CRD defines
  `foo.example.com/v1`. Any resource that has `apiVersion: example.com/v1` and
  kind `Foo` is a resource that uses the CRD.

## Install a CRD Declaration Before Using the Resource

Helm is optimized to load as many resources into Kubernetes as fast as possible.
By design, Kubernetes can take an entire set of manifests and bring them all
online (this is called the reconciliation loop).

But there's a difference with CRDs.

For a CRD, the declaration must be registered before any resources of that CRDs
kind(s) can be used. And the registration process sometimes takes a few seconds.

### Method 1: Let `helm` Do It For You

With the arrival of Helm 3, we removed the old `crd-install` hooks for a more
simple methodology. There is now a special directory called `crds` that you can
create in your chart to hold your CRDs. These CRDs are not templated, but will
be installed by default when running a `helm install` for the chart. If the CRD
already exists, it will be skipped with a warning. If you wish to skip the CRD
installation step, you can pass the `--skip-crds` flag.

#### Some caveats (and explanations)

There is no support at this time for upgrading or deleting CRDs using Helm. This
was an explicit decision after much community discussion due to the danger for
unintentional data loss. Furthermore, there is currently no community consensus
around how to handle CRDs and their lifecycle. As this evolves, Helm will add
support for those use cases.

The `--dry-run` flag of `helm install` and `helm upgrade` is not currently
supported for CRDs. The purpose of "Dry Run" is to validate that the output of
the chart will actually work if sent to the server. But CRDs are a modification
of the server's behavior. Helm cannot install the CRD on a dry run, so the
discovery client will not know about that Custom Resource (CR), and validation
will fail. You can alternatively move the CRDs to their own chart or use `helm
template` instead.

Another important point to consider in the discussion around CRD support is how
the rendering of templates is handled. One of the distinct disadvantages of the
`crd-install` method used in Helm 2 was the inability to properly validate
charts due to changing API availability (a CRD is actually adding another
available API to your Kubernetes cluster). If a chart installed a CRD, `helm` no
longer had a valid set of API versions to work against. This is also the reason
behind removing templating support from CRDs. With the new `crds` method of CRD
installation, we now ensure that `helm` has completely valid information about
the current state of the cluster.

### Method 2: Separate Charts

Another way to do this is to put the CRD definition in one chart, and then put
any resources that use that CRD in _another_ chart.

In this method, each chart must be installed separately. However, this workflow
may be more useful for cluster operators who have admin access to a cluster
</file>

<file path="chart_best_practices/dependencies.mdx">
---
title: Dependencies
description: Covers best practices for Chart dependencies.
sidebar_position: 4
---

import Helm4 from "/docs/_v4-in-progress.mdx"

<Helm4/>

This section of the guide covers best practices for `dependencies` declared in
`Chart.yaml`.

## Versions

Where possible, use version ranges instead of pinning to an exact version. The
suggested default is to use a patch-level version match:

```yaml
version: ~1.2.3
```

This will match version `1.2.3` and any patches to that release.  In other
words, `~1.2.3` is equivalent to `>= 1.2.3, < 1.3.0`

For the complete version matching syntax, please see the [semver
documentation](https://github.com/Masterminds/semver#checking-version-constraints).

### Prerelease versions

The above versioning constraints will not match on pre-release versions.
For example `version: ~1.2.3` will match `version: ~1.2.4` but not `version: ~1.2.3-1`.
The following provides a pre-release as well as patch-level matching:

```yaml
version: ~1.2.3-0
```

### Repository URLs

Where possible, use `https://` repository URLs, followed by `http://` URLs.

If the repository has been added to the repository index file, the repository
name can be used as an alias of URL. Use `alias:` or `@` followed by repository
names.

File URLs (`file://...`) are considered a "special case" for charts that are
assembled by a fixed deployment pipeline.

When using [downloader plugins](/topics/plugins.mdx#downloader-plugins)
the URL scheme will be specific to the plugin. Note, a user of the chart will
need to have a plugin supporting the scheme installed to update or build the
dependency.

Helm cannot perform dependency management operations on the dependency when the
`repository` field is left blank. In that case Helm will assume the dependency
is in a sub-directory of the `charts` folder with the name being the same as the
`name` property for the dependency.

## Conditions and Tags

Conditions or tags should be added to any dependencies that _are optional_. Note that by default a `condition` is `true`.

The preferred form of a condition is:

```yaml
condition: somechart.enabled
```

Where `somechart` is the chart name of the dependency.

When multiple subcharts (dependencies) together provide an optional or swappable
feature, those charts should share the same tags.

For example, if both `nginx` and `memcached` together provide performance
optimizations for the main app in the chart, and are required to both be present
when that feature is enabled, then they should both have a tags section like
this:

```yaml
tags:
  - webaccelerator
```

This allows a user to turn that feature on and off with one tag.
</file>

<file path="chart_best_practices/index.mdx">
---
title: Best Practices
sidebar: true
sidebar_position: 4
---

# The Chart Best Practices Guide

This guide covers the Helm Team's considered best practices for creating charts.
It focuses on how charts should be structured.

We focus primarily on best practices for charts that may be publicly deployed.
We know that many charts are for internal-use only, and authors of such charts
may find that their internal interests override our suggestions here.


import DocCardList from '@theme/DocCardList';

<DocCardList />
</file>

<file path="chart_best_practices/labels.md">
---
title: Labels and Annotations
description: Covers best practices for using labels and annotations in your Chart.
sidebar_position: 5
---

This part of the Best Practices Guide discusses the best practices for using
labels and annotations in your chart.

## Is it a Label or an Annotation?

An item of metadata should be a label under the following conditions:

- It is used by Kubernetes to identify this resource
- It is useful to expose to operators for the purpose of querying the system.

For example, we suggest using `helm.sh/chart: NAME-VERSION` as a label so that
operators can conveniently find all of the instances of a particular chart to
use.

If an item of metadata is not used for querying, it should be set as an
annotation instead.

Helm hooks are always annotations.

## Standard Labels

The following table defines common labels that Helm charts use. Helm itself
never requires that a particular label be present. Labels that are marked REC
are recommended, and _should_ be placed onto a chart for global consistency.
Those marked OPT are optional. These are idiomatic or commonly in use, but are
not relied upon frequently for operational purposes.

Name|Status|Description
-----|------|----------
`app.kubernetes.io/name` | REC | This should be the app name, reflecting the entire app. Usually `{{ template "name" . }}` is used for this. This is used by many Kubernetes manifests, and is not Helm-specific.
`helm.sh/chart` | REC | This should be the chart name and version: `{{ .Chart.Name }}-{{ .Chart.Version \| replace "+" "_" }}`.
`app.kubernetes.io/managed-by` | REC | This should always be set to `{{ .Release.Service }}`. It is for finding all things managed by Helm.
`app.kubernetes.io/instance` | REC | This should be the `{{ .Release.Name }}`. It aids in differentiating between different instances of the same application.
`app.kubernetes.io/version` | OPT | The version of the app and can be set to `{{ .Chart.AppVersion }}`.
`app.kubernetes.io/component` | OPT | This is a common label for marking the different roles that pieces may play in an application. For example, `app.kubernetes.io/component: frontend`.
`app.kubernetes.io/part-of` | OPT | When multiple charts or pieces of software are used together to make one application. For example, application software and a database to produce a website. This can be set to the top level application being supported.

You can find more information on the Kubernetes labels, prefixed with
`app.kubernetes.io`, in the [Kubernetes
documentation](https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels/).
</file>

<file path="chart_best_practices/pods.md">
---
title: Pods and PodTemplates
description: Discusses formatting the Pod and PodTemplate portions in Chart manifests.
sidebar_position: 6
---

This part of the Best Practices Guide discusses formatting the Pod and
PodTemplate portions in chart manifests.

The following (non-exhaustive) list of resources use PodTemplates:

- Deployment
- ReplicationController
- ReplicaSet
- DaemonSet
- StatefulSet

## Images

A container image should use a fixed tag or the SHA of the image. It should not
use the tags `latest`, `head`, `canary`, or other tags that are designed to be
"floating".


Images _may_ be defined in the `values.yaml` file to make it easy to swap out
images.

```yaml
image: {{ .Values.redisImage | quote }}
```

An image and a tag _may_ be defined in `values.yaml` as two separate fields:

```yaml
image: "{{ .Values.redisImage }}:{{ .Values.redisTag }}"
```

## ImagePullPolicy

`helm create` sets the `imagePullPolicy` to `IfNotPresent` by default by doing
the following in your `deployment.yaml`:

```yaml
imagePullPolicy: {{ .Values.image.pullPolicy }}
```

And `values.yaml`:

```yaml
image:
  pullPolicy: IfNotPresent
```

Similarly, Kubernetes defaults the `imagePullPolicy` to `IfNotPresent` if it is
not defined at all. If you want a value other than `IfNotPresent`, simply update
the value in `values.yaml` to your desired value.


## PodTemplates Should Declare Selectors

All PodTemplate sections should specify a selector. For example:

```yaml
selector:
  matchLabels:
      app.kubernetes.io/name: MyName
template:
  metadata:
    labels:
      app.kubernetes.io/name: MyName
```

This is a good practice because it makes the relationship between the set and
the pod.

But this is even more important for sets like Deployment. Without this, the
_entire_ set of labels is used to select matching pods, and this will break if
you use labels that change, like version or release date.
</file>

<file path="chart_best_practices/rbac.md">
---
title: Role-Based Access Control
description: Discusses the creation and formatting of RBAC resources in Chart manifests.
sidebar_position: 8
---

This part of the Best Practices Guide discusses the creation and formatting of
RBAC resources in chart manifests.

RBAC resources are:

- ServiceAccount (namespaced)
- Role (namespaced)
- ClusterRole
- RoleBinding (namespaced)
- ClusterRoleBinding

## YAML Configuration

RBAC and ServiceAccount configuration should happen under separate keys. They
are separate things. Splitting these two concepts out in the YAML disambiguates
them and makes this clearer.

```yaml
rbac:
  # Specifies whether RBAC resources should be created
  create: true

serviceAccount:
  # Specifies whether a ServiceAccount should be created
  create: true
  # The name of the ServiceAccount to use.
  # If not set and create is true, a name is generated using the fullname template
  name:
```

This structure can be extended for more complex charts that require multiple
ServiceAccounts.

```yaml
someComponent:
  serviceAccount:
    create: true
    name:
anotherComponent:
  serviceAccount:
    create: true
    name:
```

## RBAC Resources Should be Created by Default

`rbac.create` should be a boolean value controlling whether RBAC resources are
created.  The default should be `true`.  Users who wish to manage RBAC access
controls themselves can set this value to `false` (in which case see below).

## Using RBAC Resources

`serviceAccount.name` should be set to the name of the ServiceAccount to be used
by access-controlled resources created by the chart.  If `serviceAccount.create`
is true, then a ServiceAccount with this name should be created.  If the name is
not set, then a name is generated using the `fullname` template, If
`serviceAccount.create` is false, then it should not be created, but it should
still be associated with the same resources so that manually-created RBAC
resources created later that reference it will function correctly.  If
`serviceAccount.create` is false and the name is not specified, then the default
ServiceAccount is used.

The following helper template should be used for the ServiceAccount.

```yaml
{{/*
Create the name of the service account to use
*/}}
{{- define "mychart.serviceAccountName" -}}
{{- if .Values.serviceAccount.create -}}
    {{ default (include "mychart.fullname" .) .Values.serviceAccount.name }}
{{- else -}}
    {{ default "default" .Values.serviceAccount.name }}
{{- end -}}
{{- end -}}
```
</file>

<file path="chart_best_practices/templates.md">
---
title: Templates
description: A closer look at best practices surrounding templates.
sidebar_position: 3
---

This part of the Best Practices Guide focuses on templates.

## Structure of `templates/`

The `templates/` directory should be structured as follows:

- Template files should have the extension `.yaml` if they produce YAML output.
  The extension `.tpl` may be used for template files that produce no formatted
  content.
- Template file names should use dashed notation (`my-example-configmap.yaml`),
  not camelcase.
- Each resource definition should be in its own template file.
- Template file names should reflect the resource kind in the name. e.g.
  `foo-pod.yaml`, `bar-svc.yaml`

## Names of Defined Templates

Defined templates (templates created inside a `{{ define }} ` directive) are
globally accessible. That means that a chart and all of its subcharts will have
access to all of the templates created with `{{ define }}`.

For that reason, _all defined template names should be namespaced._

Correct:

```yaml
{{- define "nginx.fullname" }}
{{/* ... */}}
{{ end -}}
```

Incorrect:

```yaml
{{- define "fullname" -}}
{{/* ... */}}
{{ end -}}
```
It is highly recommended that new charts are created via `helm create` command
as the template names are automatically defined as per this best practice.

## Formatting Templates

Templates should be indented using _two spaces_ (never tabs).

Template directives should have whitespace after the opening  braces and before
the closing braces:

Correct:
```
{{ .foo }}
{{ print "foo" }}
{{- print "bar" -}}
```

Incorrect:
```
{{.foo}}
{{print "foo"}}
{{-print "bar"-}}
```

Templates should chomp whitespace where possible:

```yaml
foo:
  {{- range .Values.items }}
  {{ . }}
  {{ end -}}
```

Blocks (such as control structures) may be indented to indicate flow of the
template code.

```
{{ if $foo -}}
  {{- with .Bar }}Hello{{ end -}}
{{- end -}}
```

However, since YAML is a whitespace-oriented language, it is often not possible
for code indentation to follow that convention.

## Whitespace in Generated Templates

It is preferable to keep the amount of whitespace in generated templates to a
minimum. In particular, numerous blank lines should not appear adjacent to each
other. But occasional empty lines (particularly between logical sections) is
fine.

This is best:

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: example
  labels:
    first: first
    second: second
```

This is okay:

```yaml
apiVersion: batch/v1
kind: Job

metadata:
  name: example

  labels:
    first: first
    second: second

```

But this should be avoided:

```yaml
apiVersion: batch/v1
kind: Job

metadata:
  name: example





  labels:
    first: first

    second: second

```

## Comments (YAML Comments vs. Template Comments)

Both YAML and Helm Templates have comment markers.

YAML comments:
```yaml
# This is a comment
type: sprocket
```

Template Comments:
```yaml
{{- /*
This is a comment.
*/}}
type: frobnitz
```

Template comments should be used when documenting features of a template, such
as explaining a defined template:

```yaml
{{- /*
mychart.shortname provides a 6 char truncated version of the release name.
*/}}
{{ define "mychart.shortname" -}}
{{ .Release.Name | trunc 6 }}
{{- end -}}

```

Inside of templates, YAML comments may be used when it is useful for Helm users
to (possibly) see the comments during debugging.

```yaml
# This may cause problems if the value is more than 100Gi
memory: {{ .Values.maxMem | quote }}
```

The comment above is visible when the user runs `helm install --debug`, while
comments specified in `{{- /* */}}` sections are not.

Beware of adding `#` YAML comments on template sections containing Helm values that may be required by certain template functions.

For example, if `required` function is introduced to the above example, and `maxMem` is unset, then a `#` YAML comment will introduce a rendering error.

Correct: `helm template` does not render this block
```yaml
{{- /*
# This may cause problems if the value is more than 100Gi
memory: {{ required "maxMem must be set" .Values.maxMem | quote }}
*/ -}}
```

Incorrect: `helm template` returns `Error: execution error at (templates/test.yaml:2:13): maxMem must be set`
```yaml
# This may cause problems if the value is more than 100Gi
# memory: {{ required .Values.maxMem "maxMem must be set" | quote }}
```

Review [Debugging Templates](/chart_template_guide/debugging.md) for another example of this behavior of how YAML comments are left intact.

## Use of JSON in Templates and Template Output

YAML is a superset of JSON. In some cases, using a JSON syntax can be more
readable than other YAML representations.

For example, this YAML is closer to the normal YAML method of expressing lists:

```yaml
arguments:
  - "--dirname"
  - "/foo"
```

But it is easier to read when collapsed into a JSON list style:

```yaml
arguments: ["--dirname", "/foo"]
```

Using JSON for increased legibility is good. However, JSON syntax should not be
used for representing more complex constructs.

When dealing with pure JSON embedded inside of YAML (such as init container
configuration), it is of course appropriate to use the JSON format.
</file>

<file path="chart_best_practices/values.md">
---
title: Values
description: Focuses on how you should structure and use your values.
sidebar_position: 2
---

This part of the best practices guide covers using values. In this part of the
guide, we provide recommendations on how you should structure and use your
values, with focus on designing a chart's `values.yaml` file.

## Naming Conventions

Variable names should begin with a lowercase letter, and words should be
separated with camelcase:

Correct:

```yaml
chicken: true
chickenNoodleSoup: true
```

Incorrect:

```yaml
Chicken: true  # initial caps may conflict with built-ins
chicken-noodle-soup: true # do not use hyphens in the name
```

Note that all of Helm's built-in variables begin with an uppercase letter to
easily distinguish them from user-defined values: `.Release.Name`,
`.Capabilities.KubeVersion`.

## Flat or Nested Values

YAML is a flexible format, and values may be nested deeply or flattened.

Nested:

```yaml
server:
  name: nginx
  port: 80
```

Flat:

```yaml
serverName: nginx
serverPort: 80
```

In most cases, flat should be favored over nested. The reason for this is that
it is simpler for template developers and users.


For optimal safety, a nested value must be checked at every level:

```
{{ if .Values.server }}
  {{ default "none" .Values.server.name }}
{{ end }}
```

For every layer of nesting, an existence check must be done. But for flat
configuration, such checks can be skipped, making the template easier to read
and use.

```
{{ default "none" .Values.serverName }}
```

When there are a large number of related variables, and at least one of them is
non-optional, nested values may be used to improve readability.

## Make Types Clear

YAML's type coercion rules are sometimes counterintuitive. For example, `foo:
false` is not the same as `foo: "false"`. Large integers like `foo: 12345678`
will get converted to scientific notation in some cases.

The easiest way to avoid type conversion errors is to be explicit about strings,
and implicit about everything else. Or, in short, _quote all strings_.

Often, to avoid the integer casting issues, it is advantageous to store your
integers as strings as well, and use `{{ int $value }}` in the template to
convert from a string back to an integer.

In most cases, explicit type tags are respected, so `foo: !!string 1234` should
treat `1234` as a string. _However_, the YAML parser consumes tags, so the type
data is lost after one parse.

## Consider How Users Will Use Your Values

There are three potential sources of values:

- A chart's `values.yaml` file
- A values file supplied by `helm install -f` or `helm upgrade -f`
- The values passed to a `--set` or `--set-string` flag on `helm install` or
  `helm upgrade`

When designing the structure of your values, keep in mind that users of your
chart may want to override them via either the `-f` flag or with the `--set`
option.

Since `--set` is more limited in expressiveness, the first guidelines for
writing your `values.yaml` file is _make it easy to override from `--set`_.

For this reason, it's often better to structure your values file using maps.

Difficult to use with `--set`:

```yaml
servers:
  - name: foo
    port: 80
  - name: bar
    port: 81
```

The above cannot be expressed with `--set` in Helm `<=2.4`. In Helm 2.5,
accessing the port on foo is `--set servers[0].port=80`. Not only is it harder
for the user to figure out, but it is prone to errors if at some later time the
order of the `servers` is changed.

Easy to use:

```yaml
servers:
  foo:
    port: 80
  bar:
    port: 81
```

Accessing foo's port is much more obvious: `--set servers.foo.port=80`.

## Document `values.yaml`

Every defined property in `values.yaml` should be documented. The documentation
string should begin with the name of the property that it describes, and then
give at least a one-sentence description.

Incorrect:

```yaml
# the host name for the webserver
serverHost: example
serverPort: 9191
```

Correct:

```yaml
# serverHost is the host name for the webserver
serverHost: example
# serverPort is the HTTP listener port for the webserver
serverPort: 9191
```

Beginning each comment with the name of the parameter it documents makes it easy
to grep out documentation, and will enable documentation tools to reliably
correlate doc strings with the parameters they describe.
</file>

<file path="chart_template_guide/accessing_files.md">
---
title: Accessing Files Inside Templates
description: How to access files from within a template.
sidebar_position: 10
---

In the previous section we looked at several ways to create and access named
templates. This makes it easy to import one template from within another
template. But sometimes it is desirable to import a _file that is not a
template_ and inject its contents without sending the contents through the
template renderer.

Helm provides access to files through the `.Files` object. Before we get going
with the template examples, though, there are a few things to note about how
this works:

- It is okay to add extra files to your Helm chart. These files will be bundled.
  Be careful, though. Charts must be smaller than 1M because of the storage
  limitations of Kubernetes objects.
- Some files cannot be accessed through the `.Files` object, usually for
  security reasons.
  - Files in `templates/` cannot be accessed.
  - Files excluded using `.helmignore` cannot be accessed.
  - Files outside of a Helm application [subchart](/chart_template_guide/subcharts_and_globals.md), including those of the parent, cannot be accessed
- Charts do not preserve UNIX mode information, so file-level permissions will
  have no impact on the availability of a file when it comes to the `.Files`
  object.

<!-- (see https://github.com/jonschlinkert/markdown-toc) -->

<!-- toc -->

- [Basic example](#basic-example)
- [Path helpers](#path-helpers)
- [Glob patterns](#glob-patterns)
- [ConfigMap and Secrets utility functions](#configmap-and-secrets-utility-functions)
- [Encoding](#encoding)
- [Lines](#lines)

<!-- tocstop -->

## Basic example

With those caveats behind, let's write a template that reads three files into
our ConfigMap. To get started, we will add three files to the chart, putting all
three directly inside of the `mychart/` directory.

`config1.toml`:

```toml
message = "Hello from config 1"
```

`config2.toml`:

```toml
message = "This is config 2"
```

`config3.toml`:

```toml
message = "Goodbye from config 3"
```

Each of these is a simple TOML file (think old-school Windows INI files). We
know the names of these files, so we can use a `range` function to loop through
them and inject their contents into our ConfigMap.

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  {{- $files := .Files }}
  {{- range tuple "config1.toml" "config2.toml" "config3.toml" }}
  {{ . }}: |-
    {{ $files.Get . }}
  {{- end }}
```

This ConfigMap uses several of the techniques discussed in previous sections.
For example, we create a `$files` variable to hold a reference to the `.Files`
object. We also use the `tuple` function to create a list of files that we loop
through. Then we print each file name (`{{ . }}: |-`) followed by the contents
of the file `{{ $files.Get . }}`.

Running this template will produce a single ConfigMap with the contents of all
three files:

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: quieting-giraf-configmap
data:
  config1.toml: |-
    message = "Hello from config 1"

  config2.toml: |-
    message = "This is config 2"

  config3.toml: |-
    message = "Goodbye from config 3"
```

## Path helpers

When working with files, it can be very useful to perform some standard
operations on the file paths themselves. To help with this, Helm imports many of
the functions from Go's [path](https://golang.org/pkg/path/) package for your
use. They are all accessible with the same names as in the Go package, but with
a lowercase first letter. For example, `Base` becomes `base`, etc.

The imported functions are:
- Base
- Dir
- Ext
- IsAbs
- Clean

## Glob patterns

As your chart grows, you may find you have a greater need to organize your files
more, and so we provide a `Files.Glob(pattern string)` method to assist in
extracting certain files with all the flexibility of [glob
patterns](https://godoc.org/github.com/gobwas/glob).

`.Glob` returns a `Files` type, so you may call any of the `Files` methods on
the returned object.

For example, imagine the directory structure:

```
foo/:
  foo.txt foo.yaml

bar/:
  bar.go bar.conf baz.yaml
```

You have multiple options with Globs:


```yaml
{{ $currentScope := .}}
{{ range $path, $_ :=  .Files.Glob  "**.yaml" }}
    {{- with $currentScope}}
        {{ .Files.Get $path }}
    {{- end }}
{{ end }}
```

Or

```yaml
{{ range $path, $_ :=  .Files.Glob  "**.yaml" }}
      {{ $.Files.Get $path }}
{{ end }}
```

## ConfigMap and Secrets utility functions

(Available Helm 2.0.2 and after)

It is very common to want to place file content into both ConfigMaps and
Secrets, for mounting into your pods at run time. To help with this, we provide
a couple utility methods on the `Files` type.

For further organization, it is especially useful to use these methods in
conjunction with the `Glob` method.

Given the directory structure from the [Glob](#glob-patterns) example above:

```yaml
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: conf
data:
{{ (.Files.Glob "foo/*").AsConfig | indent 2 }}
---
apiVersion: v1
kind: Secret
metadata:
  name: very-secret
type: Opaque
data:
{{ (.Files.Glob "bar/*").AsSecrets | indent 2 }}
```

## Encoding

You can import a file and have the template base-64 encode it to ensure
successful transmission:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: {{ .Release.Name }}-secret
type: Opaque
data:
  token: |-
    {{ .Files.Get "config1.toml" | b64enc }}
```

The above will take the same `config1.toml` file we used before and encode it:

```yaml
# Source: mychart/templates/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: lucky-turkey-secret
type: Opaque
data:
  token: |-
    bWVzc2FnZSA9ICJIZWxsbyBmcm9tIGNvbmZpZyAxIgo=
```

## Lines

Sometimes it is desirable to access each line of a file in your template. We
provide a convenient `Lines` method for this.

You can loop through `Lines` using a `range` function:

```yaml
data:
  some-file.txt: {{ range .Files.Lines "foo/bar.txt" }}
    {{ . }}{{ end }}
```

There is no way to pass files external to the chart during `helm install`. So if
you are asking users to supply data, it must be loaded using `helm install -f`
or `helm install --set`.

This discussion wraps up our dive into the tools and techniques for writing Helm
templates. In the next section we will see how you can use one special file,
`templates/NOTES.txt`, to send post-installation instructions to the users of
your chart.
</file>

<file path="chart_template_guide/builtin_objects.md">
---
title: Built-in Objects
description: Built-in objects available to templates.
sidebar_position: 3
---

Objects are passed into a template from the template engine. And your code can
pass objects around (we'll see examples when we look at the `with` and `range`
statements). There are even a few ways to create new objects within your
templates, like with the `tuple` function we'll see later.

Objects can be simple, and have just one value. Or they can contain other
objects or functions. For example, the `Release` object contains several objects
(like `Release.Name`) and the `Files` object has a few functions.

In the previous section, we use `{{ .Release.Name }}` to insert the name of a
release into a template. `Release` is one of the top-level objects that you can
access in your templates.

- `Release`: This object describes the release itself. It has several objects
  inside of it:
  - `Release.Name`: The release name
  - `Release.Namespace`: The namespace to be released into (if the manifest
    doesnâ€™t override)
  - `Release.IsUpgrade`: This is set to `true` if the current operation is an
    upgrade or rollback.
  - `Release.IsInstall`: This is set to `true` if the current operation is an
    install.
  - `Release.Revision`: The revision number for this release. On install, this
    is 1, and it is incremented with each upgrade and rollback.
  - `Release.Service`: The service that is rendering the present template. On
    Helm, this is always `Helm`.
- `Values`: Values passed into the template from the `values.yaml` file and from
  user-supplied files. By default, `Values` is empty.
- `Chart`: The contents of the `Chart.yaml` file. Any data in `Chart.yaml` will
  be accessible here. For example `{{ .Chart.Name }}-{{ .Chart.Version }}` will
  print out the `mychart-0.1.0`.
  - The available fields are listed in the [Charts Guide](/topics/charts.mdx#the-chartyaml-file)
- `Subcharts`: This provides access to the scope (.Values, .Charts, .Releases etc.)
  of subcharts to the parent. For example `.Subcharts.mySubChart.myValue` to access
  the `myValue` in the `mySubChart` chart.
- `Files`: This provides access to all non-special files in a chart. While you
  cannot use it to access templates, you can use it to access other files in the
  chart. See the section [Accessing Files](/chart_template_guide/accessing_files.md) for more.
  - `Files.Get` is a function for getting a file by name (`.Files.Get
    config.ini`)
  - `Files.GetBytes` is a function for getting the contents of a file as an
    array of bytes instead of as a string. This is useful for things like
    images.
  - `Files.Glob` is a function that returns a list of files whose names match
    the given shell glob pattern.
  - `Files.Lines` is a function that reads a file line-by-line. This is useful
    for iterating over each line in a file.
  - `Files.AsSecrets` is a function that returns the file bodies as Base 64
    encoded strings.
  - `Files.AsConfig` is a function that returns file bodies as a YAML map.
- `Capabilities`: This provides information about what capabilities the
  Kubernetes cluster supports.
  - `Capabilities.APIVersions` is a set of versions.
  - `Capabilities.APIVersions.Has $version` indicates whether a version (e.g.,
    `batch/v1`) or resource (e.g., `apps/v1/Deployment`) is available on the
    cluster.
  - `Capabilities.KubeVersion` and `Capabilities.KubeVersion.Version` is the
    Kubernetes version.
  - `Capabilities.KubeVersion.Major` is the Kubernetes major version.
  - `Capabilities.KubeVersion.Minor` is the Kubernetes minor version.
  - `Capabilities.HelmVersion` is the object containing the Helm Version details, it is the same output of `helm version`.
  - `Capabilities.HelmVersion.Version` is the current Helm version in semver format.
  - `Capabilities.HelmVersion.GitCommit` is the Helm git sha1.
  - `Capabilities.HelmVersion.GitTreeState` is the state of the Helm git tree.
  - `Capabilities.HelmVersion.GoVersion` is the version of the Go compiler used.
- `Template`: Contains information about the current template that is being
  executed
  - `Template.Name`: A namespaced file path to the current template (e.g.
    `mychart/templates/mytemplate.yaml`)
  - `Template.BasePath`: The namespaced path to the templates directory of the current
    chart (e.g. `mychart/templates`).

The built-in values always begin with a capital letter. This is in keeping with
Go's naming convention. When you create your own names, you are free to use a
convention that suits your team. Some teams, like many whose charts you may see
on [Artifact Hub](https://artifacthub.io/packages/search?kind=0), choose to use
only initial lower case letters in order to distinguish local names from those
built-in. In this guide, we follow that convention.
</file>

<file path="chart_template_guide/control_structures.md">
---
title: Flow Control
description: A quick overview on the flow structure within templates.
sidebar_position: 7
---

Control structures (called "actions" in template parlance) provide you, the
template author, with the ability to control the flow of a template's
generation. Helm's template language provides the following control structures:

- `if`/`else` for creating conditional blocks
- `with` to specify a scope
- `range`, which provides a "for each"-style loop

In addition to these, it provides a few actions for declaring and using named
template segments:

- `define` declares a new named template inside of your template
- `template` imports a named template
- `block` declares a special kind of fillable template area

In this section, we'll talk about `if`, `with`, and `range`. The others are
covered in the "Named Templates" section later in this guide.

## If/Else

The first control structure we'll look at is for conditionally including blocks
of text in a template. This is the `if`/`else` block.

The basic structure for a conditional looks like this:

```
{{ if PIPELINE }}
  # Do something
{{ else if OTHER PIPELINE }}
  # Do something else
{{ else }}
  # Default case
{{ end }}
```

Notice that we're now talking about _pipelines_ instead of values. The reason
for this is to make it clear that control structures can execute an entire
pipeline, not just evaluate a value.

A pipeline is evaluated as _false_ if the value is:

- a boolean false
- a numeric zero
- an empty string
- a `nil` (empty or null)
- an empty collection (`map`, `slice`, `tuple`, `dict`, `array`)

Under all other conditions, the condition is true.

Let's add a simple conditional to our ConfigMap. We'll add another setting if
the drink is set to coffee:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ .Values.favorite.drink | default "tea" | quote }}
  food: {{ .Values.favorite.food | upper | quote }}
  {{ if eq .Values.favorite.drink "coffee" }}mug: "true"{{ end }}
```

Since we commented out `drink: coffee` in our last example, the output should
not include a `mug: "true"` flag. But if we add that line back into our
`values.yaml` file, the output should look like this:

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: eyewitness-elk-configmap
data:
  myvalue: "Hello World"
  drink: "coffee"
  food: "PIZZA"
  mug: "true"
```

## Controlling Whitespace

While we're looking at conditionals, we should take a quick look at the way
whitespace is controlled in templates. Let's take the previous example and
format it to be a little easier to read:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ .Values.favorite.drink | default "tea" | quote }}
  food: {{ .Values.favorite.food | upper | quote }}
  {{ if eq .Values.favorite.drink "coffee" }}
    mug: "true"
  {{ end }}
```

Initially, this looks good. But if we run it through the template engine, we'll
get an unfortunate result:

```console
$ helm install --dry-run --debug ./mychart
SERVER: "localhost:44134"
CHART PATH: /Users/mattbutcher/Code/Go/src/helm.sh/helm/_scratch/mychart
Error: YAML parse error on mychart/templates/configmap.yaml: error converting YAML to JSON: yaml: line 9: did not find expected key
```

What happened? We generated incorrect YAML because of the whitespacing above.

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: eyewitness-elk-configmap
data:
  myvalue: "Hello World"
  drink: "coffee"
  food: "PIZZA"
    mug: "true"
```

`mug` is incorrectly indented. Let's simply out-dent that one line, and re-run:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ .Values.favorite.drink | default "tea" | quote }}
  food: {{ .Values.favorite.food | upper | quote }}
  {{ if eq .Values.favorite.drink "coffee" }}
  mug: "true"
  {{ end }}
```

When we sent that, we'll get YAML that is valid, but still looks a little funny:

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: telling-chimp-configmap
data:
  myvalue: "Hello World"
  drink: "coffee"
  food: "PIZZA"

  mug: "true"

```

Notice that we received a few empty lines in our YAML. Why? When the template
engine runs, it _removes_ the contents inside of `{{` and `}}`, but it leaves
the remaining whitespace exactly as is.

YAML ascribes meaning to whitespace, so managing the whitespace becomes pretty
important. Fortunately, Helm templates have a few tools to help.

First, the curly brace syntax of template declarations can be modified with
special characters to tell the template engine to chomp whitespace. `{{- ` (with
the dash and space added) indicates that whitespace should be chomped left,
while ` -}}` means whitespace to the right should be consumed. _Be careful!
Newlines are whitespace!_

> Make sure there is a space between the `-` and the rest of your directive.
> `{{- 3 }}` means "trim left whitespace and print 3" while `{{-3 }}` means
> "print -3".

Using this syntax, we can modify our template to get rid of those new lines:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ .Values.favorite.drink | default "tea" | quote }}
  food: {{ .Values.favorite.food | upper | quote }}
  {{- if eq .Values.favorite.drink "coffee" }}
  mug: "true"
  {{- end }}
```

Just for the sake of making this point clear, let's adjust the above, and
substitute an `*` for each whitespace that will be deleted following this rule.
An `*` at the end of the line indicates a newline character that would be
removed

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ .Values.favorite.drink | default "tea" | quote }}
  food: {{ .Values.favorite.food | upper | quote }}*
**{{- if eq .Values.favorite.drink "coffee" }}
  mug: "true"*
**{{- end }}

```

Keeping that in mind, we can run our template through Helm and see the result:

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: clunky-cat-configmap
data:
  myvalue: "Hello World"
  drink: "coffee"
  food: "PIZZA"
  mug: "true"
```

Be careful with the chomping modifiers. It is easy to accidentally do things
like this:

```yaml
  food: {{ .Values.favorite.food | upper | quote }}
  {{- if eq .Values.favorite.drink "coffee" -}}
  mug: "true"
  {{- end -}}

```

That will produce `food: "PIZZA"mug: "true"` because it consumed newlines on both
sides.

> For the details on whitespace control in templates, see the [Official Go
> template documentation](https://godoc.org/text/template)

Finally, sometimes it's easier to tell the template system how to indent for you
instead of trying to master the spacing of template directives. For that reason,
you may sometimes find it useful to use the `indent` function (`{{ indent 2
"mug:true" }}`).

## Modifying scope using `with`

The next control structure to look at is the `with` action. This controls
variable scoping. Recall that `.` is a reference to _the current scope_. So
`.Values` tells the template to find the `Values` object in the current scope.

The syntax for `with` is similar to a simple `if` statement:

```
{{ with PIPELINE }}
  # restricted scope
{{ end }}
```

Scopes can be changed. `with` can allow you to set the current scope (`.`) to a
particular object. For example, we've been working with `.Values.favorite`.
Let's rewrite our ConfigMap to alter the `.` scope to point to
`.Values.favorite`:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  {{- with .Values.favorite }}
  drink: {{ .drink | default "tea" | quote }}
  food: {{ .food | upper | quote }}
  {{- end }}
```

Note that we removed the `if` conditional from the previous exercise
because it is now unnecessary - the block after `with` only executes
if the value of `PIPELINE` is not empty.

Notice that now we can reference `.drink` and `.food` without qualifying them.
That is because the `with` statement sets `.` to point to `.Values.favorite`.
The `.` is reset to its previous scope after `{{ end }}`.

But here's a note of caution! Inside of the restricted scope, you will not be
able to access the other objects from the parent scope using `.`. This, for
example, will fail:

```yaml
  {{- with .Values.favorite }}
  drink: {{ .drink | default "tea" | quote }}
  food: {{ .food | upper | quote }}
  release: {{ .Release.Name }}
  {{- end }}
```

It will produce an error because `Release.Name` is not inside of the restricted
scope for `.`. However, if we swap the last two lines, all will work as expected
because the scope is reset after `{{ end }}`.

```yaml
  {{- with .Values.favorite }}
  drink: {{ .drink | default "tea" | quote }}
  food: {{ .food | upper | quote }}
  {{- end }}
  release: {{ .Release.Name }}
```

Or, we can use `$` for accessing the object `Release.Name` from the parent
scope. `$` is mapped to the root scope when template execution begins and it
does not change during template execution. The following would work as well:

```yaml
  {{- with .Values.favorite }}
  drink: {{ .drink | default "tea" | quote }}
  food: {{ .food | upper | quote }}
  release: {{ $.Release.Name }}
  {{- end }}
```

After looking at `range`, we will take a look at template variables, which offer
one solution to the scoping issue above.

## Looping with the `range` action

Many programming languages have support for looping using `for` loops, `foreach`
loops, or similar functional mechanisms. In Helm's template language, the way to
iterate through a collection is to use the `range` operator.

To start, let's add a list of pizza toppings to our `values.yaml` file:

```yaml
favorite:
  drink: coffee
  food: pizza
pizzaToppings:
  - mushrooms
  - cheese
  - peppers
  - onions
  - pineapple
```

Now we have a list (called a `slice` in templates) of `pizzaToppings`. We can
modify our template to print this list into our ConfigMap:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  {{- with .Values.favorite }}
  drink: {{ .drink | default "tea" | quote }}
  food: {{ .food | upper | quote }}
  {{- end }}
  toppings: |-
    {{- range .Values.pizzaToppings }}
    - {{ . | title | quote }}
    {{- end }}

```

We can use `$` for accessing the list `Values.pizzaToppings` from the parent
scope. `$` is mapped to the root scope when template execution begins and it
does not change during template execution. The following would work as well:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  {{- with .Values.favorite }}
  drink: {{ .drink | default "tea" | quote }}
  food: {{ .food | upper | quote }}
  toppings: |-
    {{- range $.Values.pizzaToppings }}
    - {{ . | title | quote }}
    {{- end }}
  {{- end }}
```

Let's take a closer look at the `toppings:` list. The `range` function will
"range over" (iterate through) the `pizzaToppings` list. But now something
interesting happens. Just like `with` sets the scope of `.`, so does a `range`
operator. Each time through the loop, `.` is set to the current pizza topping.
That is, the first time, `.` is set to `mushrooms`. The second iteration it is
set to `cheese`, and so on.

We can send the value of `.` directly down a pipeline, so when we do `{{ . |
title | quote }}`, it sends `.` to `title` (title case function) and then to
`quote`. If we run this template, the output will be:

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: edgy-dragonfly-configmap
data:
  myvalue: "Hello World"
  drink: "coffee"
  food: "PIZZA"
  toppings: |-
    - "Mushrooms"
    - "Cheese"
    - "Peppers"
    - "Onions"
    - "Pineapple"
```

Now, in this example we've done something tricky. The `toppings: |-` line is
declaring a multi-line string. So our list of toppings is actually not a YAML
list. It's a big string. Why would we do this? Because the data in ConfigMaps
`data` is composed of key/value pairs, where both the key and the value are
simple strings. To understand why this is the case, take a look at the
[Kubernetes ConfigMap docs](https://kubernetes.io/docs/concepts/configuration/configmap/).
For us, though, this detail doesn't matter much.

> The `|-` marker in YAML takes a multi-line string. This can be a useful
> technique for embedding big blocks of data inside of your manifests, as
> exemplified here.

Sometimes it's useful to be able to quickly make a list inside of your template,
and then iterate over that list. Helm templates have a function to make this
easy: `tuple`. In computer science, a tuple is a list-like collection of fixed
size, but with arbitrary data types. This roughly conveys the way a `tuple` is
used.

```yaml
  sizes: |-
    {{- range tuple "small" "medium" "large" }}
    - {{ . }}
    {{- end }}
```

The above will produce this:

```yaml
  sizes: |-
    - small
    - medium
    - large
```

In addition to lists and tuples, `range` can be used to iterate over collections
that have a key and a value (like a `map` or `dict`). We'll see how to do that
in the next section when we introduce template variables.
</file>

<file path="chart_template_guide/data_types.md">
---
title: "Appendix: Go Data Types and Templates"
description: A quick overview on variables in templates.
sidebar_position: 16
---

The Helm template language is implemented in the strongly typed Go programming
language. For that reason, variables in templates are _typed_. For the most
part, variables will be exposed as one of the following types:

- string: A string of text
- bool: a `true` or `false`
- int: An integer value (there are also 8, 16, 32, and 64 bit signed and
  unsigned variants of this)
- float64: a 64-bit floating point value (there are also 8, 16, and 32 bit
  varieties of this)
- a byte slice (`[]byte`), often used to hold (potentially) binary data
- struct: an object with properties and methods
- a slice (indexed list) of one of the previous types
- a string-keyed map (`map[string]interface{}`) where the value is one of the
  previous types

There are many other types in Go, and sometimes you will have to convert between
them in your templates. The easiest way to debug an object's type is to pass it
through `printf "%T"` in a template, which will print the type. Also see the
`typeOf` and `kindOf` functions.
</file>

<file path="chart_template_guide/debugging.md">
---
title: Debugging Templates
description: Troubleshooting charts that are failing to deploy.
sidebar_position: 13
---

Debugging templates can be tricky because the rendered templates are sent to the
Kubernetes API server, which may reject the YAML files for reasons other than
formatting.

There are a few commands that can help you debug.

- `helm lint` is your go-to tool for verifying that your chart follows best
  practices
- `helm template --debug` will test rendering chart templates locally.  
- `helm install --dry-run --debug` will also render your chart locally without
installing it, but will also check if conflicting resources are already running
on the cluster. Setting `--dry-run=server` will additionally execute any
`lookup` in your chart towards the server.
- `helm get manifest`: This is a good way to see what templates are installed on
  the server.

When your YAML is failing to parse, but you want to see what is generated, one
easy way to retrieve the YAML is to comment out the problem section in the
template, and then re-run `helm install --dry-run --debug`:

```yaml
apiVersion: v2
# some: problem section
# {{ .Values.foo | quote }}
```

The above will be rendered and returned with the comments intact:

```yaml
apiVersion: v2
# some: problem section
#  "bar"
```

This provides a quick way of viewing the generated content without YAML parse
errors blocking.
</file>

<file path="chart_template_guide/functions_and_pipelines.mdx">
---
title: Template Functions and Pipelines
description: Using functions in templates.
sidebar_position: 5
---

import Helm4 from "/docs/_v4-in-progress.mdx"

<Helm4/>

So far, we've seen how to place information into a template. But that
information is placed into the template unmodified. Sometimes we want to
transform the supplied data in a way that makes it more useable to us.

Let's start with a best practice: When injecting strings from the `.Values`
object into the template, we ought to quote these strings. We can do that by
calling the `quote` function in the template directive:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ quote .Values.favorite.drink }}
  food: {{ quote .Values.favorite.food }}
```

Template functions follow the syntax `functionName arg1 arg2...`. In the snippet
above, `quote .Values.favorite.drink` calls the `quote` function and passes it a
single argument.

Helm has over 60 available functions. Some of them are defined by the [Go
template language](https://godoc.org/text/template) itself. Most of the others
are part of the [Sprig template library](https://masterminds.github.io/sprig/).
We'll see many of them as we progress through the examples.

> While we talk about the "Helm template language" as if it is Helm-specific, it
> is actually a combination of the Go template language, some extra functions,
> and a variety of wrappers to expose certain objects to the templates. Many
> resources on Go templates may be helpful as you learn about templating.

## Pipelines

One of the powerful features of the template language is its concept of
_pipelines_. Drawing on a concept from UNIX, pipelines are a tool for chaining
together a series of template commands to compactly express a series of
transformations. In other words, pipelines are an efficient way of getting
several things done in sequence. Let's rewrite the above example using a
pipeline.

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ .Values.favorite.drink | quote }}
  food: {{ .Values.favorite.food | quote }}
```

In this example, instead of calling `quote ARGUMENT`, we inverted the order. We
"sent" the argument to the function using a pipeline (`|`):
`.Values.favorite.drink | quote`. Using pipelines, we can chain several
functions together:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ .Values.favorite.drink | quote }}
  food: {{ .Values.favorite.food | upper | quote }}
```

> Inverting the order is a common practice in templates. You will see `.val |
> quote` more often than `quote .val`. Either practice is fine.

When evaluated, that template will produce this:

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: trendsetting-p-configmap
data:
  myvalue: "Hello World"
  drink: "coffee"
  food: "PIZZA"
```

Note that our original `pizza` has now been transformed to `"PIZZA"`.

When pipelining arguments like this, the result of the first evaluation
(`.Values.favorite.drink`) is sent as the _last argument to the function_. We
can modify the drink example above to illustrate with a function that takes two
arguments: `repeat COUNT STRING`:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ .Values.favorite.drink | repeat 5 | quote }}
  food: {{ .Values.favorite.food | upper | quote }}
```

The `repeat` function will echo the given string the given number of times, so
we will get this for output:

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: melting-porcup-configmap
data:
  myvalue: "Hello World"
  drink: "coffeecoffeecoffeecoffeecoffee"
  food: "PIZZA"
```

## Using the `default` function

One function frequently used in templates is the `default` function: `default
DEFAULT_VALUE GIVEN_VALUE`. This function allows you to specify a default value
inside of the template, in case the value is omitted. Let's use it to modify the
drink example above:

```yaml
drink: {{ .Values.favorite.drink | default "tea" | quote }}
```

If we run this as normal, we'll get our `coffee`:

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: virtuous-mink-configmap
data:
  myvalue: "Hello World"
  drink: "coffee"
  food: "PIZZA"
```

Now, we will remove the favorite drink setting from `values.yaml`:

```yaml
favorite:
  #drink: coffee
  food: pizza
```

Now re-running `helm install --dry-run --debug fair-worm ./mychart` will produce
this YAML:

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: fair-worm-configmap
data:
  myvalue: "Hello World"
  drink: "tea"
  food: "PIZZA"
```

In an actual chart, all static default values should live in the `values.yaml`,
and should not be repeated using the `default` command (otherwise they would be
redundant). However, the `default` command is perfect for computed values, which
cannot be declared inside `values.yaml`. For example:

```yaml
drink: {{ .Values.favorite.drink | default (printf "%s-tea" (include "fullname" .)) }}
```

In some places, an `if` conditional guard may be better suited than `default`.
We'll see those in the next section.

Template functions and pipelines are a powerful way to transform information and
then insert it into your YAML. But sometimes it's necessary to add some template
logic that is a little more sophisticated than just inserting a string. In the
next section we will look at the control structures provided by the template
language.

## Using the `lookup` function

The `lookup` function can be used to _look up_ resources in a running cluster.
The synopsis of the lookup function is `lookup apiVersion, kind, namespace, name
-> resource or resource list`.

| parameter  | type   |
|------------|--------|
| apiVersion | string |
| kind       | string |
| namespace  | string |
| name       | string |

Both `name` and `namespace` are optional and can be passed as an empty string
(`""`). However, if you're working with a namespace-scoped resource, both `name`
and `namespace` must be specified.

The following combination of parameters are possible:

| Behavior                               | Lookup function                            |
|----------------------------------------|--------------------------------------------|
| `kubectl get pod mypod -n mynamespace` | `lookup "v1" "Pod" "mynamespace" "mypod"`  |
| `kubectl get pods -n mynamespace`      | `lookup "v1" "Pod" "mynamespace" ""`       |
| `kubectl get pods --all-namespaces`    | `lookup "v1" "Pod" "" ""`                  |
| `kubectl get namespace mynamespace`    | `lookup "v1" "Namespace" "" "mynamespace"` |
| `kubectl get namespaces`               | `lookup "v1" "Namespace" "" ""`            |

When `lookup` returns an object, it will return a dictionary. This dictionary
can be further navigated to extract specific values.

The following example will return the annotations present for the `mynamespace`
object:

```go
(lookup "v1" "Namespace" "" "mynamespace").metadata.annotations
```

When `lookup` returns a list of objects, it is possible to access the object
list via the `items` field:

```go
{{ range $index, $service := (lookup "v1" "Service" "mynamespace" "").items }}
    {{/* do something with each service */}}
{{ end }}
```

When no object is found, an empty value is returned. This can be used to check
for the existence of an object.

The `lookup` function uses Helm's existing Kubernetes connection configuration
to query Kubernetes. If any error is returned when interacting with calling the
API server (for example due to lack of permission to access a resource), Helm's
template processing will fail.

Keep in mind that Helm is not supposed to contact the Kubernetes API Server during 
a `helm template|install|upgrade|delete|rollback --dry-run` operation. To test `lookup` 
against a running cluster, `helm template|install|upgrade|delete|rollback --dry-run=server`
should be used instead to allow cluster connection.

## Operators are functions

For templates, the operators (`eq`, `ne`, `lt`, `gt`, `and`, `or` and so on) are
all implemented as functions. In pipelines, operations can be grouped with
parentheses (`(`, and `)`).

Now we can turn from functions and pipelines to flow control with conditions,
loops, and scope modifiers.
</file>

<file path="chart_template_guide/getting_started.md">
---
title: Getting Started
description: A quick guide on Chart templates.
sidebar_position: 2
---

In this section of the guide, we'll create a chart and then add a first
template. The chart we created here will be used throughout the rest of the
guide.

To get going, let's take a brief look at a Helm chart.

## Charts

As described in the [Charts Guide](/topics/charts.mdx), Helm charts are
structured like this:

```
mychart/
  Chart.yaml
  values.yaml
  charts/
  templates/
  ...
```

The `templates/` directory is for template files. When Helm evaluates a chart,
it will send all of the files in the `templates/` directory through the template
rendering engine. It then collects the results of those templates and sends them
on to Kubernetes.

The `values.yaml` file is also important to templates. This file contains the
_default values_ for a chart. These values may be overridden by users during
`helm install` or `helm upgrade`.

The `Chart.yaml` file contains a description of the chart. You can access it
from within a template.

The `charts/` directory _may_ contain other charts
(which we call _subcharts_). Later in this guide we will see how those work when
it comes to template rendering.

## A Starter Chart

For this guide, we'll create a simple chart called `mychart`, and then we'll
create some templates inside of the chart.

```console
$ helm create mychart
Creating mychart
```

### A Quick Glimpse of `mychart/templates/`

If you take a look at the `mychart/templates/` directory, you'll notice a few
files already there.

- `NOTES.txt`: The "help text" for your chart. This will be displayed to your
  users when they run `helm install`.
- `deployment.yaml`: A basic manifest for creating a Kubernetes
  [deployment](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)
- `service.yaml`: A basic manifest for creating a [service
  endpoint](https://kubernetes.io/docs/concepts/services-networking/service/) for your deployment
- `_helpers.tpl`: A place to put template helpers that you can re-use throughout
  the chart

And what we're going to do is... _remove them all!_ That way we can work through
our tutorial from scratch. We'll actually create our own `NOTES.txt` and
`_helpers.tpl` as we go.

```console
$ rm -rf mychart/templates/*
```

When you're writing production grade charts, having basic versions of these
charts can be really useful. So in your day-to-day chart authoring, you probably
won't want to remove them.

## A First Template

The first template we are going to create will be a `ConfigMap`. In Kubernetes,
a ConfigMap is simply an object for storing configuration data. Other things,
like pods, can access the data in a ConfigMap.

Because ConfigMaps are basic resources, they make a great starting point for us.

Let's begin by creating a file called `mychart/templates/configmap.yaml`:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mychart-configmap
data:
  myvalue: "Hello World"
```

**TIP:** Template names do not follow a rigid naming pattern. However, we
recommend using the extension `.yaml` for YAML files and `.tpl` for helpers.

The YAML file above is a bare-bones ConfigMap, having the minimal necessary
fields. By virtue of the fact that this file is in the `mychart/templates/`
directory, it will be sent through the template engine.

It is just fine to put a plain YAML file like this in the `mychart/templates/`
directory. When Helm reads this template, it will simply send it to Kubernetes
as-is.

With this simple template, we now have an installable chart. And we can install
it like this:

```console
$ helm install full-coral ./mychart
NAME: full-coral
LAST DEPLOYED: Tue Nov  1 17:36:01 2016
NAMESPACE: default
STATUS: DEPLOYED
REVISION: 1
TEST SUITE: None
```

Using Helm, we can retrieve the release and see the actual template that was
loaded.

```console
$ helm get manifest full-coral

---
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mychart-configmap
data:
  myvalue: "Hello World"
```

The `helm get manifest` command takes a release name (`full-coral`) and prints
out all of the Kubernetes resources that were uploaded to the server. Each file
begins with `---` to indicate the start of a YAML document, and then is followed
by an automatically generated comment line that tells us what template file
generated this YAML document.

From there on, we can see that the YAML data is exactly what we put in our
`configmap.yaml` file.

Now we can uninstall our release: `helm uninstall full-coral`.

### Adding a Simple Template Call

Hard-coding the `name:` into a resource is usually considered to be bad
practice. Names should be unique to a release. So we might want to generate a
name field by inserting the release name.

**TIP:** The `name:` field is limited to 63 characters because of limitations to
the DNS system. For that reason, release names are limited to 53 characters.
Kubernetes 1.3 and earlier limited to only 24 characters (thus 14 character
names).

Let's alter `configmap.yaml` accordingly.

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
```

The big change comes in the value of the `name:` field, which is now
`{{ .Release.Name }}-configmap`.

> A template directive is enclosed in `{{` and `}}` blocks.

The template directive `{{ .Release.Name }}` injects the release name into the
template. The values that are passed into a template can be thought of as
_namespaced objects_, where a dot (`.`) separates each namespaced element.

The leading dot before `Release` indicates that we start with the top-most
namespace for this scope (we'll talk about scope in a bit). So we could read
`.Release.Name` as "start at the top namespace, find the `Release` object, then
look inside of it for an object called `Name`".

The `Release` object is one of the built-in objects for Helm, and we'll cover it
in more depth later. But for now, it is sufficient to say that this will display
the release name that the library assigns to our release.

Now when we install our resource, we'll immediately see the result of using this
template directive:

```console
$ helm install clunky-serval ./mychart
NAME: clunky-serval
LAST DEPLOYED: Tue Nov  1 17:45:37 2016
NAMESPACE: default
STATUS: DEPLOYED
REVISION: 1
TEST SUITE: None
```

You can run `helm get manifest clunky-serval` to see the entire generated YAML.

Note that the ConfigMap inside Kubernetes name is `clunky-serval-configmap`
instead of `mychart-configmap` previously.

At this point, we've seen templates at their most basic: YAML files that have
template directives embedded in `{{` and `}}`. In the next part, we'll take a
deeper look into templates. But before moving on, there's one quick trick that
can make building templates faster: When you want to test the template
rendering, but not actually install anything, you can use `helm install --debug
--dry-run goodly-guppy ./mychart`. This will render the templates. But instead
of installing the chart, it will return the rendered template to you so you can
see the output:

```console
$ helm install --debug --dry-run goodly-guppy ./mychart
install.go:149: [debug] Original chart version: ""
install.go:166: [debug] CHART PATH: /Users/ninja/mychart

NAME: goodly-guppy
LAST DEPLOYED: Thu Dec 26 17:24:13 2019
NAMESPACE: default
STATUS: pending-install
REVISION: 1
TEST SUITE: None
USER-SUPPLIED VALUES:
{}

COMPUTED VALUES:
affinity: {}
fullnameOverride: ""
image:
  pullPolicy: IfNotPresent
  repository: nginx
imagePullSecrets: []
ingress:
  annotations: {}
  enabled: false
  hosts:
  - host: chart-example.local
    paths: []
  tls: []
nameOverride: ""
nodeSelector: {}
podSecurityContext: {}
replicaCount: 1
resources: {}
securityContext: {}
service:
  port: 80
  type: ClusterIP
serviceAccount:
  create: true
  name: null
tolerations: []

HOOKS:
MANIFEST:
---
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: goodly-guppy-configmap
data:
  myvalue: "Hello World"

```

Using `--dry-run` will make it easier to test your code, but it won't ensure
that Kubernetes itself will accept the templates you generate. It's best not to
assume that your chart will install just because `--dry-run` works.

In the [Chart Template Guide](/chart_template_guide/index.mdx), we take the basic chart we defined
here and explore the Helm template language in detail. And we'll get started
with built-in objects.
</file>

<file path="chart_template_guide/helm_ignore_file.md">
---
title: The .helmignore file
description: The `.helmignore` file is used to specify files you don't want to include in your helm chart.
sidebar_position: 12
---

The `.helmignore` file is used to specify files you don't want to include in
your helm chart.

If this file exists, the `helm package` command will ignore all the files that
match the pattern specified in the `.helmignore` file while packaging your
application.

This can help in avoiding unnecessary or sensitive files or directories from
being added in your helm chart.

The `.helmignore` file supports Unix shell glob matching, relative path
matching, and negation (prefixed with !). Only one pattern per line is
considered.

Here is an example `.helmignore` file:

```
# comment

# Match any file or path named .helmignore
.helmignore

# Match any file or path named .git
.git

# Match any text file
*.txt

# Match only directories named mydir
mydir/

# Match only text files in the top-level directory
/*.txt

# Match only the file foo.txt in the top-level directory
/foo.txt

# Match any file named ab.txt, ac.txt, or ad.txt
a[b-d].txt

# Match any file under subdir matching temp*
*/temp*

*/*/temp*
temp?
```

Some notable differences from .gitignore:
- The '**' syntax is not supported.
- The globbing library is Go's 'filepath.Match', not fnmatch(3)
- Trailing spaces are always ignored (there is no supported escape sequence)
- There is no support for '\!' as a special leading sequence.
- It does not exclude itself by default, you have to add an explicit entry for `.helmignore`


**We'd love your help** making this document better. To add, correct, or remove
information, [file an issue](https://github.com/helm/helm-www/issues) or send us a
pull request.
</file>

<file path="chart_template_guide/index.mdx">
---
title: Chart Template Guide
sidebar_position: 5
---

# The Chart Template Developer's Guide

This guide provides an introduction to Helm's chart templates, with emphasis on
the template language.

Templates generate manifest files, which are YAML-formatted resource
descriptions that Kubernetes can understand. We'll look at how templates are
structured, how they can be used, how to write Go templates, and how to debug
your work.

This guide focuses on the following concepts:

- The Helm template language
- Using values
- Techniques for working with templates

This guide is oriented toward learning the ins and outs of the Helm template
language. Other guides provide introductory material, examples, and best
practices.


import DocCardList from '@theme/DocCardList';

<DocCardList />
</file>

<file path="chart_template_guide/named_templates.md">
---
title: Named Templates
description: How to define named templates.
sidebar_position: 9
---

It is time to move beyond one template, and begin to create others. In this
section, we will see how to define _named templates_ in one file, and then use
them elsewhere. A _named template_ (sometimes called a _partial_ or a
_subtemplate_) is simply a template defined inside of a file, and given a name.
We'll see two ways to create them, and a few different ways to use them.

In the [Flow Control](/chart_template_guide/control_structures.md) section we introduced three actions
for declaring and managing templates: `define`, `template`, and `block`. In this
section, we'll cover those three actions, and also introduce a special-purpose
`include` function that works similarly to the `template` action.

An important detail to keep in mind when naming templates: **template names are
global**. If you declare two templates with the same name, whichever one is
loaded last will be the one used. Because templates in subcharts are compiled
together with top-level templates, you should be careful to name your templates
with _chart-specific names_.

One popular naming convention is to prefix each defined template with the name
of the chart: `{{ define "mychart.labels" }}`. By using the specific chart name
as a prefix we can avoid any conflicts that may arise due to two different
charts that implement templates of the same name.

This behavior also applies to different versions of a chart. If you have
`mychart` version `1.0.0` that defines a template one way, and a `mychart`
version `2.0.0` that modifies the existing named template, it will use the one
that was loaded last. You can work around this issue by also adding a version
in the name of the chart: `{{ define "mychart.v1.labels" }}` and
`{{ define "mychart.v2.labels" }}`.

## Partials and `_` files

So far, we've used one file, and that one file has contained a single template.
But Helm's template language allows you to create named embedded templates, that
can be accessed by name elsewhere.

Before we get to the nuts-and-bolts of writing those templates, there is file
naming convention that deserves mention:

* Most files in `templates/` are treated as if they contain Kubernetes manifests
* The `NOTES.txt` is one exception
* But files whose name begins with an underscore (`_`) are assumed to _not_ have
  a manifest inside. These files are not rendered to Kubernetes object
  definitions, but are available everywhere within other chart templates for
  use.

These files are used to store partials and helpers. In fact, when we first
created `mychart`, we saw a file called `_helpers.tpl`. That file is the default
location for template partials.

## Declaring and using templates with `define` and `template`

The `define` action allows us to create a named template inside of a template
file. Its syntax goes like this:

```yaml
{{- define "MY.NAME" }}
  # body of template here
{{- end }}
```

For example, we can define a template to encapsulate a Kubernetes block of
labels:

```yaml
{{- define "mychart.labels" }}
  labels:
    generator: helm
    date: {{ now | htmlDate }}
{{- end }}
```

Now we can embed this template inside of our existing ConfigMap, and then
include it with the `template` action:

```yaml
{{- define "mychart.labels" }}
  labels:
    generator: helm
    date: {{ now | htmlDate }}
{{- end }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  {{- template "mychart.labels" }}
data:
  myvalue: "Hello World"
  {{- range $key, $val := .Values.favorite }}
  {{ $key }}: {{ $val | quote }}
  {{- end }}
```

When the template engine reads this file, it will store away the reference to
`mychart.labels` until `template "mychart.labels"` is called. Then it will
render that template inline. So the result will look like this:

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: running-panda-configmap
  labels:
    generator: helm
    date: 2016-11-02
data:
  myvalue: "Hello World"
  drink: "coffee"
  food: "pizza"
```

Note: a `define` does not produce output unless it is called with a template,
as in this example.

Conventionally, Helm charts put these templates inside of a partials file,
usually `_helpers.tpl`. Let's move this function there:

```yaml
{{/* Generate basic labels */}}
{{- define "mychart.labels" }}
  labels:
    generator: helm
    date: {{ now | htmlDate }}
{{- end }}
```

By convention, `define` functions should have a simple documentation block
(`{{/* ... */}}`) describing what they do.

Even though this definition is in `_helpers.tpl`, it can still be accessed in
`configmap.yaml`:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  {{- template "mychart.labels" }}
data:
  myvalue: "Hello World"
  {{- range $key, $val := .Values.favorite }}
  {{ $key }}: {{ $val | quote }}
  {{- end }}
```

As mentioned above, **template names are global**. As a result of this, if two
templates are declared with the same name the last occurrence will be the one
that is used. Since templates in subcharts are compiled together with top-level
templates, it is best to name your templates with _chart specific names_. A
popular naming convention is to prefix each defined template with the name of
the chart: `{{ define "mychart.labels" }}`.

## Setting the scope of a template

In the template we defined above, we did not use any objects. We just used
functions. Let's modify our defined template to include the chart name and chart
version:

```yaml
{{/* Generate basic labels */}}
{{- define "mychart.labels" }}
  labels:
    generator: helm
    date: {{ now | htmlDate }}
    chart: {{ .Chart.Name }}
    version: {{ .Chart.Version }}
{{- end }}
```

If we render this, we will get an error like this:

```console
$ helm install --dry-run moldy-jaguar ./mychart
Error: unable to build kubernetes objects from release manifest: error validating "": error validating data: [unknown object type "nil" in ConfigMap.metadata.labels.chart, unknown object type "nil" in ConfigMap.metadata.labels.version]
```

To see what rendered, re-run with `--disable-openapi-validation`:
`helm install --dry-run --disable-openapi-validation moldy-jaguar ./mychart`.
The result will not be what we expect:

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: moldy-jaguar-configmap
  labels:
    generator: helm
    date: 2021-03-06
    chart:
    version:
```

What happened to the name and version? They weren't in the scope for our defined
template. When a named template (created with `define`) is rendered, it will
receive the scope passed in by the `template` call. In our example, we included
the template like this:

```yaml
{{- template "mychart.labels" }}
```

No scope was passed in, so within the template we cannot access anything in `.`.
This is easy enough to fix, though. We simply pass a scope to the template:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  {{- template "mychart.labels" . }}
```

Note that we pass `.` at the end of the `template` call. We could just as easily
pass `.Values` or `.Values.favorite` or whatever scope we want. But what we want
is the top-level scope. In the context of the named template, `$` will refer
to the scope you passed in and not some global scope.

Now when we execute this template with `helm install --dry-run --debug
plinking-anaco ./mychart`, we get this:

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: plinking-anaco-configmap
  labels:
    generator: helm
    date: 2021-03-06
    chart: mychart
    version: 0.1.0
```

Now `{{ .Chart.Name }}` resolves to `mychart`, and `{{ .Chart.Version }}`
resolves to `0.1.0`.

## The `include` function

Say we've defined a simple template that looks like this:

```yaml
{{- define "mychart.app" -}}
app_name: {{ .Chart.Name }}
app_version: "{{ .Chart.Version }}"
{{- end -}}
```

Now say I want to insert this both into the `labels:` section of my template,
and also the `data:` section:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  labels:
    {{ template "mychart.app" . }}
data:
  myvalue: "Hello World"
  {{- range $key, $val := .Values.favorite }}
  {{ $key }}: {{ $val | quote }}
  {{- end }}
{{ template "mychart.app" . }}
```

If we render this, we will get an error like this:

```console
$ helm install --dry-run measly-whippet ./mychart
Error: unable to build kubernetes objects from release manifest: error validating "": error validating data: [ValidationError(ConfigMap): unknown field "app_name" in io.k8s.api.core.v1.ConfigMap, ValidationError(ConfigMap): unknown field "app_version" in io.k8s.api.core.v1.ConfigMap]
```

To see what rendered, re-run with `--disable-openapi-validation`:
`helm install --dry-run --disable-openapi-validation measly-whippet ./mychart`.
The output will not be what we expect:

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: measly-whippet-configmap
  labels:
    app_name: mychart
app_version: "0.1.0"
data:
  myvalue: "Hello World"
  drink: "coffee"
  food: "pizza"
app_name: mychart
app_version: "0.1.0"
```

Note that the indentation on `app_version` is wrong in both places. Why? Because
the template that is substituted in has the text aligned to the left. Because
`template` is an action, and not a function, there is no way to pass the output
of a `template` call to other functions; the data is simply inserted inline.

To work around this case, Helm provides an alternative to `template` that will
import the contents of a template into the present pipeline where it can be
passed along to other functions in the pipeline.

Here's the example above, corrected to use `indent` to indent the `mychart.app`
template correctly:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  labels:
{{ include "mychart.app" . | indent 4 }}
data:
  myvalue: "Hello World"
  {{- range $key, $val := .Values.favorite }}
  {{ $key }}: {{ $val | quote }}
  {{- end }}
{{ include "mychart.app" . | indent 2 }}
```

Now the produced YAML is correctly indented for each section:

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: edgy-mole-configmap
  labels:
    app_name: mychart
    app_version: "0.1.0"
data:
  myvalue: "Hello World"
  drink: "coffee"
  food: "pizza"
  app_name: mychart
  app_version: "0.1.0"
```

> It is considered preferable to use `include` over `template` in Helm templates
> simply so that the output formatting can be handled better for YAML documents.

Sometimes we want to import content, but not as templates. That is, we want to
import files verbatim. We can achieve this by accessing files through the
`.Files` object described in the next section.
</file>

<file path="chart_template_guide/notes_files.md">
---
title: Creating a NOTES.txt File
description: How to provide instructions to your Chart users.
sidebar_position: 10
---

In this section we are going to look at Helm's tool for providing instructions
to your chart users. At the end of a `helm install` or `helm upgrade`, Helm can
print out a block of helpful information for users. This information is highly
customizable using templates.

To add installation notes to your chart, simply create a `templates/NOTES.txt`
file. This file is plain text, but it is processed like a template, and has
all the normal template functions and objects available.

Let's create a simple `NOTES.txt` file:

```
Thank you for installing {{ .Chart.Name }}.

Your release is named {{ .Release.Name }}.

To learn more about the release, try:

  $ helm status {{ .Release.Name }}
  $ helm get all {{ .Release.Name }}

```

Now if we run `helm install rude-cardinal ./mychart` we will see this message at
the bottom:

```
RESOURCES:
==> v1/Secret
NAME                   TYPE      DATA      AGE
rude-cardinal-secret   Opaque    1         0s

==> v1/ConfigMap
NAME                      DATA      AGE
rude-cardinal-configmap   3         0s


NOTES:
Thank you for installing mychart.

Your release is named rude-cardinal.

To learn more about the release, try:

  $ helm status rude-cardinal
  $ helm get all rude-cardinal
```

Using `NOTES.txt` this way is a great way to give your users detailed
information about how to use their newly installed chart. Creating a `NOTES.txt`
file is strongly recommended, though it is not required.
</file>

<file path="chart_template_guide/subcharts_and_globals.md">
---
title: Subcharts and Global Values
description: Interacting with a subchart's and global values.
sidebar_position: 11
---

To this point we have been working only with one chart. But charts can have
dependencies, called _subcharts_, that also have their own values and templates.
In this section we will create a subchart and see the different ways we can
access values from within templates.

Before we dive into the code, there are a few important details to learn about application subcharts.

1. A subchart is considered "stand-alone", which means a subchart can never
   explicitly depend on its parent chart.
2. For that reason, a subchart cannot access the values of its parent.
3. A parent chart can override values for subcharts.
4. Helm has a concept of _global values_ that can be accessed by all charts.

> These limitations do not all necessarily apply to [library charts](/topics/library_charts.md), which are designed to provide standardized helper functionality.

As we walk through the examples in this section, many of these concepts will
become clearer.

## Creating a Subchart

For these exercises, we'll start with the `mychart/` chart we created at the
beginning of this guide, and we'll add a new chart inside of it.

```console
$ cd mychart/charts
$ helm create mysubchart
Creating mysubchart
$ rm -rf mysubchart/templates/*
```

Notice that just as before, we deleted all of the base templates so that we can
start from scratch. In this guide, we are focused on how templates work, not on
managing dependencies. But the [Charts Guide](/topics/charts.mdx)
has more information on how subcharts work.

## Adding Values and a Template to the Subchart

Next, let's create a simple template and values file for our `mysubchart` chart.
There should already be a `values.yaml` in `mychart/charts/mysubchart`. We'll
set it up like this:

```yaml
dessert: cake
```

Next, we'll create a new ConfigMap template in
`mychart/charts/mysubchart/templates/configmap.yaml`:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-cfgmap2
data:
  dessert: {{ .Values.dessert }}
```

Because every subchart is a _stand-alone chart_, we can test `mysubchart` on its
own:

```console
$ helm install --generate-name --dry-run --debug mychart/charts/mysubchart
SERVER: "localhost:44134"
CHART PATH: /Users/mattbutcher/Code/Go/src/helm.sh/helm/_scratch/mychart/charts/mysubchart
NAME:   newbie-elk
TARGET NAMESPACE:   default
CHART:  mysubchart 0.1.0
MANIFEST:
---
# Source: mysubchart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: newbie-elk-cfgmap2
data:
  dessert: cake
```

## Overriding Values from a Parent Chart

Our original chart, `mychart` is now the _parent_ chart of `mysubchart`. This
relationship is based entirely on the fact that `mysubchart` is within
`mychart/charts`.

Because `mychart` is a parent, we can specify configuration in `mychart` and
have that configuration pushed into `mysubchart`. For example, we can modify
`mychart/values.yaml` like this:

```yaml
favorite:
  drink: coffee
  food: pizza
pizzaToppings:
  - mushrooms
  - cheese
  - peppers
  - onions

mysubchart:
  dessert: ice cream
```

Note the last two lines. Any directives inside of the `mysubchart` section will
be sent to the `mysubchart` chart. So if we run `helm install --generate-name --dry-run --debug
mychart`, one of the things we will see is the `mysubchart` ConfigMap:

```yaml
# Source: mychart/charts/mysubchart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: unhinged-bee-cfgmap2
data:
  dessert: ice cream
```

The value at the top level has now overridden the value of the subchart.

There's an important detail to notice here. We didn't change the template of
`mychart/charts/mysubchart/templates/configmap.yaml` to point to
`.Values.mysubchart.dessert`. From that template's perspective, the value is
still located at `.Values.dessert`. As the template engine passes values along,
it sets the scope. So for the `mysubchart` templates, only values specifically
for `mysubchart` will be available in `.Values`.

Sometimes, though, you do want certain values to be available to all of the
templates. This is accomplished using global chart values.

## Global Chart Values

Global values are values that can be accessed from any chart or subchart by
exactly the same name. Globals require explicit declaration. You can't use an
existing non-global as if it were a global.

The Values data type has a reserved section called `Values.global` where global
values can be set. Let's set one in our `mychart/values.yaml` file.

```yaml
favorite:
  drink: coffee
  food: pizza
pizzaToppings:
  - mushrooms
  - cheese
  - peppers
  - onions

mysubchart:
  dessert: ice cream

global:
  salad: caesar
```

Because of the way globals work, both `mychart/templates/configmap.yaml` and
`mysubchart/templates/configmap.yaml` should be able to access that value as
`{{ .Values.global.salad }}`.

`mychart/templates/configmap.yaml`:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  salad: {{ .Values.global.salad }}
```

`mysubchart/templates/configmap.yaml`:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-cfgmap2
data:
  dessert: {{ .Values.dessert }}
  salad: {{ .Values.global.salad }}
```

Now if we run a dry run install, we'll see the same value in both outputs:

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: silly-snake-configmap
data:
  salad: caesar

---
# Source: mychart/charts/mysubchart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: silly-snake-cfgmap2
data:
  dessert: ice cream
  salad: caesar
```

Globals are useful for passing information like this, though it does take some
planning to make sure the right templates are configured to use globals.

## Sharing Templates with Subcharts

Parent charts and subcharts can share templates. Any defined block in any chart
is available to other charts.

For example, we can define a simple template like this:

```yaml
{{- define "labels" }}from: mychart{{ end }}
```

Recall how the labels on templates are _globally shared_. Thus, the `labels`
chart can be included from any other chart.

While chart developers have a choice between `include` and `template`, one
advantage of using `include` is that `include` can dynamically reference
templates:

```yaml
{{ include $mytemplate }}
```

The above will dereference `$mytemplate`. The `template` function, in contrast,
will only accept a string literal.

## Avoid Using Blocks

The Go template language provides a `block` keyword that allows developers to
provide a default implementation which is overridden later. In Helm charts,
blocks are not the best tool for overriding because if multiple implementations
of the same block are provided, the one selected is unpredictable.

The suggestion is to instead use `include`.
</file>

<file path="chart_template_guide/values_files.mdx">
---
title: Values Files
description: Instructions on how to use the --values flag.
sidebar_position: 4
---

import Helm4 from "/docs/_v4-in-progress.mdx"

<Helm4/>

In the previous section we looked at the built-in objects that Helm templates
offer. One of the built-in objects is `Values`. This object provides access to
values passed into the chart. Its contents come from multiple sources:

- The `values.yaml` file in the chart
- If this is a subchart, the `values.yaml` file of a parent chart
- A values file is passed into `helm install` or `helm upgrade` with the `-f`
  flag (`helm install -f myvals.yaml ./mychart`)
- Individual parameters are passed with `--set` (such as `helm install --set foo=bar
  ./mychart`)

The list above is in order of specificity: `values.yaml` is the default, which
can be overridden by a parent chart's `values.yaml`, which can in turn be
overridden by a user-supplied values file, which can in turn be overridden by
`--set` parameters.

Values files are plain YAML files. Let's edit `mychart/values.yaml` and then
edit our ConfigMap template.

Removing the defaults in `values.yaml`, we'll set just one parameter:

```yaml
favoriteDrink: coffee
```

Now we can use this inside of a template:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ .Values.favoriteDrink }}
```

Notice on the last line we access `favoriteDrink` as an attribute of `Values`:
`{{ .Values.favoriteDrink }}`.

Let's see how this renders.

```console
$ helm install geared-marsupi ./mychart --dry-run --debug
install.go:158: [debug] Original chart version: ""
install.go:175: [debug] CHART PATH: /home/bagratte/src/playground/mychart

NAME: geared-marsupi
LAST DEPLOYED: Wed Feb 19 23:21:13 2020
NAMESPACE: default
STATUS: pending-install
REVISION: 1
TEST SUITE: None
USER-SUPPLIED VALUES:
{}

COMPUTED VALUES:
favoriteDrink: coffee

HOOKS:
MANIFEST:
---
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: geared-marsupi-configmap
data:
  myvalue: "Hello World"
  drink: coffee
```

Because `favoriteDrink` is set in the default `values.yaml` file to `coffee`,
that's the value displayed in the template. We can easily override that by
adding a `--set` flag in our call to `helm install`:

```console
$ helm install solid-vulture ./mychart --dry-run --debug --set favoriteDrink=slurm
install.go:158: [debug] Original chart version: ""
install.go:175: [debug] CHART PATH: /home/bagratte/src/playground/mychart

NAME: solid-vulture
LAST DEPLOYED: Wed Feb 19 23:25:54 2020
NAMESPACE: default
STATUS: pending-install
REVISION: 1
TEST SUITE: None
USER-SUPPLIED VALUES:
favoriteDrink: slurm

COMPUTED VALUES:
favoriteDrink: slurm

HOOKS:
MANIFEST:
---
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: solid-vulture-configmap
data:
  myvalue: "Hello World"
  drink: slurm
```

Since `--set` has a higher precedence than the default `values.yaml` file, our
template generates `drink: slurm`.

Values files can contain more structured content, too. For example, we could
create a `favorite` section in our `values.yaml` file, and then add several keys
there:

```yaml
favorite:
  drink: coffee
  food: pizza
```

Now we would have to modify the template slightly:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  drink: {{ .Values.favorite.drink }}
  food: {{ .Values.favorite.food }}
```

While structuring data this way is possible, the recommendation is that you keep
your values trees shallow, favoring flatness. When we look at assigning values
to subcharts, we'll see how values are named using a tree structure.

## Deleting a default key

If you need to delete a key from the default values, you may override the value
of the key to be `null`, in which case Helm will remove the key from the
overridden values merge.

For example, the stable Drupal chart allows configuring the liveness probe, in
case you configure a custom image. Here are the default values:
```yaml
livenessProbe:
  httpGet:
    path: /user/login
    port: http
  initialDelaySeconds: 120
```

If you try to override the livenessProbe handler to `exec` instead of `httpGet`
using `--set livenessProbe.exec.command=[cat,docroot/CHANGELOG.txt]`, Helm will
coalesce the default and overridden keys together, resulting in the following
YAML:
```yaml
livenessProbe:
  httpGet:
    path: /user/login
    port: http
  exec:
    command:
    - cat
    - docroot/CHANGELOG.txt
  initialDelaySeconds: 120
```

However, Kubernetes would then fail because you can not declare more than one
livenessProbe handler. To overcome this, you may instruct Helm to delete the
`livenessProbe.httpGet` by setting it to null:
```sh
helm install stable/drupal --set image=my-registry/drupal:0.1.0 --set livenessProbe.exec.command=[cat,docroot/CHANGELOG.txt] --set livenessProbe.httpGet=null
```

At this point, we've seen several built-in objects, and used them to inject
information into a template. Now we will take a look at another aspect of the
template engine: functions and pipelines.
</file>

<file path="chart_template_guide/variables.md">
---
title: Variables
description: Using variables in templates.
sidebar_position: 8
---

With functions, pipelines, objects, and control structures under our belts, we
can turn to one of the more basic ideas in many programming languages:
variables. In templates, they are less frequently used. But we will see how to
use them to simplify code, and to make better use of `with` and `range`.

In an earlier example, we saw that this code will fail:

```yaml
  {{- with .Values.favorite }}
  drink: {{ .drink | default "tea" | quote }}
  food: {{ .food | upper | quote }}
  release: {{ .Release.Name }}
  {{- end }}
```

`Release.Name` is not inside of the scope that's restricted in the `with` block.
One way to work around scoping issues is to assign objects to variables that can
be accessed without respect to the present scope.

In Helm templates, a variable is a named reference to another object. It follows
the form `$name`. Variables are assigned with a special assignment operator:
`:=`. We can rewrite the above to use a variable for `Release.Name`.

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  {{- $relname := .Release.Name -}}
  {{- with .Values.favorite }}
  drink: {{ .drink | default "tea" | quote }}
  food: {{ .food | upper | quote }}
  release: {{ $relname }}
  {{- end }}
```

Notice that before we start the `with` block, we assign `$relname :=
.Release.Name`. Now inside of the `with` block, the `$relname` variable still
points to the release name.

Running that will produce this:

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: viable-badger-configmap
data:
  myvalue: "Hello World"
  drink: "coffee"
  food: "PIZZA"
  release: viable-badger
```

Variables are particularly useful in `range` loops. They can be used on
list-like objects to capture both the index and the value:

```yaml
  toppings: |-
    {{- range $index, $topping := .Values.pizzaToppings }}
      {{ $index }}: {{ $topping }}
    {{- end }}

```

Note that `range` comes first, then the variables, then the assignment operator,
then the list. This will assign the integer index (starting from zero) to
`$index` and the value to `$topping`. Running it will produce:

```yaml
  toppings: |-
      0: mushrooms
      1: cheese
      2: peppers
      3: onions
```

For data structures that have both a key and a value, we can use `range` to get
both. For example, we can loop through `.Values.favorite` like this:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
  {{- range $key, $val := .Values.favorite }}
  {{ $key }}: {{ $val | quote }}
  {{- end }}
```

Now on the first iteration, `$key` will be `drink` and `$val` will be `coffee`,
and on the second, `$key` will be `food` and `$val` will be `pizza`. Running the
above will generate this:

```yaml
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: eager-rabbit-configmap
data:
  myvalue: "Hello World"
  drink: "coffee"
  food: "pizza"
```

Variables are normally not "global". They are scoped to the block in which they
are declared. Earlier, we assigned `$relname` in the top level of the template.
That variable will be in scope for the entire template. But in our last example,
`$key` and `$val` will only be in scope inside of the `{{ range... }}{{ end }}`
block.

However, there is one variable that will always point to the root context: - `$` -.
This can be very useful when you are looping
in a range and you need to know the chart's release name.

An example illustrating this:
```yaml
{{- range .Values.tlsSecrets }}
---
apiVersion: v1
kind: Secret
metadata:
  name: {{ .name }}
  labels:
    # Many helm templates would use `.` below, but that will not work,
    # however `$` will work here
    app.kubernetes.io/name: {{ template "fullname" $ }}
    # I cannot reference .Chart.Name, but I can do $.Chart.Name
    helm.sh/chart: "{{ $.Chart.Name }}-{{ $.Chart.Version }}"
    app.kubernetes.io/instance: "{{ $.Release.Name }}"
    # Value from appVersion in Chart.yaml
    app.kubernetes.io/version: "{{ $.Chart.AppVersion }}"
    app.kubernetes.io/managed-by: "{{ $.Release.Service }}"
type: kubernetes.io/tls
data:
  tls.crt: {{ .certificate }}
  tls.key: {{ .key }}
{{- end }}
```

So far we have looked at just one template declared in just one file. But one of
the powerful features of the Helm template language is its ability to declare
multiple templates and use them together. We'll turn to that in the next
section.
</file>

<file path="chart_template_guide/wrapping_up.md">
---
title: Next Steps
description: Wrapping up - some useful pointers to other documentation that will help you.
sidebar_position: 14
---

This guide is intended to give you, the chart developer, a strong understanding
of how to use Helm's template language. The guide focuses on the technical
aspects of template development.

But there are many things this guide has not covered when it comes to the
practical day-to-day development of charts. Here are some useful pointers to
other documentation that will help you as you create new charts:

- The CNCF [Artifact Hub](https://artifacthub.io/packages/search?kind=0) is an
  indispensable source of charts.
- The Kubernetes [Documentation](https://kubernetes.io/docs/home/) provides
  detailed examples of the various resource kinds that you can use, from
  ConfigMaps and Secrets to DaemonSets and Deployments.
- The Helm [Charts Guide](/topics/charts.mdx) explains the workflow of using
  charts.
- The Helm [Chart Hooks Guide](/topics/charts_hooks.md) explains how to
  create lifecycle hooks.
- The Helm [Charts Tips and Tricks](/howto/charts_tips_and_tricks.md) article
  provides some useful tips for writing charts.
- The [Sprig documentation](https://github.com/Masterminds/sprig) documents more
  than sixty of the template functions.
- The [Go template docs](https://godoc.org/text/template) explain the template
  syntax in detail.
- The [Schelm tool](https://github.com/databus23/schelm) is a nice helper
  utility for debugging charts.

Sometimes it's easier to ask a few questions and get answers from experienced
developers. The best place to do this is in the [Kubernetes
Slack](https://kubernetes.slack.com) Helm channels:

- [#helm-users](https://kubernetes.slack.com/messages/helm-users)
- [#helm-dev](https://kubernetes.slack.com/messages/helm-dev)
- [#charts](https://kubernetes.slack.com/messages/charts)

Finally, if you find errors or omissions in this document, want to suggest some
new content, or would like to contribute, visit [The Helm
Project](https://github.com/helm/helm-www).
</file>

<file path="chart_template_guide/yaml_techniques.md">
---
title: "Appendix: YAML Techniques"
description: A closer look at the YAML specification and how it applies to Helm.
sidebar_position: 15
---

Most of this guide has been focused on writing the template language. Here,
we'll look at the YAML format. YAML has some useful features that we, as
template authors, can use to make our templates less error prone and easier to
read.

## Scalars and Collections

According to the [YAML spec](https://yaml.org/spec/1.2/spec.html), there are two
types of collections, and many scalar types.

The two types of collections are maps and sequences:

```yaml
map:
  one: 1
  two: 2
  three: 3

sequence:
  - one
  - two
  - three
```

Scalar values are individual values (as opposed to collections)

### Scalar Types in YAML

In Helm's dialect of YAML, the scalar data type of a value is determined by a
complex set of rules, including the Kubernetes schema for resource definitions.
But when inferring types, the following rules tend to hold true.

If an integer or float is an unquoted bare word, it is typically treated as a
numeric type:

```yaml
count: 1
size: 2.34
```

But if they are quoted, they are treated as strings:

```yaml
count: "1" # <-- string, not int
size: '2.34' # <-- string, not float
```

The same is true of booleans:

```yaml
isGood: true   # bool
answer: "true" # string
```

The word for an empty value is `null` (not `nil`).

Note that `port: "80"` is valid YAML, and will pass through both the template
engine and the YAML parser, but will fail if Kubernetes expects `port` to be an
integer.

In some cases, you can force a particular type inference using YAML node tags:

```yaml
coffee: "yes, please"
age: !!str 21
port: !!int "80"
```

In the above, `!!str` tells the parser that `age` is a string, even if it looks
like an int. And `port` is treated as an int, even though it is quoted.


## Strings in YAML

Much of the data that we place in YAML documents are strings. YAML has more than
one way to represent a string. This section explains the ways and demonstrates
how to use some of them.

There are three "inline" ways of declaring a string:

```yaml
way1: bare words
way2: "double-quoted strings"
way3: 'single-quoted strings'
```

All inline styles must be on one line.

- Bare words are unquoted, and are not escaped. For this reason, you have to be
  careful what characters you use.
- Double-quoted strings can have specific characters escaped with `\`. For
  example `"\"Hello\", she said"`. You can escape line breaks with `\n`.
- Single-quoted strings are "literal" strings, and do not use the `\` to escape
  characters. The only escape sequence is `''`, which is decoded as a single
  `'`.

In addition to the one-line strings, you can declare multi-line strings:

```yaml
coffee: |
  Latte
  Cappuccino
  Espresso
```

The above will treat the value of `coffee` as a single string equivalent to
`Latte\nCappuccino\nEspresso\n`.

Note that the first line after the `|` must be correctly indented. So we could
break the example above by doing this:

```yaml
coffee: |
         Latte
  Cappuccino
  Espresso

```

Because `Latte` is incorrectly indented, we'd get an error like this:

```
Error parsing file: error converting YAML to JSON: yaml: line 7: did not find expected key
```

In templates, it is sometimes safer to put a fake "first line" of content in a
multi-line document just for protection from the above error:

```yaml
coffee: |
  # Commented first line
         Latte
  Cappuccino
  Espresso

```

Note that whatever that first line is, it will be preserved in the output of the
string. So if you are, for example, using this technique to inject a file's
contents into a ConfigMap, the comment should be of the type expected by
whatever is reading that entry.

### Controlling Spaces in Multi-line Strings

In the example above, we used `|` to indicate a multi-line string. But notice
that the content of our string was followed with a trailing `\n`. If we want the
YAML processor to strip off the trailing newline, we can add a `-` after the
`|`:

```yaml
coffee: |-
  Latte
  Cappuccino
  Espresso
```

Now the `coffee` value will be: `Latte\nCappuccino\nEspresso` (with no trailing
`\n`).

Other times, we might want all trailing whitespace to be preserved. We can do
this with the `|+` notation:

```yaml
coffee: |+
  Latte
  Cappuccino
  Espresso


another: value
```

Now the value of `coffee` will be `Latte\nCappuccino\nEspresso\n\n\n`.

Indentation inside of a text block is preserved, and results in the preservation
of line breaks, too:

```yaml
coffee: |-
  Latte
    12 oz
    16 oz
  Cappuccino
  Espresso
```

In the above case, `coffee` will be `Latte\n  12 oz\n  16
oz\nCappuccino\nEspresso`.

### Indenting and Templates

When writing templates, you may find yourself wanting to inject the contents of
a file into the template. As we saw in previous chapters, there are two ways of
doing this:

- Use `{{ .Files.Get "FILENAME" }}` to get the contents of a file in the chart.
- Use `{{ include "TEMPLATE" . }}` to render a template and then place its
  contents into the chart.

When inserting files into YAML, it's good to understand the multi-line rules
above. Often times, the easiest way to insert a static file is to do something
like this:

```yaml
myfile: |
{{ .Files.Get "myfile.txt" | indent 2 }}
```

Note how we do the indentation above: `indent 2` tells the template engine to
indent every line in "myfile.txt" with two spaces. Note that we do not indent
that template line. That's because if we did, the file content of the first line
would be indented twice.

### Folded Multi-line Strings

Sometimes you want to represent a string in your YAML with multiple lines, but
want it to be treated as one long line when it is interpreted. This is called
"folding". To declare a folded block, use `>` instead of `|`:

```yaml
coffee: >
  Latte
  Cappuccino
  Espresso


```

The value of `coffee` above will be `Latte Cappuccino Espresso\n`. Note that all
but the last line feed will be converted to spaces. You can combine the
whitespace controls with the folded text marker, so `>-` will replace or trim
all newlines.

Note that in the folded syntax, indenting text will cause lines to be preserved.

```yaml
coffee: >-
  Latte
    12 oz
    16 oz
  Cappuccino
  Espresso
```

The above will produce `Latte\n  12 oz\n  16 oz\nCappuccino Espresso`. Note that
both the spacing and the newlines are still there.

## Embedding Multiple Documents in One File

It is possible to place more than one YAML document into a single file. This is
done by prefixing a new document with `---` and ending the document with
`...`

```yaml

---
document: 1
...
---
document: 2
...
```

In many cases, either the `---` or the `...` may be omitted.

Some files in Helm cannot contain more than one doc. If, for example, more than
one document is provided inside of a `values.yaml` file, only the first will be
used.

Template files, however, may have more than one document. When this happens, the
file (and all of its documents) is treated as one object during template
rendering. But then the resulting YAML is split into multiple documents before
it is fed to Kubernetes.

We recommend only using multiple documents per file when it is absolutely
necessary. Having multiple documents in a file can be difficult to debug.

## YAML is a Superset of JSON

Because YAML is a superset of JSON, any valid JSON document _should_ be valid
YAML.

```json
{
  "coffee": "yes, please",
  "coffees": [
    "Latte", "Cappuccino", "Espresso"
  ]
}
```

The above is another way of representing this:

```yaml
coffee: yes, please
coffees:
- Latte
- Cappuccino
- Espresso
```

And the two can be mixed (with care):

```yaml
coffee: "yes, please"
coffees: [ "Latte", "Cappuccino", "Espresso"]
```

All three of these should parse into the same internal representation.

While this means that files such as `values.yaml` may contain JSON data, Helm
does not treat the file extension `.json` as a valid suffix.

## YAML Anchors

The YAML spec provides a way to store a reference to a value, and later refer to
that value by reference. YAML refers to this as "anchoring":

```yaml
coffee: "yes, please"
favorite: &favoriteCoffee "Cappuccino"
coffees:
  - Latte
  - *favoriteCoffee
  - Espresso
```

In the above, `&favoriteCoffee` sets a reference to `Cappuccino`. Later, that
reference is used as `*favoriteCoffee`. So `coffees` becomes `Latte, Cappuccino,
Espresso`.

While there are a few cases where anchors are useful, there is one aspect of
them that can cause subtle bugs: The first time the YAML is consumed, the
reference is expanded and then discarded.

So if we were to decode and then re-encode the example above, the resulting YAML
would be:

```yaml
coffee: yes, please
favorite: Cappuccino
coffees:
- Latte
- Cappuccino
- Espresso
```

Because Helm and Kubernetes often read, modify, and then rewrite YAML files, the
anchors will be lost.
</file>

<file path="faq/index.mdx">
---
title: Frequently Asked Questions
sidebar_position: 9
---

# Frequently Asked Questions

> This section provides help with the most common questions.

**We'd love your help** making this document better. To add, correct, or remove
information, [file an issue](https://github.com/helm/helm-www/issues) or send us
a pull request.



import DocCardList from '@theme/DocCardList';

<DocCardList />
</file>

<file path="faq/installing.mdx">
---
title: Installing
sidebar_position: 2
---

import Helm4 from "/docs/_v4-in-progress.mdx"

<Helm4/>

## Installing

### Why aren't there native packages of Helm for Fedora and other Linux distros?

The Helm project does not maintain packages for operating systems and
environments. The Helm community may provide native packages and if the Helm
project is made aware of them they will be listed. This is how the Homebrew
formula was started and listed. If you're interested in maintaining a package,
we'd love it.

### Why do you provide a `curl ...|bash` script?

There is a script in our repository (`scripts/get-helm-4`) that can be executed
as a `curl ..|bash` script. The transfers are all protected by HTTPS, and the
script does some auditing of the packages it fetches. However, the script has
all the usual dangers of any shell script.

We provide it because it is useful, but we suggest that users carefully read the
script first. What we'd really like, though, are better packaged releases of
Helm.

### How do I put the Helm client files somewhere other than their defaults?

Helm uses the XDG structure for storing files. There are environment variables
you can use to override these locations:

- `$XDG_CACHE_HOME`: set an alternative location for storing cached files.
- `$XDG_CONFIG_HOME`: set an alternative location for storing Helm
  configuration.
- `$XDG_DATA_HOME`: set an alternative location for storing Helm data.

Note that if you have existing repositories, you will need to re-add them with
`helm repo add...`.
</file>

<file path="faq/uninstalling.mdx">
---
title: Uninstalling
sidebar_position: 3
---

import Helm4 from "/docs/_v4-in-progress.mdx"

<Helm4/>

## Uninstalling

### I want to delete my local Helm. Where are all its files?

Along with the `helm` binary, Helm stores some files in the following locations:

- $XDG_CACHE_HOME
- $XDG_CONFIG_HOME
- $XDG_DATA_HOME

The following table gives the default folder for each of these, by OS:

| Operating System | Cache Path                  | Configuration Path               | Data Path                 |
|------------------|-----------------------------|----------------------------------|---------------------------|
| Linux            | `$HOME/.cache/helm`         | `$HOME/.config/helm`             | `$HOME/.local/share/helm` |
| macOS            | `$HOME/Library/Caches/helm` | `$HOME/Library/Preferences/helm` | `$HOME/Library/helm`      |
| Windows          | `%TEMP%\helm`               | `%APPDATA%\helm`                 | `%APPDATA%\helm`          |
</file>

<file path="glossary/index.mdx">
---
title: Glossary
description: Terms used to describe components of Helm's architecture.
sidebar_position: 10
---

# Glossary

import Helm4 from "/docs/_v4-in-progress.mdx"

<Helm4/>

## Chart

A Helm package that contains information sufficient for installing a set of
Kubernetes resources into a Kubernetes cluster.

Charts contain a `Chart.yaml` file as well as templates, default values
(`values.yaml`), and dependencies.

Charts are developed in a well-defined directory structure, and then packaged
into an archive format called a _chart archive_.

## Chart Archive

A _chart archive_ is a tarred and gzipped (and optionally signed) chart.

## Chart Dependency (Subcharts)

Charts may depend upon other charts. There are two ways a dependency may occur:

- Soft dependency: A chart may simply not function without another chart being
  installed in a cluster. Helm does not provide tooling for this case. In this
  case, dependencies may be managed separately.
- Hard dependency: A chart may contain (inside of its `charts/` directory)
  another chart upon which it depends. In this case, installing the chart will
  install all of its dependencies. In this case, a chart and its dependencies
  are managed as a collection.

When a chart is packaged (via `helm package`) all of its hard dependencies are
bundled with it.

## Chart Version

Charts are versioned according to the [SemVer 2 spec](https://semver.org). A
version number is required on every chart.

## Chart.yaml

Information about a chart is stored in a special file called `Chart.yaml`. Every
chart must have this file.

## Helm (and helm)

Helm is the package manager for Kubernetes. As an operating system package
manager makes it easy to install tools on an OS, Helm makes it easy to install
applications and resources into Kubernetes clusters.

While _Helm_ is the name of the project, the command line client is also named
`helm`. By convention, when speaking of the project, _Helm_ is capitalized. When
speaking of the client, _helm_ is in lowercase.

## Helm Configuration Files (XDG)

Helm stores its configuration files in XDG directories. These directories are
created the first time `helm` is run.

## Kube Config (KUBECONFIG)

The Helm client learns about Kubernetes clusters by using files in the _Kube
config_ file format. By default, Helm attempts to find this file in the place
where `kubectl` creates it (`$HOME/.kube/config`).

## Lint (Linting)

To _lint_ a chart is to validate that it follows the conventions and
requirements of the Helm chart standard. Helm provides tools to do this, notably
the `helm lint` command.

## Provenance (Provenance file)

Helm charts may be accompanied by a _provenance file_ which provides information
about where the chart came from and what it contains.

Provenance files are one part of the Helm security story. A provenance contains
a cryptographic hash of the chart archive file, the Chart.yaml data, and a
signature block (an OpenPGP "clearsign" block). When coupled with a keychain,
this provides chart users with the ability to:

- Validate that a chart was signed by a trusted party
- Validate that the chart file has not been tampered with
- Validate the contents of a chart metadata (`Chart.yaml`)
- Quickly match a chart to its provenance data

Provenance files have the `.prov` extension, and can be served from a chart
repository server or any other HTTP server.

## Release

When a chart is installed, the Helm library creates a _release_ to track that
installation.

A single chart may be installed many times into the same cluster, and create
many different releases. For example, one can install three PostgreSQL databases
by running `helm install` three times with a different release name.

## Release Number (Release Version)

A single release can be updated multiple times. A sequential counter is used to
track releases as they change. After a first `helm install`, a release will have
_release number_ 1. Each time a release is upgraded or rolled back, the release
number will be incremented.

## Rollback

A release can be upgraded to a newer chart or configuration. But since release
history is stored, a release can also be _rolled back_ to a previous release
number. This is done with the `helm rollback` command.

Importantly, a rolled back release will receive a new release number.

| Operation  | Release Number                                       |
|------------|------------------------------------------------------|
| install    | release 1                                            |
| upgrade    | release 2                                            |
| upgrade    | release 3                                            |
| rollback 1 | release 4 (but running the same config as release 1) |

The above table illustrates how release numbers increment across install,
upgrade, and rollback.

## Helm Library (or SDK)

The Helm Library (or SDK) refers to the Go code that interacts directly with the
Kubernetes API server to install, upgrade, query, and remove Kubernetes
resources. It can be imported into a project to use Helm as a client library
instead of a CLI.

## Repository (Repo, Chart Repository)

Helm charts may be stored on dedicated HTTP servers called _chart repositories_
(_repositories_, or just _repos_).

A chart repository server is a simple HTTP server that can serve an `index.yaml`
file that describes a batch of charts, and provides information on where each
chart can be downloaded from. (Many chart repositories serve the charts as well
as the `index.yaml` file.)

A Helm client can point to zero or more chart repositories. By default, Helm
clients are not configured with any chart repositories. Chart repositories can
be added at any time using the `helm repo add` command.

## Chart Registry (OCI-based Registry)

A Helm Chart Registry is an [OCI-based](https://opencontainers.org/about/overview/) storage and distribution system that is used to host and share Helm chart packages. For more information, see the [Helm documentation on registries](https://helm.sh/docs/topics/registries/).

## Values (Values Files, values.yaml)

Values provide a way to override template defaults with your own information.

Helm Charts are "parameterized", which means the chart developer may expose
configuration that can be overridden at installation time. For example, a chart
may expose a `username` field that allows setting a user name for a service.

These exposed variables are called _values_ in Helm parlance.

Values can be set during `helm install` and `helm upgrade` operations, either by
passing them in directly, or by using a `values.yaml` file.


import DocCardList from '@theme/DocCardList';

<DocCardList />
</file>

<file path="helm/_category_.json">
{
  "link": {
    "type": "doc",
    "id": "helm-category"
  }
}
</file>

<file path="helm/helm_completion_bash.md">
---
title: helm completion bash
---

generate autocompletion script for bash

### Synopsis


Generate the autocompletion script for Helm for the bash shell.

To load completions in your current shell session:

    source <(helm completion bash)

To load completions for every new session, execute once:
- Linux:

      helm completion bash > /etc/bash_completion.d/helm

- MacOS:

      helm completion bash > /usr/local/etc/bash_completion.d/helm


```
helm completion bash [flags]
```

### Options

```
  -h, --help              help for bash
      --no-descriptions   disable completion descriptions
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm completion](/helm/helm_completion.md)	 - generate autocompletion scripts for the specified shell

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_completion_fish.md">
---
title: helm completion fish
---

generate autocompletion script for fish

### Synopsis


Generate the autocompletion script for Helm for the fish shell.

To load completions in your current shell session:

    helm completion fish | source

To load completions for every new session, execute once:

    helm completion fish > ~/.config/fish/completions/helm.fish

You will need to start a new shell for this setup to take effect.


```
helm completion fish [flags]
```

### Options

```
  -h, --help              help for fish
      --no-descriptions   disable completion descriptions
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm completion](/helm/helm_completion.md)	 - generate autocompletion scripts for the specified shell

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_completion_powershell.md">
---
title: helm completion powershell
---

generate autocompletion script for powershell

### Synopsis


Generate the autocompletion script for powershell.

To load completions in your current shell session:
PS C:\> helm completion powershell | Out-String | Invoke-Expression

To load completions for every new session, add the output of the above command
to your powershell profile.


```
helm completion powershell [flags]
```

### Options

```
  -h, --help              help for powershell
      --no-descriptions   disable completion descriptions
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm completion](/helm/helm_completion.md)	 - generate autocompletion scripts for the specified shell

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_completion_zsh.md">
---
title: helm completion zsh
---

generate autocompletion script for zsh

### Synopsis


Generate the autocompletion script for Helm for the zsh shell.

To load completions in your current shell session:

    source <(helm completion zsh)

To load completions for every new session, execute once:

    helm completion zsh > "${fpath[1]}/_helm"


```
helm completion zsh [flags]
```

### Options

```
  -h, --help              help for zsh
      --no-descriptions   disable completion descriptions
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm completion](/helm/helm_completion.md)	 - generate autocompletion scripts for the specified shell

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_completion.md">
---
title: helm completion
---

generate autocompletion scripts for the specified shell

### Synopsis


Generate autocompletion scripts for Helm for the specified shell.


### Options

```
  -h, --help   help for completion
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm](/helm/helm.md)	 - The Helm package manager for Kubernetes.
* [helm completion bash](/helm/helm_completion_bash.md)	 - generate autocompletion script for bash
* [helm completion fish](/helm/helm_completion_fish.md)	 - generate autocompletion script for fish
* [helm completion powershell](/helm/helm_completion_powershell.md)	 - generate autocompletion script for powershell
* [helm completion zsh](/helm/helm_completion_zsh.md)	 - generate autocompletion script for zsh

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_create.md">
---
title: helm create
---

create a new chart with the given name

### Synopsis


This command creates a chart directory along with the common files and
directories used in a chart.

For example, 'helm create foo' will create a directory structure that looks
something like this:

    foo/
    â”œâ”€â”€ .helmignore   # Contains patterns to ignore when packaging Helm charts.
    â”œâ”€â”€ Chart.yaml    # Information about your chart
    â”œâ”€â”€ values.yaml   # The default values for your templates
    â”œâ”€â”€ charts/       # Charts that this chart depends on
    â””â”€â”€ templates/    # The template files
        â””â”€â”€ tests/    # The test files

'helm create' takes a path for an argument. If directories in the given path
do not exist, Helm will attempt to create them as it goes. If the given
destination exists and there are files in that directory, conflicting files
will be overwritten, but other files will be left alone.


```
helm create NAME [flags]
```

### Options

```
  -h, --help             help for create
  -p, --starter string   the name or absolute path to Helm starter scaffold
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm](/helm/helm.md)	 - The Helm package manager for Kubernetes.

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_dependency_build.md">
---
title: helm dependency build
---

rebuild the charts/ directory based on the Chart.lock file

### Synopsis


Build out the charts/ directory from the Chart.lock file.

Build is used to reconstruct a chart's dependencies to the state specified in
the lock file. This will not re-negotiate dependencies, as 'helm dependency update'
does.

If no lock file is found, 'helm dependency build' will mirror the behavior
of 'helm dependency update'.


```
helm dependency build CHART [flags]
```

### Options

```
      --ca-file string             verify certificates of HTTPS-enabled servers using this CA bundle
      --cert-file string           identify HTTPS client using this SSL certificate file
  -h, --help                       help for build
      --insecure-skip-tls-verify   skip tls certificate checks for the chart download
      --key-file string            identify HTTPS client using this SSL key file
      --keyring string             keyring containing public keys (default "~/.gnupg/pubring.gpg")
      --password string            chart repository password where to locate the requested chart
      --plain-http                 use insecure HTTP connections for the chart download
      --skip-refresh               do not refresh the local repository cache
      --username string            chart repository username where to locate the requested chart
      --verify                     verify the packages against signatures
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm dependency](/helm/helm_dependency.md)	 - manage a chart's dependencies

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_dependency_list.md">
---
title: helm dependency list
---

list the dependencies for the given chart

### Synopsis


List all of the dependencies declared in a chart.

This can take chart archives and chart directories as input. It will not alter
the contents of a chart.

This will produce an error if the chart cannot be loaded.


```
helm dependency list CHART [flags]
```

### Options

```
  -h, --help                 help for list
      --max-col-width uint   maximum column width for output table (default 80)
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm dependency](/helm/helm_dependency.md)	 - manage a chart's dependencies

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_dependency_update.md">
---
title: helm dependency update
---

update charts/ based on the contents of Chart.yaml

### Synopsis


Update the on-disk dependencies to mirror Chart.yaml.

This command verifies that the required charts, as expressed in 'Chart.yaml',
are present in 'charts/' and are at an acceptable version. It will pull down
the latest charts that satisfy the dependencies, and clean up old dependencies.

On successful update, this will generate a lock file that can be used to
rebuild the dependencies to an exact version.

Dependencies are not required to be represented in 'Chart.yaml'. For that
reason, an update command will not remove charts unless they are (a) present
in the Chart.yaml file, but (b) at the wrong version.


```
helm dependency update CHART [flags]
```

### Options

```
      --ca-file string             verify certificates of HTTPS-enabled servers using this CA bundle
      --cert-file string           identify HTTPS client using this SSL certificate file
  -h, --help                       help for update
      --insecure-skip-tls-verify   skip tls certificate checks for the chart download
      --key-file string            identify HTTPS client using this SSL key file
      --keyring string             keyring containing public keys (default "~/.gnupg/pubring.gpg")
      --password string            chart repository password where to locate the requested chart
      --plain-http                 use insecure HTTP connections for the chart download
      --skip-refresh               do not refresh the local repository cache
      --username string            chart repository username where to locate the requested chart
      --verify                     verify the packages against signatures
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm dependency](/helm/helm_dependency.md)	 - manage a chart's dependencies

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_dependency.md">
---
title: helm dependency
---

manage a chart's dependencies

### Synopsis


Manage the dependencies of a chart.

Helm charts store their dependencies in 'charts/'. For chart developers, it is
often easier to manage dependencies in 'Chart.yaml' which declares all
dependencies.

The dependency commands operate on that file, making it easy to synchronize
between the desired dependencies and the actual dependencies stored in the
'charts/' directory.

For example, this Chart.yaml declares two dependencies:

    # Chart.yaml
    dependencies:
    - name: nginx
      version: "1.2.3"
      repository: "https://example.com/charts"
    - name: memcached
      version: "3.2.1"
      repository: "https://another.example.com/charts"


The 'name' should be the name of a chart, where that name must match the name
in that chart's 'Chart.yaml' file.

The 'version' field should contain a semantic version or version range.

The 'repository' URL should point to a Chart Repository. Helm expects that by
appending '/index.yaml' to the URL, it should be able to retrieve the chart
repository's index. Note: 'repository' can be an alias. The alias must start
with 'alias:' or '@'.

Starting from 2.2.0, repository can be defined as the path to the directory of
the dependency charts stored locally. The path should start with a prefix of
"file://". For example,

    # Chart.yaml
    dependencies:
    - name: nginx
      version: "1.2.3"
      repository: "file://../dependency_chart/nginx"

If the dependency chart is retrieved locally, it is not required to have the
repository added to helm by "helm add repo". Version matching is also supported
for this case.


### Options

```
  -h, --help   help for dependency
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm](/helm/helm.md)	 - The Helm package manager for Kubernetes.
* [helm dependency build](/helm/helm_dependency_build.md)	 - rebuild the charts/ directory based on the Chart.lock file
* [helm dependency list](/helm/helm_dependency_list.md)	 - list the dependencies for the given chart
* [helm dependency update](/helm/helm_dependency_update.md)	 - update charts/ based on the contents of Chart.yaml

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_env.md">
---
title: helm env
---

helm client environment information

### Synopsis


Env prints out all the environment information in use by Helm.


```
helm env [flags]
```

### Options

```
  -h, --help   help for env
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm](/helm/helm.md)	 - The Helm package manager for Kubernetes.

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_get_all.md">
---
title: helm get all
---

download all information for a named release

### Synopsis


This command prints a human readable collection of information about the
notes, hooks, supplied values, and generated manifest file of the given release.


```
helm get all RELEASE_NAME [flags]
```

### Options

```
  -h, --help              help for all
      --revision int      get the named release with revision
      --template string   go template for formatting the output, eg: {{.Release.Name}}
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm get](/helm/helm_get.md)	 - download extended information of a named release

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_get_hooks.md">
---
title: helm get hooks
---

download all hooks for a named release

### Synopsis


This command downloads hooks for a given release.

Hooks are formatted in YAML and separated by the YAML '---\n' separator.


```
helm get hooks RELEASE_NAME [flags]
```

### Options

```
  -h, --help           help for hooks
      --revision int   get the named release with revision
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm get](/helm/helm_get.md)	 - download extended information of a named release

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_get_manifest.md">
---
title: helm get manifest
---

download the manifest for a named release

### Synopsis


This command fetches the generated manifest for a given release.

A manifest is a YAML-encoded representation of the Kubernetes resources that
were generated from this release's chart(s). If a chart is dependent on other
charts, those resources will also be included in the manifest.


```
helm get manifest RELEASE_NAME [flags]
```

### Options

```
  -h, --help           help for manifest
      --revision int   get the named release with revision
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm get](/helm/helm_get.md)	 - download extended information of a named release

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_get_metadata.md">
---
title: helm get metadata
---

This command fetches metadata for a given release

```
helm get metadata RELEASE_NAME [flags]
```

### Options

```
  -h, --help            help for metadata
  -o, --output format   prints the output in the specified format. Allowed values: table, json, yaml (default table)
      --revision int    specify release revision
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm get](/helm/helm_get.md)	 - download extended information of a named release

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_get_notes.md">
---
title: helm get notes
---

download the notes for a named release

### Synopsis


This command shows notes provided by the chart of a named release.


```
helm get notes RELEASE_NAME [flags]
```

### Options

```
  -h, --help           help for notes
      --revision int   get the named release with revision
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm get](/helm/helm_get.md)	 - download extended information of a named release

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_get_values.md">
---
title: helm get values
---

download the values file for a named release

### Synopsis


This command downloads a values file for a given release.


```
helm get values RELEASE_NAME [flags]
```

### Options

```
  -a, --all             dump all (computed) values
  -h, --help            help for values
  -o, --output format   prints the output in the specified format. Allowed values: table, json, yaml (default table)
      --revision int    get the named release with revision
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm get](/helm/helm_get.md)	 - download extended information of a named release

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_get.md">
---
title: helm get
---

download extended information of a named release

### Synopsis


This command consists of multiple subcommands which can be used to
get extended information about the release, including:

- The values used to generate the release
- The generated manifest file
- The notes provided by the chart of the release
- The hooks associated with the release
- The metadata of the release


### Options

```
  -h, --help   help for get
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm](/helm/helm.md)	 - The Helm package manager for Kubernetes.
* [helm get all](/helm/helm_get_all.md)	 - download all information for a named release
* [helm get hooks](/helm/helm_get_hooks.md)	 - download all hooks for a named release
* [helm get manifest](/helm/helm_get_manifest.md)	 - download the manifest for a named release
* [helm get metadata](/helm/helm_get_metadata.md)	 - This command fetches metadata for a given release
* [helm get notes](/helm/helm_get_notes.md)	 - download the notes for a named release
* [helm get values](/helm/helm_get_values.md)	 - download the values file for a named release

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_history.md">
---
title: helm history
---

fetch release history

### Synopsis


History prints historical revisions for a given release.

A default maximum of 256 revisions will be returned. Setting '--max'
configures the maximum length of the revision list returned.

The historical release set is printed as a formatted table, e.g:

    $ helm history angry-bird
    REVISION    UPDATED                     STATUS          CHART             APP VERSION     DESCRIPTION
    1           Mon Oct 3 10:15:13 2016     superseded      alpine-0.1.0      1.0             Initial install
    2           Mon Oct 3 10:15:13 2016     superseded      alpine-0.1.0      1.0             Upgraded successfully
    3           Mon Oct 3 10:15:13 2016     superseded      alpine-0.1.0      1.0             Rolled back to 2
    4           Mon Oct 3 10:15:13 2016     deployed        alpine-0.1.0      1.0             Upgraded successfully


```
helm history RELEASE_NAME [flags]
```

### Options

```
  -h, --help            help for history
      --max int         maximum number of revision to include in history (default 256)
  -o, --output format   prints the output in the specified format. Allowed values: table, json, yaml (default table)
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm](/helm/helm.md)	 - The Helm package manager for Kubernetes.

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_install.md">
---
title: helm install
---

install a chart

### Synopsis


This command installs a chart archive.

The install argument must be a chart reference, a path to a packaged chart,
a path to an unpacked chart directory or a URL.

To override values in a chart, use either the '--values' flag and pass in a file
or use the '--set' flag and pass configuration from the command line, to force
a string value use '--set-string'. You can use '--set-file' to set individual
values from a file when the value itself is too long for the command line
or is dynamically generated. You can also use '--set-json' to set json values
(scalars/objects/arrays) from the command line. Additionally, you can use '--set-json' and passing json object as a string.

    $ helm install -f myvalues.yaml myredis ./redis

or

    $ helm install --set name=prod myredis ./redis

or

    $ helm install --set-string long_int=1234567890 myredis ./redis

or

    $ helm install --set-file my_script=dothings.sh myredis ./redis

or

    $ helm install --set-json 'master.sidecars=[{"name":"sidecar","image":"myImage","imagePullPolicy":"Always","ports":[{"name":"portname","containerPort":1234}]}]' myredis ./redis

or

    $ helm install --set-json '{"master":{"sidecars":[{"name":"sidecar","image":"myImage","imagePullPolicy":"Always","ports":[{"name":"portname","containerPort":1234}]}]}}' myredis ./redis

You can specify the '--values'/'-f' flag multiple times. The priority will be given to the
last (right-most) file specified. For example, if both myvalues.yaml and override.yaml
contained a key called 'Test', the value set in override.yaml would take precedence:

    $ helm install -f myvalues.yaml -f override.yaml  myredis ./redis

You can specify the '--set' flag multiple times. The priority will be given to the
last (right-most) set specified. For example, if both 'bar' and 'newbar' values are
set for a key called 'foo', the 'newbar' value would take precedence:

    $ helm install --set foo=bar --set foo=newbar  myredis ./redis

Similarly, in the following example 'foo' is set to '["four"]':

    $ helm install --set-json='foo=["one", "two", "three"]' --set-json='foo=["four"]' myredis ./redis

And in the following example, 'foo' is set to '{"key1":"value1","key2":"bar"}':

    $ helm install --set-json='foo={"key1":"value1","key2":"value2"}' --set-json='foo.key2="bar"' myredis ./redis

To check the generated manifests of a release without installing the chart,
the --debug and --dry-run flags can be combined.

The --dry-run flag will output all generated chart manifests, including Secrets
which can contain sensitive values. To hide Kubernetes Secrets use the
--hide-secret flag. Please carefully consider how and when these flags are used.

If --verify is set, the chart MUST have a provenance file, and the provenance
file MUST pass all verification steps.

There are six different ways you can express the chart you want to install:

1. By chart reference: helm install mymaria example/mariadb
2. By path to a packaged chart: helm install mynginx ./nginx-1.2.3.tgz
3. By path to an unpacked chart directory: helm install mynginx ./nginx
4. By absolute URL: helm install mynginx https://example.com/charts/nginx-1.2.3.tgz
5. By chart reference and repo url: helm install --repo https://example.com/charts/ mynginx nginx
6. By OCI registries: helm install mynginx --version 1.2.3 oci://example.com/charts/nginx

CHART REFERENCES

A chart reference is a convenient way of referencing a chart in a chart repository.

When you use a chart reference with a repo prefix ('example/mariadb'), Helm will look in the local
configuration for a chart repository named 'example', and will then look for a
chart in that repository whose name is 'mariadb'. It will install the latest stable version of that chart
until you specify '--devel' flag to also include development version (alpha, beta, and release candidate releases), or
supply a version number with the '--version' flag.

To see the list of chart repositories, use 'helm repo list'. To search for
charts in a repository, use 'helm search'.


```
helm install [NAME] [CHART] [flags]
```

### Options

```
      --ca-file string                             verify certificates of HTTPS-enabled servers using this CA bundle
      --cert-file string                           identify HTTPS client using this SSL certificate file
      --create-namespace                           create the release namespace if not present
      --dependency-update                          update dependencies if they are missing before installing the chart
      --description string                         add a custom description
      --devel                                      use development versions, too. Equivalent to version '>0.0.0-0'. If --version is set, this is ignored
      --disable-openapi-validation                 if set, the installation process will not validate rendered templates against the Kubernetes OpenAPI Schema
      --dry-run string[="unset"]                   simulates the operation without persisting changes. Must be one of: "none" (default), "client", or "server". '--dry-run=none' executes the operation normally and persists changes (no simulation). '--dry-run=client' simulates the operation client-side only and avoids cluster connections. '--dry-run=server' simulates the operation on the server, requiring cluster connectivity. (default "none")
      --enable-dns                                 enable DNS lookups when rendering templates
      --force-conflicts                            if set server-side apply will force changes against conflicts
      --force-replace                              force resource updates by replacement
  -g, --generate-name                              generate the name (and omit the NAME parameter)
  -h, --help                                       help for install
      --hide-notes                                 if set, do not show notes in install output. Does not affect presence in chart metadata
      --hide-secret                                hide Kubernetes Secrets when also using the --dry-run flag
      --insecure-skip-tls-verify                   skip tls certificate checks for the chart download
      --key-file string                            identify HTTPS client using this SSL key file
      --keyring string                             location of public keys used for verification (default "~/.gnupg/pubring.gpg")
  -l, --labels stringToString                      Labels that would be added to release metadata. Should be divided by comma. (default [])
      --name-template string                       specify template used to name the release
      --no-hooks                                   prevent hooks from running during install
  -o, --output format                              prints the output in the specified format. Allowed values: table, json, yaml (default table)
      --pass-credentials                           pass credentials to all domains
      --password string                            chart repository password where to locate the requested chart
      --plain-http                                 use insecure HTTP connections for the chart download
      --post-renderer postRendererString           the name of a postrenderer type plugin to be used for post rendering. If it exists, the plugin will be used
      --post-renderer-args postRendererArgsSlice   an argument to the post-renderer (can specify multiple) (default [])
      --render-subchart-notes                      if set, render subchart notes along with the parent
      --replace                                    reuse the given name, only if that name is a deleted release which remains in the history. This is unsafe in production
      --repo string                                chart repository url where to locate the requested chart
      --rollback-on-failure                        if set, Helm will rollback (uninstall) the installation upon failure. The --wait flag will be default to "watcher" if --rollback-on-failure is set
      --server-side                                object updates run in the server instead of the client (default true)
      --set stringArray                            set values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)
      --set-file stringArray                       set values from respective files specified via the command line (can specify multiple or separate values with commas: key1=path1,key2=path2)
      --set-json stringArray                       set JSON values on the command line (can specify multiple or separate values with commas: key1=jsonval1,key2=jsonval2 or using json format: {"key1": jsonval1, "key2": "jsonval2"})
      --set-literal stringArray                    set a literal STRING value on the command line
      --set-string stringArray                     set STRING values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)
      --skip-crds                                  if set, no CRDs will be installed. By default, CRDs are installed if not already present
      --skip-schema-validation                     if set, disables JSON schema validation
      --take-ownership                             if set, install will ignore the check for helm annotations and take ownership of the existing resources
      --timeout duration                           time to wait for any individual Kubernetes operation (like Jobs for hooks) (default 5m0s)
      --username string                            chart repository username where to locate the requested chart
  -f, --values strings                             specify values in a YAML file or a URL (can specify multiple)
      --verify                                     verify the package before using it
      --version string                             specify a version constraint for the chart version to use. This constraint can be a specific tag (e.g. 1.1.1) or it may reference a valid range (e.g. ^2.0.0). If this is not specified, the latest version is used
      --wait WaitStrategy[=watcher]                if specified, will wait until all resources are in the expected state before marking the operation as successful. It will wait for as long as --timeout. Valid inputs are 'watcher' and 'legacy' (default hookOnly)
      --wait-for-jobs                              if set and --wait enabled, will wait until all Jobs have been completed before marking the release as successful. It will wait for as long as --timeout
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm](/helm/helm.md)	 - The Helm package manager for Kubernetes.

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_lint.md">
---
title: helm lint
---

examine a chart for possible issues

### Synopsis


This command takes a path to a chart and runs a series of tests to verify that
the chart is well-formed.

If the linter encounters things that will cause the chart to fail installation,
it will emit [ERROR] messages. If it encounters issues that break with convention
or recommendation, it will emit [WARNING] messages.


```
helm lint PATH [flags]
```

### Options

```
  -h, --help                      help for lint
      --kube-version string       Kubernetes version used for capabilities and deprecation checks
      --quiet                     print only warnings and errors
      --set stringArray           set values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)
      --set-file stringArray      set values from respective files specified via the command line (can specify multiple or separate values with commas: key1=path1,key2=path2)
      --set-json stringArray      set JSON values on the command line (can specify multiple or separate values with commas: key1=jsonval1,key2=jsonval2 or using json format: {"key1": jsonval1, "key2": "jsonval2"})
      --set-literal stringArray   set a literal STRING value on the command line
      --set-string stringArray    set STRING values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)
      --skip-schema-validation    if set, disables JSON schema validation
      --strict                    fail on lint warnings
  -f, --values strings            specify values in a YAML file or a URL (can specify multiple)
      --with-subcharts            lint dependent charts
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm](/helm/helm.md)	 - The Helm package manager for Kubernetes.

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_list.md">
---
title: helm list
---

list releases

### Synopsis


This command lists all of the releases for a specified namespace (uses current namespace context if namespace not specified).

By default, it lists all releases in any status. Individual status filters like '--deployed', '--failed',
'--pending', '--uninstalled', '--superseded', and '--uninstalling' can be used
to show only releases in specific states. Such flags can be combined:
'--deployed --failed'.

By default, items are sorted alphabetically. Use the '-d' flag to sort by
release date.

If the --filter flag is provided, it will be treated as a filter. Filters are
regular expressions (Perl compatible) that are applied to the list of releases.
Only items that match the filter will be returned.

    $ helm list --filter 'ara[a-z]+'
    NAME                UPDATED                                  CHART
    maudlin-arachnid    2020-06-18 14:17:46.125134977 +0000 UTC  alpine-0.1.0

If no results are found, 'helm list' will exit 0, but with no output (or in
the case of no '-q' flag, only headers).

By default, up to 256 items may be returned. To limit this, use the '--max' flag.
Setting '--max' to 0 will not return all results. Rather, it will return the
server's default, which may be much higher than 256. Pairing the '--max'
flag with the '--offset' flag allows you to page through results.


```
helm list [flags]
```

### Options

```
  -A, --all-namespaces       list releases across all namespaces
  -d, --date                 sort by release date
      --deployed             show deployed releases
      --failed               show failed releases
  -f, --filter string        a regular expression (Perl compatible). Any releases that match the expression will be included in the results
  -h, --help                 help for list
  -m, --max int              maximum number of releases to fetch (default 256)
      --no-headers           don't print headers when using the default output format
      --offset int           next release index in the list, used to offset from start value
  -o, --output format        prints the output in the specified format. Allowed values: table, json, yaml (default table)
      --pending              show pending releases
  -r, --reverse              reverse the sort order
  -l, --selector string      Selector (label query) to filter on, supports '=', '==', and '!='.(e.g. -l key1=value1,key2=value2). Works only for secret(default) and configmap storage backends.
  -q, --short                output short (quiet) listing format
      --superseded           show superseded releases
      --time-format string   format time using golang time formatter. Example: --time-format "2006-01-02 15:04:05Z0700"
      --uninstalled          show uninstalled releases (if 'helm uninstall --keep-history' was used)
      --uninstalling         show releases that are currently being uninstalled
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm](/helm/helm.md)	 - The Helm package manager for Kubernetes.

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_package.md">
---
title: helm package
---

package a chart directory into a chart archive

### Synopsis


This command packages a chart into a versioned chart archive file. If a path
is given, this will look at that path for a chart (which must contain a
Chart.yaml file) and then package that directory.

Versioned chart archives are used by Helm package repositories.

To sign a chart, use the '--sign' flag. In most cases, you should also
provide '--keyring path/to/secret/keys' and '--key keyname'.

  $ helm package --sign ./mychart --key mykey --keyring ~/.gnupg/secring.gpg

If '--keyring' is not specified, Helm usually defaults to the public keyring
unless your environment is otherwise configured.


```
helm package [CHART_PATH] [...] [flags]
```

### Options

```
      --app-version string         set the appVersion on the chart to this version
      --ca-file string             verify certificates of HTTPS-enabled servers using this CA bundle
      --cert-file string           identify HTTPS client using this SSL certificate file
  -u, --dependency-update          update dependencies from "Chart.yaml" to dir "charts/" before packaging
  -d, --destination string         location to write the chart. (default ".")
  -h, --help                       help for package
      --insecure-skip-tls-verify   skip tls certificate checks for the chart download
      --key string                 name of the key to use when signing. Used if --sign is true
      --key-file string            identify HTTPS client using this SSL key file
      --keyring string             location of a public keyring (default "~/.gnupg/pubring.gpg")
      --passphrase-file string     location of a file which contains the passphrase for the signing key. Use "-" in order to read from stdin.
      --password string            chart repository password where to locate the requested chart
      --plain-http                 use insecure HTTP connections for the chart download
      --sign                       use a PGP private key to sign this package
      --username string            chart repository username where to locate the requested chart
      --version string             set the version on the chart to this semver version
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm](/helm/helm.md)	 - The Helm package manager for Kubernetes.

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_plugin_install.md">
---
title: helm plugin install
---

install a Helm plugin

### Synopsis


This command allows you to install a plugin from a url to a VCS repo or a local path.

By default, plugin signatures are verified before installation when installing from
tarballs (.tgz or .tar.gz). This requires a corresponding .prov file to be available
alongside the tarball.
For local development, plugins installed from local directories are automatically
treated as "local dev" and do not require signatures.
Use --verify=false to skip signature verification for remote plugins.


```
helm plugin install [options] <path|url> [flags]
```

### Options

```
      --ca-file string             verify certificates of HTTPS-enabled servers using this CA bundle
      --cert-file string           identify registry client using this SSL certificate file
  -h, --help                       help for install
      --insecure-skip-tls-verify   skip tls certificate checks for the plugin download
      --key-file string            identify registry client using this SSL key file
      --keyring string             location of public keys used for verification (default "~/.gnupg/pubring.gpg")
      --password string            registry password
      --plain-http                 use insecure HTTP connections for the plugin download
      --username string            registry username
      --verify                     verify the plugin signature before installing (default true)
      --version string             specify a version constraint. If this is not specified, the latest version is installed
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm plugin](/helm/helm_plugin.md)	 - install, list, or uninstall Helm plugins

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_plugin_list.md">
---
title: helm plugin list
---

list installed Helm plugins

```
helm plugin list [flags]
```

### Options

```
  -h, --help          help for list
      --type string   Plugin type
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm plugin](/helm/helm_plugin.md)	 - install, list, or uninstall Helm plugins

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_plugin_package.md">
---
title: helm plugin package
---

package a plugin directory into a plugin archive

### Synopsis


This command packages a Helm plugin directory into a tarball.

By default, the command will generate a provenance file signed with a PGP key.
This ensures the plugin can be verified after installation.

Use --sign=false to skip signing (not recommended for distribution).


```
helm plugin package [PATH] [flags]
```

### Options

```
  -d, --destination string       location to write the plugin tarball. (default ".")
  -h, --help                     help for package
      --key string               name of the key to use when signing. Used if --sign is true
      --keyring string           location of a public keyring (default "~/.gnupg/pubring.gpg")
      --passphrase-file string   location of a file which contains the passphrase for the signing key. Use "-" to read from stdin.
      --sign                     use a PGP private key to sign this plugin (default true)
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm plugin](/helm/helm_plugin.md)	 - install, list, or uninstall Helm plugins

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_plugin_uninstall.md">
---
title: helm plugin uninstall
---

uninstall one or more Helm plugins

```
helm plugin uninstall <plugin>... [flags]
```

### Options

```
  -h, --help   help for uninstall
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm plugin](/helm/helm_plugin.md)	 - install, list, or uninstall Helm plugins

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_plugin_update.md">
---
title: helm plugin update
---

update one or more Helm plugins

```
helm plugin update <plugin>... [flags]
```

### Options

```
  -h, --help   help for update
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm plugin](/helm/helm_plugin.md)	 - install, list, or uninstall Helm plugins

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_plugin_verify.md">
---
title: helm plugin verify
---

verify that a plugin at the given path has been signed and is valid

### Synopsis


This command verifies that a Helm plugin has a valid provenance file,
and that the provenance file is signed by a trusted PGP key.

It supports both:
- Plugin tarballs (.tgz or .tar.gz files)
- Installed plugin directories

For installed plugins, use the path shown by 'helm env HELM_PLUGINS' followed
by the plugin name. For example:
  helm plugin verify ~/.local/share/helm/plugins/example-cli

To generate a signed plugin, use the 'helm plugin package --sign' command.


```
helm plugin verify [PATH] [flags]
```

### Options

```
  -h, --help             help for verify
      --keyring string   keyring containing public keys (default "~/.gnupg/pubring.gpg")
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm plugin](/helm/helm_plugin.md)	 - install, list, or uninstall Helm plugins

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_plugin.md">
---
title: helm plugin
---

install, list, or uninstall Helm plugins

### Synopsis


Manage client-side Helm plugins.


### Options

```
  -h, --help   help for plugin
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm](/helm/helm.md)	 - The Helm package manager for Kubernetes.
* [helm plugin install](/helm/helm_plugin_install.md)	 - install a Helm plugin
* [helm plugin list](/helm/helm_plugin_list.md)	 - list installed Helm plugins
* [helm plugin package](/helm/helm_plugin_package.md)	 - package a plugin directory into a plugin archive
* [helm plugin uninstall](/helm/helm_plugin_uninstall.md)	 - uninstall one or more Helm plugins
* [helm plugin update](/helm/helm_plugin_update.md)	 - update one or more Helm plugins
* [helm plugin verify](/helm/helm_plugin_verify.md)	 - verify that a plugin at the given path has been signed and is valid

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_pull.md">
---
title: helm pull
---

download a chart from a repository and (optionally) unpack it in local directory

### Synopsis


Retrieve a package from a package repository, and download it locally.

This is useful for fetching packages to inspect, modify, or repackage. It can
also be used to perform cryptographic verification of a chart without installing
the chart.

There are options for unpacking the chart after download. This will create a
directory for the chart and uncompress into that directory.

If the --verify flag is specified, the requested chart MUST have a provenance
file, and MUST pass the verification process. Failure in any part of this will
result in an error, and the chart will not be saved locally.


```
helm pull [chart URL | repo/chartname] [...] [flags]
```

### Options

```
      --ca-file string             verify certificates of HTTPS-enabled servers using this CA bundle
      --cert-file string           identify HTTPS client using this SSL certificate file
  -d, --destination string         location to write the chart. If this and untardir are specified, untardir is appended to this (default ".")
      --devel                      use development versions, too. Equivalent to version '>0.0.0-0'. If --version is set, this is ignored.
  -h, --help                       help for pull
      --insecure-skip-tls-verify   skip tls certificate checks for the chart download
      --key-file string            identify HTTPS client using this SSL key file
      --keyring string             location of public keys used for verification (default "~/.gnupg/pubring.gpg")
      --pass-credentials           pass credentials to all domains
      --password string            chart repository password where to locate the requested chart
      --plain-http                 use insecure HTTP connections for the chart download
      --prov                       fetch the provenance file, but don't perform verification
      --repo string                chart repository url where to locate the requested chart
      --untar                      if set to true, will untar the chart after downloading it
      --untardir string            if untar is specified, this flag specifies the name of the directory into which the chart is expanded (default ".")
      --username string            chart repository username where to locate the requested chart
      --verify                     verify the package before using it
      --version string             specify a version constraint for the chart version to use. This constraint can be a specific tag (e.g. 1.1.1) or it may reference a valid range (e.g. ^2.0.0). If this is not specified, the latest version is used
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm](/helm/helm.md)	 - The Helm package manager for Kubernetes.

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_push.md">
---
title: helm push
---

push a chart to remote

### Synopsis


Upload a chart to a registry.

If the chart has an associated provenance file,
it will also be uploaded.


```
helm push [chart] [remote] [flags]
```

### Options

```
      --ca-file string             verify certificates of HTTPS-enabled servers using this CA bundle
      --cert-file string           identify registry client using this SSL certificate file
  -h, --help                       help for push
      --insecure-skip-tls-verify   skip tls certificate checks for the chart upload
      --key-file string            identify registry client using this SSL key file
      --password string            chart repository password where to locate the requested chart
      --plain-http                 use insecure HTTP connections for the chart upload
      --username string            chart repository username where to locate the requested chart
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm](/helm/helm.md)	 - The Helm package manager for Kubernetes.

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_registry_login.md">
---
title: helm registry login
---

login to a registry

### Synopsis


Authenticate to a remote registry.

For example for Github Container Registry:

    echo "$GITHUB_TOKEN" | helm registry login ghcr.io -u $GITHUB_USER --password-stdin


```
helm registry login [host] [flags]
```

### Options

```
      --ca-file string     verify certificates of HTTPS-enabled servers using this CA bundle
      --cert-file string   identify registry client using this SSL certificate file
  -h, --help               help for login
      --insecure           allow connections to TLS registry without certs
      --key-file string    identify registry client using this SSL key file
  -p, --password string    registry password or identity token
      --password-stdin     read password or identity token from stdin
      --plain-http         use insecure HTTP connections for the chart upload
  -u, --username string    registry username
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm registry](/helm/helm_registry.md)	 - login to or logout from a registry

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_registry_logout.md">
---
title: helm registry logout
---

logout from a registry

### Synopsis


Remove credentials stored for a remote registry.


```
helm registry logout [host] [flags]
```

### Options

```
  -h, --help   help for logout
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm registry](/helm/helm_registry.md)	 - login to or logout from a registry

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_registry.md">
---
title: helm registry
---

login to or logout from a registry

### Synopsis


This command consists of multiple subcommands to interact with registries.


### Options

```
  -h, --help   help for registry
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm](/helm/helm.md)	 - The Helm package manager for Kubernetes.
* [helm registry login](/helm/helm_registry_login.md)	 - login to a registry
* [helm registry logout](/helm/helm_registry_logout.md)	 - logout from a registry

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_repo_add.md">
---
title: helm repo add
---

add a chart repository

```
helm repo add [NAME] [URL] [flags]
```

### Options

```
      --allow-deprecated-repos     by default, this command will not allow adding official repos that have been permanently deleted. This disables that behavior
      --ca-file string             verify certificates of HTTPS-enabled servers using this CA bundle
      --cert-file string           identify HTTPS client using this SSL certificate file
      --force-update               replace (overwrite) the repo if it already exists
  -h, --help                       help for add
      --insecure-skip-tls-verify   skip tls certificate checks for the repository
      --key-file string            identify HTTPS client using this SSL key file
      --pass-credentials           pass credentials to all domains
      --password string            chart repository password
      --password-stdin             read chart repository password from stdin
      --timeout duration           time to wait for the index file download to complete (default 2m0s)
      --username string            chart repository username
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm repo](/helm/helm_repo.md)	 - add, list, remove, update, and index chart repositories

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_repo_index.md">
---
title: helm repo index
---

generate an index file given a directory containing packaged charts

### Synopsis


Read the current directory, generate an index file based on the charts found
and write the result to 'index.yaml' in the current directory.

This tool is used for creating an 'index.yaml' file for a chart repository. To
set an absolute URL to the charts, use '--url' flag.

To merge the generated index with an existing index file, use the '--merge'
flag. In this case, the charts found in the current directory will be merged
into the index passed in with --merge, with local charts taking priority over
existing charts.


```
helm repo index [DIR] [flags]
```

### Options

```
  -h, --help           help for index
      --json           output in JSON format
      --merge string   merge the generated index into the given index
      --url string     url of chart repository
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm repo](/helm/helm_repo.md)	 - add, list, remove, update, and index chart repositories

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_repo_list.md">
---
title: helm repo list
---

list chart repositories

```
helm repo list [flags]
```

### Options

```
  -h, --help            help for list
  -o, --output format   prints the output in the specified format. Allowed values: table, json, yaml (default table)
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm repo](/helm/helm_repo.md)	 - add, list, remove, update, and index chart repositories

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_repo_remove.md">
---
title: helm repo remove
---

remove one or more chart repositories

```
helm repo remove [REPO1 [REPO2 ...]] [flags]
```

### Options

```
  -h, --help   help for remove
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm repo](/helm/helm_repo.md)	 - add, list, remove, update, and index chart repositories

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_repo_update.md">
---
title: helm repo update
---

update information of available charts locally from chart repositories

### Synopsis


Update gets the latest information about charts from the respective chart repositories.
Information is cached locally, where it is used by commands like 'helm search'.

You can optionally specify a list of repositories you want to update.
	$ helm repo update <repo_name> ...
To update all the repositories, use 'helm repo update'.


```
helm repo update [REPO1 [REPO2 ...]] [flags]
```

### Options

```
  -h, --help               help for update
      --timeout duration   time to wait for the index file download to complete (default 2m0s)
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm repo](/helm/helm_repo.md)	 - add, list, remove, update, and index chart repositories

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_repo.md">
---
title: helm repo
---

add, list, remove, update, and index chart repositories

### Synopsis


This command consists of multiple subcommands to interact with chart repositories.

It can be used to add, remove, list, and index chart repositories.


### Options

```
  -h, --help   help for repo
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm](/helm/helm.md)	 - The Helm package manager for Kubernetes.
* [helm repo add](/helm/helm_repo_add.md)	 - add a chart repository
* [helm repo index](/helm/helm_repo_index.md)	 - generate an index file given a directory containing packaged charts
* [helm repo list](/helm/helm_repo_list.md)	 - list chart repositories
* [helm repo remove](/helm/helm_repo_remove.md)	 - remove one or more chart repositories
* [helm repo update](/helm/helm_repo_update.md)	 - update information of available charts locally from chart repositories

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_rollback.md">
---
title: helm rollback
---

roll back a release to a previous revision

### Synopsis


This command rolls back a release to a previous revision.

The first argument of the rollback command is the name of a release, and the
second is a revision (version) number. If this argument is omitted or set to
0, it will roll back to the previous release.

To see revision numbers, run 'helm history RELEASE'.


```
helm rollback <RELEASE> [REVISION] [flags]
```

### Options

```
      --cleanup-on-fail               allow deletion of new resources created in this rollback when rollback fails
      --dry-run string[="unset"]      simulates the operation without persisting changes. Must be one of: "none" (default), "client", or "server". '--dry-run=none' executes the operation normally and persists changes (no simulation). '--dry-run=client' simulates the operation client-side only and avoids cluster connections. '--dry-run=server' simulates the operation on the server, requiring cluster connectivity. (default "none")
      --force-conflicts               if set server-side apply will force changes against conflicts
      --force-replace                 force resource updates by replacement
  -h, --help                          help for rollback
      --history-max int               limit the maximum number of revisions saved per release. Use 0 for no limit (default 10)
      --no-hooks                      prevent hooks from running during rollback
      --server-side string            must be "true", "false" or "auto". Object updates run in the server instead of the client ("auto" defaults the value from the previous chart release's method) (default "auto")
      --timeout duration              time to wait for any individual Kubernetes operation (like Jobs for hooks) (default 5m0s)
      --wait WaitStrategy[=watcher]   if specified, will wait until all resources are in the expected state before marking the operation as successful. It will wait for as long as --timeout. Valid inputs are 'watcher' and 'legacy' (default hookOnly)
      --wait-for-jobs                 if set and --wait enabled, will wait until all Jobs have been completed before marking the release as successful. It will wait for as long as --timeout
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm](/helm/helm.md)	 - The Helm package manager for Kubernetes.

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_search_hub.md">
---
title: helm search hub
---

search for charts in the Artifact Hub or your own hub instance

### Synopsis


Search for Helm charts in the Artifact Hub or your own hub instance.

Artifact Hub is a web-based application that enables finding, installing, and
publishing packages and configurations for CNCF projects, including publicly
available distributed charts Helm charts. It is a Cloud Native Computing
Foundation sandbox project. You can browse the hub at https://artifacthub.io/

The [KEYWORD] argument accepts either a keyword string, or quoted string of rich
query options. For rich query options documentation, see
https://artifacthub.github.io/hub/api/?urls.primaryName=Monocular%20compatible%20search%20API#/Monocular/get_api_chartsvc_v1_charts_search

Previous versions of Helm used an instance of Monocular as the default
'endpoint', so for backwards compatibility Artifact Hub is compatible with the
Monocular search API. Similarly, when setting the 'endpoint' flag, the specified
endpoint must also be implement a Monocular compatible search API endpoint.
Note that when specifying a Monocular instance as the 'endpoint', rich queries
are not supported. For API details, see https://github.com/helm/monocular


```
helm search hub [KEYWORD] [flags]
```

### Options

```
      --endpoint string      Hub instance to query for charts (default "https://hub.helm.sh")
      --fail-on-no-result    search fails if no results are found
  -h, --help                 help for hub
      --list-repo-url        print charts repository URL
      --max-col-width uint   maximum column width for output table (default 50)
  -o, --output format        prints the output in the specified format. Allowed values: table, json, yaml (default table)
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm search](/helm/helm_search.md)	 - search for a keyword in charts

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_search_repo.md">
---
title: helm search repo
---

search repositories for a keyword in charts

### Synopsis


Search reads through all of the repositories configured on the system, and
looks for matches. Search of these repositories uses the metadata stored on
the system.

It will display the latest stable versions of the charts found. If you
specify the --devel flag, the output will include pre-release versions.
If you want to search using a version constraint, use --version.

Examples:

    # Search for stable release versions matching the keyword "nginx"
    $ helm search repo nginx

    # Search for release versions matching the keyword "nginx", including pre-release versions
    $ helm search repo nginx --devel

    # Search for the latest stable release for nginx-ingress with a major version of 1
    $ helm search repo nginx-ingress --version ^1.0.0

Repositories are managed with 'helm repo' commands.


```
helm search repo [keyword] [flags]
```

### Options

```
      --devel                use development versions (alpha, beta, and release candidate releases), too. Equivalent to version '>0.0.0-0'. If --version is set, this is ignored
      --fail-on-no-result    search fails if no results are found
  -h, --help                 help for repo
      --max-col-width uint   maximum column width for output table (default 50)
  -o, --output format        prints the output in the specified format. Allowed values: table, json, yaml (default table)
  -r, --regexp               use regular expressions for searching repositories you have added
      --version string       search using semantic versioning constraints on repositories you have added
  -l, --versions             show the long listing, with each version of each chart on its own line, for repositories you have added
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm search](/helm/helm_search.md)	 - search for a keyword in charts

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_search.md">
---
title: helm search
---

search for a keyword in charts

### Synopsis


Search provides the ability to search for Helm charts in the various places
they can be stored including the Artifact Hub and repositories you have added.
Use search subcommands to search different locations for charts.


### Options

```
  -h, --help   help for search
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm](/helm/helm.md)	 - The Helm package manager for Kubernetes.
* [helm search hub](/helm/helm_search_hub.md)	 - search for charts in the Artifact Hub or your own hub instance
* [helm search repo](/helm/helm_search_repo.md)	 - search repositories for a keyword in charts

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_show_all.md">
---
title: helm show all
---

show all information of the chart

### Synopsis


This command inspects a chart (directory, file, or URL) and displays all its content
(values.yaml, Chart.yaml, README)


```
helm show all [CHART] [flags]
```

### Options

```
      --ca-file string             verify certificates of HTTPS-enabled servers using this CA bundle
      --cert-file string           identify HTTPS client using this SSL certificate file
      --devel                      use development versions, too. Equivalent to version '>0.0.0-0'. If --version is set, this is ignored
  -h, --help                       help for all
      --insecure-skip-tls-verify   skip tls certificate checks for the chart download
      --key-file string            identify HTTPS client using this SSL key file
      --keyring string             location of public keys used for verification (default "~/.gnupg/pubring.gpg")
      --pass-credentials           pass credentials to all domains
      --password string            chart repository password where to locate the requested chart
      --plain-http                 use insecure HTTP connections for the chart download
      --repo string                chart repository url where to locate the requested chart
      --username string            chart repository username where to locate the requested chart
      --verify                     verify the package before using it
      --version string             specify a version constraint for the chart version to use. This constraint can be a specific tag (e.g. 1.1.1) or it may reference a valid range (e.g. ^2.0.0). If this is not specified, the latest version is used
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm show](/helm/helm_show.md)	 - show information of a chart

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_show_chart.md">
---
title: helm show chart
---

show the chart's definition

### Synopsis


This command inspects a chart (directory, file, or URL) and displays the contents
of the Chart.yaml file


```
helm show chart [CHART] [flags]
```

### Options

```
      --ca-file string             verify certificates of HTTPS-enabled servers using this CA bundle
      --cert-file string           identify HTTPS client using this SSL certificate file
      --devel                      use development versions, too. Equivalent to version '>0.0.0-0'. If --version is set, this is ignored
  -h, --help                       help for chart
      --insecure-skip-tls-verify   skip tls certificate checks for the chart download
      --key-file string            identify HTTPS client using this SSL key file
      --keyring string             location of public keys used for verification (default "~/.gnupg/pubring.gpg")
      --pass-credentials           pass credentials to all domains
      --password string            chart repository password where to locate the requested chart
      --plain-http                 use insecure HTTP connections for the chart download
      --repo string                chart repository url where to locate the requested chart
      --username string            chart repository username where to locate the requested chart
      --verify                     verify the package before using it
      --version string             specify a version constraint for the chart version to use. This constraint can be a specific tag (e.g. 1.1.1) or it may reference a valid range (e.g. ^2.0.0). If this is not specified, the latest version is used
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm show](/helm/helm_show.md)	 - show information of a chart

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_show_crds.md">
---
title: helm show crds
---

show the chart's CRDs

### Synopsis


This command inspects a chart (directory, file, or URL) and displays the contents
of the CustomResourceDefinition files


```
helm show crds [CHART] [flags]
```

### Options

```
      --ca-file string             verify certificates of HTTPS-enabled servers using this CA bundle
      --cert-file string           identify HTTPS client using this SSL certificate file
      --devel                      use development versions, too. Equivalent to version '>0.0.0-0'. If --version is set, this is ignored
  -h, --help                       help for crds
      --insecure-skip-tls-verify   skip tls certificate checks for the chart download
      --key-file string            identify HTTPS client using this SSL key file
      --keyring string             location of public keys used for verification (default "~/.gnupg/pubring.gpg")
      --pass-credentials           pass credentials to all domains
      --password string            chart repository password where to locate the requested chart
      --plain-http                 use insecure HTTP connections for the chart download
      --repo string                chart repository url where to locate the requested chart
      --username string            chart repository username where to locate the requested chart
      --verify                     verify the package before using it
      --version string             specify a version constraint for the chart version to use. This constraint can be a specific tag (e.g. 1.1.1) or it may reference a valid range (e.g. ^2.0.0). If this is not specified, the latest version is used
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm show](/helm/helm_show.md)	 - show information of a chart

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_show_readme.md">
---
title: helm show readme
---

show the chart's README

### Synopsis


This command inspects a chart (directory, file, or URL) and displays the contents
of the README file


```
helm show readme [CHART] [flags]
```

### Options

```
      --ca-file string             verify certificates of HTTPS-enabled servers using this CA bundle
      --cert-file string           identify HTTPS client using this SSL certificate file
      --devel                      use development versions, too. Equivalent to version '>0.0.0-0'. If --version is set, this is ignored
  -h, --help                       help for readme
      --insecure-skip-tls-verify   skip tls certificate checks for the chart download
      --key-file string            identify HTTPS client using this SSL key file
      --keyring string             location of public keys used for verification (default "~/.gnupg/pubring.gpg")
      --pass-credentials           pass credentials to all domains
      --password string            chart repository password where to locate the requested chart
      --plain-http                 use insecure HTTP connections for the chart download
      --repo string                chart repository url where to locate the requested chart
      --username string            chart repository username where to locate the requested chart
      --verify                     verify the package before using it
      --version string             specify a version constraint for the chart version to use. This constraint can be a specific tag (e.g. 1.1.1) or it may reference a valid range (e.g. ^2.0.0). If this is not specified, the latest version is used
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm show](/helm/helm_show.md)	 - show information of a chart

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_show_values.md">
---
title: helm show values
---

show the chart's values

### Synopsis


This command inspects a chart (directory, file, or URL) and displays the contents
of the values.yaml file


```
helm show values [CHART] [flags]
```

### Options

```
      --ca-file string             verify certificates of HTTPS-enabled servers using this CA bundle
      --cert-file string           identify HTTPS client using this SSL certificate file
      --devel                      use development versions, too. Equivalent to version '>0.0.0-0'. If --version is set, this is ignored
  -h, --help                       help for values
      --insecure-skip-tls-verify   skip tls certificate checks for the chart download
      --jsonpath string            supply a JSONPath expression to filter the output
      --key-file string            identify HTTPS client using this SSL key file
      --keyring string             location of public keys used for verification (default "~/.gnupg/pubring.gpg")
      --pass-credentials           pass credentials to all domains
      --password string            chart repository password where to locate the requested chart
      --plain-http                 use insecure HTTP connections for the chart download
      --repo string                chart repository url where to locate the requested chart
      --username string            chart repository username where to locate the requested chart
      --verify                     verify the package before using it
      --version string             specify a version constraint for the chart version to use. This constraint can be a specific tag (e.g. 1.1.1) or it may reference a valid range (e.g. ^2.0.0). If this is not specified, the latest version is used
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm show](/helm/helm_show.md)	 - show information of a chart

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_show.md">
---
title: helm show
---

show information of a chart

### Synopsis


This command consists of multiple subcommands to display information about a chart


### Options

```
  -h, --help   help for show
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm](/helm/helm.md)	 - The Helm package manager for Kubernetes.
* [helm show all](/helm/helm_show_all.md)	 - show all information of the chart
* [helm show chart](/helm/helm_show_chart.md)	 - show the chart's definition
* [helm show crds](/helm/helm_show_crds.md)	 - show the chart's CRDs
* [helm show readme](/helm/helm_show_readme.md)	 - show the chart's README
* [helm show values](/helm/helm_show_values.md)	 - show the chart's values

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_status.md">
---
title: helm status
---

display the status of the named release

### Synopsis


This command shows the status of a named release.
The status consists of:
- last deployment time
- k8s namespace in which the release lives
- state of the release (can be: unknown, deployed, uninstalled, superseded, failed, uninstalling, pending-install, pending-upgrade or pending-rollback)
- revision of the release
- description of the release (can be completion message or error message)
- list of resources that this release consists of
- details on last test suite run, if applicable
- additional notes provided by the chart


```
helm status RELEASE_NAME [flags]
```

### Options

```
  -h, --help            help for status
  -o, --output format   prints the output in the specified format. Allowed values: table, json, yaml (default table)
      --revision int    if set, display the status of the named release with revision
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm](/helm/helm.md)	 - The Helm package manager for Kubernetes.

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_template.md">
---
title: helm template
---

locally render templates

### Synopsis


Render chart templates locally and display the output.

Any values that would normally be looked up or retrieved in-cluster will be
faked locally. Additionally, none of the server-side testing of chart validity
(e.g. whether an API is supported) is done.


```
helm template [NAME] [CHART] [flags]
```

### Options

```
  -a, --api-versions strings                       Kubernetes api versions used for Capabilities.APIVersions (multiple can be specified)
      --ca-file string                             verify certificates of HTTPS-enabled servers using this CA bundle
      --cert-file string                           identify HTTPS client using this SSL certificate file
      --create-namespace                           create the release namespace if not present
      --dependency-update                          update dependencies if they are missing before installing the chart
      --description string                         add a custom description
      --devel                                      use development versions, too. Equivalent to version '>0.0.0-0'. If --version is set, this is ignored
      --disable-openapi-validation                 if set, the installation process will not validate rendered templates against the Kubernetes OpenAPI Schema
      --dry-run string[="unset"]                   simulates the operation either client-side or server-side. Must be either: "client", or "server". '--dry-run=client simulates the operation client-side only and avoids cluster connections. '--dry-run=server' simulates/validates the operation on the server, requiring cluster connectivity. (default "client")
      --enable-dns                                 enable DNS lookups when rendering templates
      --force-conflicts                            if set server-side apply will force changes against conflicts
      --force-replace                              force resource updates by replacement
  -g, --generate-name                              generate the name (and omit the NAME parameter)
  -h, --help                                       help for template
      --hide-notes                                 if set, do not show notes in install output. Does not affect presence in chart metadata
      --include-crds                               include CRDs in the templated output
      --insecure-skip-tls-verify                   skip tls certificate checks for the chart download
      --is-upgrade                                 set .Release.IsUpgrade instead of .Release.IsInstall
      --key-file string                            identify HTTPS client using this SSL key file
      --keyring string                             location of public keys used for verification (default "~/.gnupg/pubring.gpg")
      --kube-version string                        Kubernetes version used for Capabilities.KubeVersion
  -l, --labels stringToString                      Labels that would be added to release metadata. Should be divided by comma. (default [])
      --name-template string                       specify template used to name the release
      --no-hooks                                   prevent hooks from running during install
      --output-dir string                          writes the executed templates to files in output-dir instead of stdout
      --pass-credentials                           pass credentials to all domains
      --password string                            chart repository password where to locate the requested chart
      --plain-http                                 use insecure HTTP connections for the chart download
      --post-renderer postRendererString           the name of a postrenderer type plugin to be used for post rendering. If it exists, the plugin will be used
      --post-renderer-args postRendererArgsSlice   an argument to the post-renderer (can specify multiple) (default [])
      --release-name                               use release name in the output-dir path.
      --render-subchart-notes                      if set, render subchart notes along with the parent
      --replace                                    reuse the given name, only if that name is a deleted release which remains in the history. This is unsafe in production
      --repo string                                chart repository url where to locate the requested chart
      --rollback-on-failure                        if set, Helm will rollback (uninstall) the installation upon failure. The --wait flag will be default to "watcher" if --rollback-on-failure is set
      --server-side                                object updates run in the server instead of the client (default true)
      --set stringArray                            set values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)
      --set-file stringArray                       set values from respective files specified via the command line (can specify multiple or separate values with commas: key1=path1,key2=path2)
      --set-json stringArray                       set JSON values on the command line (can specify multiple or separate values with commas: key1=jsonval1,key2=jsonval2 or using json format: {"key1": jsonval1, "key2": "jsonval2"})
      --set-literal stringArray                    set a literal STRING value on the command line
      --set-string stringArray                     set STRING values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)
  -s, --show-only stringArray                      only show manifests rendered from the given templates
      --skip-crds                                  if set, no CRDs will be installed. By default, CRDs are installed if not already present
      --skip-schema-validation                     if set, disables JSON schema validation
      --skip-tests                                 skip tests from templated output
      --take-ownership                             if set, install will ignore the check for helm annotations and take ownership of the existing resources
      --timeout duration                           time to wait for any individual Kubernetes operation (like Jobs for hooks) (default 5m0s)
      --username string                            chart repository username where to locate the requested chart
  -f, --values strings                             specify values in a YAML file or a URL (can specify multiple)
      --verify                                     verify the package before using it
      --version string                             specify a version constraint for the chart version to use. This constraint can be a specific tag (e.g. 1.1.1) or it may reference a valid range (e.g. ^2.0.0). If this is not specified, the latest version is used
      --wait WaitStrategy[=watcher]                if specified, will wait until all resources are in the expected state before marking the operation as successful. It will wait for as long as --timeout. Valid inputs are 'watcher' and 'legacy' (default hookOnly)
      --wait-for-jobs                              if set and --wait enabled, will wait until all Jobs have been completed before marking the release as successful. It will wait for as long as --timeout
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm](/helm/helm.md)	 - The Helm package manager for Kubernetes.

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_test.md">
---
title: helm test
---

run tests for a release

### Synopsis


The test command runs the tests for a release.

The argument this command takes is the name of a deployed release.
The tests to be run are defined in the chart that was installed.


```
helm test [RELEASE] [flags]
```

### Options

```
      --filter strings     specify tests by attribute (currently "name") using attribute=value syntax or '!attribute=value' to exclude a test (can specify multiple or separate values with commas: name=test1,name=test2)
  -h, --help               help for test
      --logs               dump the logs from test pods (this runs after all tests are complete, but before any cleanup)
      --timeout duration   time to wait for any individual Kubernetes operation (like Jobs for hooks) (default 5m0s)
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm](/helm/helm.md)	 - The Helm package manager for Kubernetes.

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_uninstall.md">
---
title: helm uninstall
---

uninstall a release

### Synopsis


This command takes a release name and uninstalls the release.

It removes all of the resources associated with the last release of the chart
as well as the release history, freeing it up for future use.

Use the '--dry-run' flag to see which releases will be uninstalled without actually
uninstalling them.


```
helm uninstall RELEASE_NAME [...] [flags]
```

### Options

```
      --cascade string                Must be "background", "orphan", or "foreground". Selects the deletion cascading strategy for the dependents. Defaults to background. (default "background")
      --description string            add a custom description
      --dry-run                       simulate a uninstall
  -h, --help                          help for uninstall
      --ignore-not-found              Treat "release not found" as a successful uninstall
      --keep-history                  remove all associated resources and mark the release as deleted, but retain the release history
      --no-hooks                      prevent hooks from running during uninstallation
      --timeout duration              time to wait for any individual Kubernetes operation (like Jobs for hooks) (default 5m0s)
      --wait WaitStrategy[=watcher]   if specified, will wait until all resources are in the expected state before marking the operation as successful. It will wait for as long as --timeout. Valid inputs are 'watcher' and 'legacy' (default hookOnly)
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm](/helm/helm.md)	 - The Helm package manager for Kubernetes.

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_upgrade.md">
---
title: helm upgrade
---

upgrade a release

### Synopsis


This command upgrades a release to a new version of a chart.

The upgrade arguments must be a release and chart. The chart
argument can be either: a chart reference('example/mariadb'), a path to a chart directory,
a packaged chart, or a fully qualified URL. For chart references, the latest
version will be specified unless the '--version' flag is set.

To override values in a chart, use either the '--values' flag and pass in a file
or use the '--set' flag and pass configuration from the command line, to force string
values, use '--set-string'. You can use '--set-file' to set individual
values from a file when the value itself is too long for the command line
or is dynamically generated. You can also use '--set-json' to set json values
(scalars/objects/arrays) from the command line. Additionally, you can use '--set-json' and passing json object as a string.

You can specify the '--values'/'-f' flag multiple times. The priority will be given to the
last (right-most) file specified. For example, if both myvalues.yaml and override.yaml
contained a key called 'Test', the value set in override.yaml would take precedence:

    $ helm upgrade -f myvalues.yaml -f override.yaml redis ./redis

You can specify the '--set' flag multiple times. The priority will be given to the
last (right-most) set specified. For example, if both 'bar' and 'newbar' values are
set for a key called 'foo', the 'newbar' value would take precedence:

    $ helm upgrade --set foo=bar --set foo=newbar redis ./redis

You can update the values for an existing release with this command as well via the
'--reuse-values' flag. The 'RELEASE' and 'CHART' arguments should be set to the original
parameters, and existing values will be merged with any values set via '--values'/'-f'
or '--set' flags. Priority is given to new values.

    $ helm upgrade --reuse-values --set foo=bar --set foo=newbar redis ./redis

The --dry-run flag will output all generated chart manifests, including Secrets
which can contain sensitive values. To hide Kubernetes Secrets use the
--hide-secret flag. Please carefully consider how and when these flags are used.


```
helm upgrade [RELEASE] [CHART] [flags]
```

### Options

```
      --ca-file string                             verify certificates of HTTPS-enabled servers using this CA bundle
      --cert-file string                           identify HTTPS client using this SSL certificate file
      --cleanup-on-fail                            allow deletion of new resources created in this upgrade when upgrade fails
      --create-namespace                           if --install is set, create the release namespace if not present
      --dependency-update                          update dependencies if they are missing before installing the chart
      --description string                         add a custom description
      --devel                                      use development versions, too. Equivalent to version '>0.0.0-0'. If --version is set, this is ignored
      --disable-openapi-validation                 if set, the upgrade process will not validate rendered templates against the Kubernetes OpenAPI Schema
      --dry-run string[="unset"]                   simulates the operation without persisting changes. Must be one of: "none" (default), "client", or "server". '--dry-run=none' executes the operation normally and persists changes (no simulation). '--dry-run=client' simulates the operation client-side only and avoids cluster connections. '--dry-run=server' simulates the operation on the server, requiring cluster connectivity. (default "none")
      --enable-dns                                 enable DNS lookups when rendering templates
      --force-conflicts                            if set server-side apply will force changes against conflicts
      --force-replace                              force resource updates by replacement
  -h, --help                                       help for upgrade
      --hide-notes                                 if set, do not show notes in upgrade output. Does not affect presence in chart metadata
      --hide-secret                                hide Kubernetes Secrets when also using the --dry-run flag
      --history-max int                            limit the maximum number of revisions saved per release. Use 0 for no limit (default 10)
      --insecure-skip-tls-verify                   skip tls certificate checks for the chart download
  -i, --install                                    if a release by this name doesn't already exist, run an install
      --key-file string                            identify HTTPS client using this SSL key file
      --keyring string                             location of public keys used for verification (default "~/.gnupg/pubring.gpg")
  -l, --labels stringToString                      Labels that would be added to release metadata. Should be separated by comma. Original release labels will be merged with upgrade labels. You can unset label using null. (default [])
      --no-hooks                                   disable pre/post upgrade hooks
  -o, --output format                              prints the output in the specified format. Allowed values: table, json, yaml (default table)
      --pass-credentials                           pass credentials to all domains
      --password string                            chart repository password where to locate the requested chart
      --plain-http                                 use insecure HTTP connections for the chart download
      --post-renderer postRendererString           the name of a postrenderer type plugin to be used for post rendering. If it exists, the plugin will be used
      --post-renderer-args postRendererArgsSlice   an argument to the post-renderer (can specify multiple) (default [])
      --render-subchart-notes                      if set, render subchart notes along with the parent
      --repo string                                chart repository url where to locate the requested chart
      --reset-then-reuse-values                    when upgrading, reset the values to the ones built into the chart, apply the last release's values and merge in any overrides from the command line via --set and -f. If '--reset-values' or '--reuse-values' is specified, this is ignored
      --reset-values                               when upgrading, reset the values to the ones built into the chart
      --reuse-values                               when upgrading, reuse the last release's values and merge in any overrides from the command line via --set and -f. If '--reset-values' is specified, this is ignored
      --rollback-on-failure                        if set, Helm will rollback the upgrade to previous success release upon failure. The --wait flag will be defaulted to "watcher" if --rollback-on-failure is set
      --server-side string                         must be "true", "false" or "auto". Object updates run in the server instead of the client ("auto" defaults the value from the previous chart release's method) (default "auto")
      --set stringArray                            set values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)
      --set-file stringArray                       set values from respective files specified via the command line (can specify multiple or separate values with commas: key1=path1,key2=path2)
      --set-json stringArray                       set JSON values on the command line (can specify multiple or separate values with commas: key1=jsonval1,key2=jsonval2 or using json format: {"key1": jsonval1, "key2": "jsonval2"})
      --set-literal stringArray                    set a literal STRING value on the command line
      --set-string stringArray                     set STRING values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)
      --skip-crds                                  if set, no CRDs will be installed when an upgrade is performed with install flag enabled. By default, CRDs are installed if not already present, when an upgrade is performed with install flag enabled
      --skip-schema-validation                     if set, disables JSON schema validation
      --take-ownership                             if set, upgrade will ignore the check for helm annotations and take ownership of the existing resources
      --timeout duration                           time to wait for any individual Kubernetes operation (like Jobs for hooks) (default 5m0s)
      --username string                            chart repository username where to locate the requested chart
  -f, --values strings                             specify values in a YAML file or a URL (can specify multiple)
      --verify                                     verify the package before using it
      --version string                             specify a version constraint for the chart version to use. This constraint can be a specific tag (e.g. 1.1.1) or it may reference a valid range (e.g. ^2.0.0). If this is not specified, the latest version is used
      --wait WaitStrategy[=watcher]                if specified, will wait until all resources are in the expected state before marking the operation as successful. It will wait for as long as --timeout. Valid inputs are 'watcher' and 'legacy' (default hookOnly)
      --wait-for-jobs                              if set and --wait enabled, will wait until all Jobs have been completed before marking the release as successful. It will wait for as long as --timeout
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm](/helm/helm.md)	 - The Helm package manager for Kubernetes.

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_verify.md">
---
title: helm verify
---

verify that a chart at the given path has been signed and is valid

### Synopsis


Verify that the given chart has a valid provenance file.

Provenance files provide cryptographic verification that a chart has not been
tampered with, and was packaged by a trusted provider.

This command can be used to verify a local chart. Several other commands provide
'--verify' flags that run the same validation. To generate a signed package, use
the 'helm package --sign' command.


```
helm verify PATH [flags]
```

### Options

```
  -h, --help             help for verify
      --keyring string   keyring containing public keys (default "~/.gnupg/pubring.gpg")
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm](/helm/helm.md)	 - The Helm package manager for Kubernetes.

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm_version.md">
---
title: helm version
---

print the helm version information

### Synopsis


Show the version for Helm.

This will print a representation the version of Helm.
The output will look something like this:

version.BuildInfo{Version:"v3.2.1", GitCommit:"fe51cd1e31e6a202cba7dead9552a6d418ded79a", GitTreeState:"clean", GoVersion:"go1.13.10"}

- Version is the semantic version of the release.
- GitCommit is the SHA for the commit that this version was built from.
- GitTreeState is "clean" if there are no local code changes when this binary was
  built, and "dirty" if the binary was built from locally modified code.
- GoVersion is the version of Go that was used to compile Helm.

When using the --template flag the following properties are available to use in
the template:

- .Version contains the semantic version of Helm
- .GitCommit is the git commit
- .GitTreeState is the state of the git tree when Helm was built
- .GoVersion contains the version of Go that Helm was compiled with

For example, --template='Version: {{.Version}}' outputs 'Version: v3.2.1'.


```
helm version [flags]
```

### Options

```
  -h, --help              help for version
      --short             print the version number
      --template string   template for version string format
```

### Options inherited from parent commands

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm](/helm/helm.md)	 - The Helm package manager for Kubernetes.

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/helm.md">
---
title: helm
slug: helm
---

The Helm package manager for Kubernetes.

### Synopsis

The Kubernetes package manager

Common actions for Helm:

- helm search:    search for charts
- helm pull:      download a chart to your local directory to view
- helm install:   upload the chart to Kubernetes
- helm list:      list releases of charts

Environment variables:

| Name                               | Description                                                                                                |
|------------------------------------|------------------------------------------------------------------------------------------------------------|
| $HELM_CACHE_HOME                   | set an alternative location for storing cached files.                                                      |
| $HELM_CONFIG_HOME                  | set an alternative location for storing Helm configuration.                                                |
| $HELM_DATA_HOME                    | set an alternative location for storing Helm data.                                                         |
| $HELM_DEBUG                        | indicate whether or not Helm is running in Debug mode                                                      |
| $HELM_DRIVER                       | set the backend storage driver. Values are: configmap, secret, memory, sql.                                |
| $HELM_DRIVER_SQL_CONNECTION_STRING | set the connection string the SQL storage driver should use.                                               |
| $HELM_MAX_HISTORY                  | set the maximum number of helm release history.                                                            |
| $HELM_NAMESPACE                    | set the namespace used for the helm operations.                                                            |
| $HELM_NO_PLUGINS                   | disable plugins. Set HELM_NO_PLUGINS=1 to disable plugins.                                                 |
| $HELM_PLUGINS                      | set the path to the plugins directory                                                                      |
| $HELM_REGISTRY_CONFIG              | set the path to the registry config file.                                                                  |
| $HELM_REPOSITORY_CACHE             | set the path to the repository cache directory                                                             |
| $HELM_REPOSITORY_CONFIG            | set the path to the repositories file.                                                                     |
| $KUBECONFIG                        | set an alternative Kubernetes configuration file (default "~/.kube/config")                                |
| $HELM_KUBEAPISERVER                | set the Kubernetes API Server Endpoint for authentication                                                  |
| $HELM_KUBECAFILE                   | set the Kubernetes certificate authority file.                                                             |
| $HELM_KUBEASGROUPS                 | set the Groups to use for impersonation using a comma-separated list.                                      |
| $HELM_KUBEASUSER                   | set the Username to impersonate for the operation.                                                         |
| $HELM_KUBECONTEXT                  | set the name of the kubeconfig context.                                                                    |
| $HELM_KUBETOKEN                    | set the Bearer KubeToken used for authentication.                                                          |
| $HELM_KUBEINSECURE_SKIP_TLS_VERIFY | indicate if the Kubernetes API server's certificate validation should be skipped (insecure)                |
| $HELM_KUBETLS_SERVER_NAME          | set the server name used to validate the Kubernetes API server certificate                                 |
| $HELM_BURST_LIMIT                  | set the default burst limit in the case the server contains many CRDs (default 100, -1 to disable)         |
| $HELM_QPS                          | set the Queries Per Second in cases where a high number of calls exceed the option for higher burst values |
| $HELM_COLOR                        | set color output mode. Allowed values: never, always, auto (default: never)                                |
| $NO_COLOR                          | set to any non-empty value to disable all colored output (overrides $HELM_COLOR)                           |

Helm stores cache, configuration, and data based on the following configuration order:

- If a HELM_*_HOME environment variable is set, it will be used
- Otherwise, on systems supporting the XDG base directory specification, the XDG variables will be used
- When no other location is set a default location will be used based on the operating system

By default, the default directories depend on the Operating System. The defaults are listed below:

| Operating System | Cache Path                | Configuration Path             | Data Path               |
|------------------|---------------------------|--------------------------------|-------------------------|
| Linux            | $HOME/.cache/helm         | $HOME/.config/helm             | $HOME/.local/share/helm |
| macOS            | $HOME/Library/Caches/helm | $HOME/Library/Preferences/helm | $HOME/Library/helm      |
| Windows          | %TEMP%\helm               | %APPDATA%\helm                 | %APPDATA%\helm          |


### Options

```
      --burst-limit int                 client-side default throttling limit (default 100)
      --color string                    use colored output (never, auto, always) (default "auto")
      --colour string                   use colored output (never, auto, always) (default "auto")
      --content-cache string            path to the directory containing cached content (e.g. charts) (default "~/.cache/helm/content")
      --debug                           enable verbose output
  -h, --help                            help for helm
      --kube-apiserver string           the address and the port for the Kubernetes API server
      --kube-as-group stringArray       group to impersonate for the operation, this flag can be repeated to specify multiple groups.
      --kube-as-user string             username to impersonate for the operation
      --kube-ca-file string             the certificate authority file for the Kubernetes API server connection
      --kube-context string             name of the kubeconfig context to use
      --kube-insecure-skip-tls-verify   if true, the Kubernetes API server's certificate will not be checked for validity. This will make your HTTPS connections insecure
      --kube-tls-server-name string     server name to use for Kubernetes API server certificate validation. If it is not provided, the hostname used to contact the server is used
      --kube-token string               bearer token used for authentication
      --kubeconfig string               path to the kubeconfig file
  -n, --namespace string                namespace scope for this request
      --qps float32                     queries per second used when communicating with the Kubernetes API, not including bursting
      --registry-config string          path to the registry config file (default "~/.config/helm/registry/config.json")
      --repository-cache string         path to the directory containing cached repository indexes (default "~/.cache/helm/repository")
      --repository-config string        path to the file containing repository names and URLs (default "~/.config/helm/repositories.yaml")
```

### SEE ALSO

* [helm completion](/helm/helm_completion.md)	 - generate autocompletion scripts for the specified shell
* [helm create](/helm/helm_create.md)	 - create a new chart with the given name
* [helm dependency](/helm/helm_dependency.md)	 - manage a chart's dependencies
* [helm env](/helm/helm_env.md)	 - helm client environment information
* [helm get](/helm/helm_get.md)	 - download extended information of a named release
* [helm history](/helm/helm_history.md)	 - fetch release history
* [helm install](/helm/helm_install.md)	 - install a chart
* [helm lint](/helm/helm_lint.md)	 - examine a chart for possible issues
* [helm list](/helm/helm_list.md)	 - list releases
* [helm package](/helm/helm_package.md)	 - package a chart directory into a chart archive
* [helm plugin](/helm/helm_plugin.md)	 - install, list, or uninstall Helm plugins
* [helm pull](/helm/helm_pull.md)	 - download a chart from a repository and (optionally) unpack it in local directory
* [helm push](/helm/helm_push.md)	 - push a chart to remote
* [helm registry](/helm/helm_registry.md)	 - login to or logout from a registry
* [helm repo](/helm/helm_repo.md)	 - add, list, remove, update, and index chart repositories
* [helm rollback](/helm/helm_rollback.md)	 - roll back a release to a previous revision
* [helm search](/helm/helm_search.md)	 - search for a keyword in charts
* [helm show](/helm/helm_show.md)	 - show information of a chart
* [helm status](/helm/helm_status.md)	 - display the status of the named release
* [helm template](/helm/helm_template.md)	 - locally render templates
* [helm test](/helm/helm_test.md)	 - run tests for a release
* [helm uninstall](/helm/helm_uninstall.md)	 - uninstall a release
* [helm upgrade](/helm/helm_upgrade.md)	 - upgrade a release
* [helm verify](/helm/helm_verify.md)	 - verify that a chart at the given path has been signed and is valid
* [helm version](/helm/helm_version.md)	 - print the helm version information

###### Auto generated by spf13/cobra on 6-Nov-2025
</file>

<file path="helm/index.mdx">
---
title: Helm Commands
description: Documentation for the full list of helm CLI commands.
sidebar_position: 6
id: helm-category
---

# Helm Commands

Here you'll find the list of CLI commands for Helm, with help info on their usage.


import DocCardList from '@theme/DocCardList';

<DocCardList />
</file>

<file path="howto/chart_releaser_action.md">
---
title: Chart Releaser Action to Automate GitHub Page Charts
description: Describe how to use Chart Releaser Action to automate releasing charts through GitHub pages.
sidebar_position: 3
---

This guide describes how to use [Chart Releaser
Action](https://github.com/marketplace/actions/helm-chart-releaser) to automate
releasing charts through GitHub pages.  Chart Releaser Action is a GitHub Action
workflow to turn a GitHub project into a self-hosted Helm chart repo, using
[helm/chart-releaser](https://github.com/helm/chart-releaser) CLI tool.

## Repository Changes

Create a Git repository under your GitHub organization.  You could give the name
of the repository as `helm-charts`, though other names are also acceptable.  The
sources of all the charts can be placed under the `main` branch.  The charts
should be placed under `/charts` directory at the top-level of the directory
tree.

There should be another branch named `gh-pages` to publish the charts.  The
changes to that branch will be automatically created by the Chart Releaser
Action described here.  However, you can create that `gh-branch` and add
`README.md` file, which is going to be visible to the users visiting the page.

You can add instruction in the `README.md` for charts installation like this
(replace `<alias>`, `<orgname>`, and `<chart-name>`):

```
## Usage

[Helm](https://helm.sh) must be installed to use the charts.  Please refer to
Helm's [documentation](https://helm.sh/docs) to get started.

Once Helm has been set up correctly, add the repo as follows:

  helm repo add <alias> https://<orgname>.github.io/helm-charts

If you had already added this repo earlier, run `helm repo update` to retrieve
the latest versions of the packages.  You can then run `helm search repo
<alias>` to see the charts.

To install the <chart-name> chart:

    helm install my-<chart-name> <alias>/<chart-name>

To uninstall the chart:

    helm uninstall my-<chart-name>
```

The charts will be published to a website with URL like this:

    https://<orgname>.github.io/helm-charts

## GitHub Actions Workflow

Create GitHub Actions workflow file in the `main` branch at
`.github/workflows/release.yml`

```
name: Release Charts

on:
  push:
    branches:
      - main

jobs:
  release:
    permissions:
      contents: write
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config user.name "$GITHUB_ACTOR"
          git config user.email "$GITHUB_ACTOR@users.noreply.github.com"

      - name: Run chart-releaser
        uses: helm/chart-releaser-action@v1.6.0
        env:
          CR_TOKEN: "${{ secrets.GITHUB_TOKEN }}"
```

The above configuration uses
[@helm/chart-releaser-action](https://github.com/helm/chart-releaser-action) to
turn your GitHub project into a self-hosted Helm chart repo.  It does this -
during every push to main - by checking each chart in your project, and whenever
there's a new chart version, creates a corresponding GitHub release named for
the chart version, adds Helm chart artifacts to the release, and creates or
updates an `index.yaml` file with metadata about those releases, which is then
hosted on GitHub pages.

The Chart Releaser Action version number used in the above example is `v1.6.0`.
You can change it to the [latest available
version](https://github.com/helm/chart-releaser-action/releases).

Note: The Chart Releaser Action is almost always used in tandem with the [Helm Testing
Action](https://github.com/marketplace/actions/helm-chart-testing) and [Kind
Action](https://github.com/marketplace/actions/kind-cluster).
</file>

<file path="howto/chart_repository_sync_example.md">
---
title: Syncing Your Chart Repository
description: Describes how to synchronize your local and remote chart repositories.
sidebar_position: 2
---

*Note: This example is specifically for a Google Cloud Storage (GCS) bucket
which serves a chart repository.*

## Prerequisites
* Install the [gsutil](https://cloud.google.com/storage/docs/gsutil) tool. *We
  rely heavily on the gsutil rsync functionality*
* Be sure to have access to the Helm binary
* _Optional: We recommend you set [object
  versioning](https://cloud.google.com/storage/docs/gsutil/addlhelp/ObjectVersioningandConcurrencyControl#top_of_page)
  on your GCS bucket in case you accidentally delete something._

## Set up a local chart repository directory
Create a local directory like we did in [the chart repository guide](/topics/chart_repository.md), and place your packaged charts in that
directory.

For example:
```console
$ mkdir fantastic-charts
$ mv alpine-0.1.0.tgz fantastic-charts/
```

## Generate an updated index.yaml
Use Helm to generate an updated index.yaml file by passing in the directory path
and the url of the remote repository to the `helm repo index` command like this:

```console
$ helm repo index fantastic-charts/ --url https://fantastic-charts.storage.googleapis.com
```
This will generate an updated index.yaml file and place it in the
`fantastic-charts/` directory.

## Sync your local and remote chart repositories
Upload the contents of the directory to your GCS bucket by running
`scripts/sync-repo.sh` and pass in the local directory name and the GCS bucket
name.

For example:
```console
$ pwd
/Users/me/code/go/src/helm.sh/helm
$ scripts/sync-repo.sh fantastic-charts/ fantastic-charts
Getting ready to sync your local directory (fantastic-charts/) to a remote repository at gs://fantastic-charts
Verifying Prerequisites....
Thumbs up! Looks like you have gsutil. Let's continue.
Building synchronization state...
Starting synchronization
Would copy file://fantastic-charts/alpine-0.1.0.tgz to gs://fantastic-charts/alpine-0.1.0.tgz
Would copy file://fantastic-charts/index.yaml to gs://fantastic-charts/index.yaml
Are you sure you would like to continue with these changes?? [y/N]} y
Building synchronization state...
Starting synchronization
Copying file://fantastic-charts/alpine-0.1.0.tgz [Content-Type=application/x-tar]...
Uploading   gs://fantastic-charts/alpine-0.1.0.tgz:              740 B/740 B
Copying file://fantastic-charts/index.yaml [Content-Type=application/octet-stream]...
Uploading   gs://fantastic-charts/index.yaml:                    347 B/347 B
Congratulations your remote chart repository now matches the contents of fantastic-charts/
```
## Updating your chart repository
You'll want to keep a local copy of the contents of your chart repository or use
`gsutil rsync` to copy the contents of your remote chart repository to a local
directory.

For example:
```console
$ gsutil rsync -d -n gs://bucket-name local-dir/    # the -n flag does a dry run
Building synchronization state...
Starting synchronization
Would copy gs://bucket-name/alpine-0.1.0.tgz to file://local-dir/alpine-0.1.0.tgz
Would copy gs://bucket-name/index.yaml to file://local-dir/index.yaml

$ gsutil rsync -d gs://bucket-name local-dir/       # performs the copy actions
Building synchronization state...
Starting synchronization
Copying gs://bucket-name/alpine-0.1.0.tgz...
Downloading file://local-dir/alpine-0.1.0.tgz:                        740 B/740 B
Copying gs://bucket-name/index.yaml...
Downloading file://local-dir/index.yaml:                              346 B/346 B
```

Helpful Links:
* Documentation on [gsutil
  rsync](https://cloud.google.com/storage/docs/gsutil/commands/rsync#description)
* [The Chart Repository Guide](/topics/chart_repository.md)
* Documentation on [object versioning and concurrency
  control](https://cloud.google.com/storage/docs/gsutil/addlhelp/ObjectVersioningandConcurrencyControl#overview)
  in Google Cloud Storage
</file>

<file path="howto/charts_tips_and_tricks.md">
---
title: Chart Development Tips and Tricks
description: Covers some of the tips and tricks Helm chart developers have learned while building production-quality charts.
sidebar_position: 1
---

This guide covers some of the tips and tricks Helm chart developers have learned
while building production-quality charts.

## Know Your Template Functions

Helm uses [Go templates](https://godoc.org/text/template) for templating your
resource files. While Go ships several built-in functions, we have added many
others.

First, we added all of the functions in the [Sprig
library](https://masterminds.github.io/sprig/), except `env` and `expandenv`, for security reasons.

We also added two special template functions: `include` and `required`. The
`include` function allows you to bring in another template, and then pass the
results to other template functions. The `required` function allows you to declare
a particular values entry as required for template rendering. If the value is empty,
the template rendering will fail with a user submitted error message.

### Using the 'include' Function

Go provides a way of including one template in another using a built-in
`template` directive. However, the built-in function cannot be used in Go
template pipelines.

To make it possible to include a template, and then perform an operation on that
template's output, Helm has a special `include` function:

```
{{ include "toYaml" $value | indent 2 }}
```

The above includes a template called `toYaml`, passes it `$value`, and then
passes the output of that template to the `indent` function.

Because YAML ascribes significance to indentation levels and whitespace, this is
one great way to include snippets of code, but handle indentation in a relevant
context.

This template snippet includes a template called `mytpl`, then
lowercases the result, then wraps that in double quotes.

```yaml
value: {{ include "mytpl" . | lower | quote }}
```

### Using the 'required' function

Go provides a `missingkey` template option to control behavior when a map is indexed
with a key that's not present in the map. There may be situations where a chart
developer wants to enforce this behavior for select values in the `values.yaml` file.

The `required` function gives developers the ability to declare a value entry as
required for template rendering. If the entry is empty in `values.yaml`, the
template will not render and will return an error message supplied by the
developer.

For example:

```
{{ required "A valid foo is required!" .Values.foo }}
```

The above will render the template when `.Values.foo` is defined, but will fail
to render and exit when `.Values.foo` is undefined.

The following example of the `required` function declares an entry for
`.Values.who` is required, and will print an error message when that entry is
missing:

```yaml
value: {{ required "A valid .Values.who entry required!" .Values.who }}
```

## Quote Strings, Don't Quote Integers

When you are working with string data, you are always safer quoting the strings
than leaving them as bare words:

```yaml
name: {{ .Values.MyName | quote }}
```

But when working with integers _do not quote the values._ That can, in many
cases, cause parsing errors inside of Kubernetes.

```yaml
port: {{ .Values.Port }}
```

This remark does not apply to env variables values which are expected to be
string, even if they represent integers:

```yaml
env:
  - name: HOST
    value: "http://host"
  - name: PORT
    value: "1234"
```

## Using the 'tpl' Function

The `tpl` function allows developers to evaluate strings as templates inside a
template. This is useful to pass a template string as a value to a chart or
render external configuration files. Syntax: `{{ tpl TEMPLATE_STRING VALUES }}`

Examples:

```yaml
# values
template: "{{ .Values.name }}"
name: "Tom"

# template
{{ tpl .Values.template . }}

# output
Tom
```

Rendering an external configuration file:

```yaml
# external configuration file conf/app.conf
firstName={{ .Values.firstName }}
lastName={{ .Values.lastName }}

# values
firstName: Peter
lastName: Parker

# template
{{ tpl (.Files.Get "conf/app.conf") . }}

# output
firstName=Peter
lastName=Parker
```

## Creating Image Pull Secrets
Image pull secrets are essentially a combination of _registry_, _username_, and
_password_.  You may need them in an application you are deploying, but to
create them requires running `base64` a couple of times.  We can write a helper
template to compose the Docker configuration file for use as the Secret's
payload.  Here is an example:

First, assume that the credentials are defined in the `values.yaml` file like
so:
```yaml
imageCredentials:
  registry: quay.io
  username: someone
  password: sillyness
  email: someone@host.com
```

We then define our helper template as follows:
```
{{- define "imagePullSecret" }}
{{- with .Values.imageCredentials }}
{{- printf "{\"auths\":{\"%s\":{\"username\":\"%s\",\"password\":%s,\"email\":\"%s\",\"auth\":\"%s\"}}}" .registry .username (.password | quote) .email (printf "%s:%s" .username .password | b64enc) | b64enc }}
{{- end }}
{{- end }}
```

Finally, we use the helper template in a larger template to create the Secret
manifest:
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: myregistrykey
type: kubernetes.io/dockerconfigjson
data:
  .dockerconfigjson: {{ template "imagePullSecret" . }}
```

## Automatically Roll Deployments

Often times ConfigMaps or Secrets are injected as configuration files in
containers or there are other external dependency changes that require rolling
pods. Depending on the application a restart may be required should those be
updated with a subsequent `helm upgrade`, but if the deployment spec itself
didn't change the application keeps running with the old configuration resulting
in an inconsistent deployment.

The `sha256sum` function can be used to ensure a deployment's annotation section
is updated if another file changes:

```yaml
kind: Deployment
spec:
  template:
    metadata:
      annotations:
        checksum/config: {{ include (print $.Template.BasePath "/configmap.yaml") . | sha256sum }}
[...]
```

NOTE: If you're adding this to a library chart you won't be able to access your
file in `$.Template.BasePath`. Instead you can reference your definition with
`{{ include ("mylibchart.configmap") . | sha256sum }}`.

In the event you always want to roll your deployment, you can use a similar
annotation step as above, instead replacing with a random string so it always
changes and causes the deployment to roll:

```yaml
kind: Deployment
spec:
  template:
    metadata:
      annotations:
        rollme: {{ randAlphaNum 5 | quote }}
[...]
```

Each invocation of the template function will generate a unique random string.
This means that if it's necessary to sync the random strings used by multiple
resources, all relevant resources will need to be in the same template file.

Both of these methods allow your Deployment to leverage the built in update
strategy logic to avoid taking downtime.

NOTE: In the past we recommended using the `--recreate-pods` flag as another
option. This flag has been marked as deprecated in Helm 3 in favor of the more
declarative method above.

## Tell Helm Not To Uninstall a Resource

Sometimes there are resources that should not be uninstalled when Helm runs a
`helm uninstall`. Chart developers can add an annotation to a resource to
prevent it from being uninstalled.

```yaml
kind: Secret
metadata:
  annotations:
    helm.sh/resource-policy: keep
[...]
```

The annotation `helm.sh/resource-policy: keep` instructs Helm to skip deleting
this resource when a helm operation (such as `helm uninstall`, `helm upgrade` or
`helm rollback`) would result in its deletion. _However_, this resource becomes
orphaned. Helm will no longer manage it in any way. This can lead to problems if
using `helm install --replace` on a release that has already been uninstalled,
but has kept resources.

## Using "Partials" and Template Includes

Sometimes you want to create some reusable parts in your chart, whether they're
blocks or template partials. And often, it's cleaner to keep these in their own
files.

In the `templates/` directory, any file that begins with an underscore(`_`) is
not expected to output a Kubernetes manifest file. So by convention, helper
templates and partials are placed in a `_helpers.tpl` file.

## Complex Charts with Many Dependencies

Many of the charts in the CNCF [Artifact
Hub](https://artifacthub.io/packages/search?kind=0) are "building blocks" for
creating more advanced applications. But charts may be used to create instances
of large-scale applications. In such cases, a single umbrella chart may have
multiple subcharts, each of which functions as a piece of the whole.

The current best practice for composing a complex application from discrete
parts is to create a top-level umbrella chart that exposes the global
configurations, and then use the `charts/` subdirectory to embed each of the
components.

## YAML is a Superset of JSON

According to the YAML specification, YAML is a superset of JSON. That means that
any valid JSON structure ought to be valid in YAML.

This has an advantage: Sometimes template developers may find it easier to
express a datastructure with a JSON-like syntax rather than deal with YAML's
whitespace sensitivity.

As a best practice, templates should follow a YAML-like syntax _unless_ the JSON
syntax substantially reduces the risk of a formatting issue.

## Be Careful with Generating Random Values

There are functions in Helm that allow you to generate random data,
cryptographic keys, and so on. These are fine to use. But be aware that during
upgrades, templates are re-executed. When a template run generates data that
differs from the last run, that will trigger an update of that resource.

## Install or Upgrade a Release with One Command

Helm provides a way to perform an install-or-upgrade as a single command. Use
`helm upgrade` with the `--install` command. This will cause Helm to see if the
release is already installed. If not, it will run an install. If it is, then the
existing release will be upgraded.

```console
$ helm upgrade --install <release name> --values <values file> <chart directory>
```
</file>

<file path="howto/index.mdx">
---
title: How-to
sidebar_position: 3
---

# How-to Guides

Here youâ€™ll find short answers to â€œHow do Iâ€¦.?â€ types of questions. These how-to
guides donâ€™t cover topics in depth â€“ youâ€™ll find that material in the [Topic
Guides](/topics/index.mdx). However, these guides will help you quickly accomplish
common tasks.


import DocCardList from '@theme/DocCardList';

<DocCardList />
</file>

<file path="intro/CheatSheet.mdx">
---
title: Cheat Sheet
description: Helm cheatsheet
sidebar_position: 4
---

import Helm4 from "/docs/_v4-in-progress.mdx"

<Helm4/>

Helm cheatsheet featuring all the necessary commands required to manage an application through Helm.

-----------------------------------------------------------------------------------------------------------------------------------------------
### Basic interpretations/context

Chart:
- It is the name of your chart in case it has been pulled and untarred.
- It is `<repo_name>/<chart_name>` in case the repository has been added but chart not pulled.
- It is the URL/Absolute path to the chart.

Name:
- It is the name you want to give to your current helm chart installation.

Release:
- Is the name you assigned to an installation instance.

Revision:
- Is the value from the Helm history command

Repo-name:
- The name of a repository.

DIR:
- Directory name/path

------------------------------------------------------------------------------------------------------------------------------------------------

### Chart Management

```bash
helm create <name>                      # Creates a chart directory along with the common files and directories used in a chart.
helm package <chart-path>               # Packages a chart into a versioned chart archive file.
helm lint <chart>                       # Run tests to examine a chart and identify possible issues:
helm show all <chart>                   # Inspect a chart and list its contents:
helm show values <chart>                # Displays the contents of the values.yaml file
helm pull <chart>                       # Download/pull chart
helm pull <chart> --untar=true          # If set to true, will untar the chart after downloading it
helm pull <chart> --verify              # Verify the package before using it
helm pull <chart> --version <number>    # Default-latest is used, specify a version constraint for the chart version to use
helm dependency list <chart>            # Display a list of a chartâ€™s dependencies:
```
--------------------------------------------------------------------------------------------------------------------------------------------------

### Install and Uninstall Apps

```bash
helm install <name> <chart>                           # Install the chart with a name
helm install <name> <chart> --namespace <namespace>   # Install the chart in a specific namespace
helm install <name> <chart> --set key1=val1,key2=val2 # Set values on the command line (can specify multiple or separate values with commas)
helm install <name> <chart> --values <yaml-file/url>  # Install the chart with your specified values
helm install <name> <chart> --dry-run --debug         # Run a test installation to validate chart (p)
helm install <name> <chart> --verify                  # Verify the package before using it
helm install <name> <chart> --dependency-update       # update dependencies if they are missing before installing the chart
helm uninstall <name>                                 # Uninstalls a release from the current (default) namespace
helm uninstall <release-name> --namespace <namespace> # Uninstalls a release from the specified namespace
```
------------------------------------------------------------------------------------------------------------------------------------------------
### Perform App Upgrade and Rollback

```bash
helm upgrade <release> <chart>                            # Upgrade a release
helm upgrade <release> <chart> --rollback-on-failure      # If set, upgrade process rolls back changes made in case of failed upgrade.
helm upgrade <release> <chart> --dependency-update        # update dependencies if they are missing before installing the chart
helm upgrade <release> <chart> --version <version_number> # specify a version constraint for the chart version to use
helm upgrade <release> <chart> --values                   # specify values in a YAML file or a URL (can specify multiple)
helm upgrade <release> <chart> --set key1=val1,key2=val2  # Set values on the command line (can specify multiple or separate valuese)
helm upgrade <release> <chart> --force                    # Force resource updates through a replacement strategy
helm rollback <release> <revision>                        # Roll back a release to a specific revision
helm rollback <release> <revision>  --cleanup-on-fail     # Allow deletion of new resources created in this rollback when rollback fails
```
------------------------------------------------------------------------------------------------------------------------------------------------
### List, Add, Remove, and Update Repositories

```bash
helm repo add <repo-name> <url>   # Add a repository from the internet:
helm repo list                    # List added chart repositories
helm repo update                  # Update information of available charts locally from chart repositories
helm repo remove <repo_name>      # Remove one or more chart repositories
helm repo index <DIR>             # Read the current directory and generate an index file based on the charts found.
helm repo index <DIR> --merge     # Merge the generated index with an existing index file
helm search repo <keyword>        # Search repositories for a keyword in charts
helm search hub <keyword>         # Search for charts in the Artifact Hub or your own hub instance
```
-------------------------------------------------------------------------------------------------------------------------------------------------
### Helm Release monitoring

```bash
helm list                       # Lists all of the releases for a specified namespace, uses current namespace context if namespace not specified
helm list --all                 # Show all releases without any filter applied, can use -a
helm list --all-namespaces      # List releases across all namespaces, we can use -A
helm list -l key1=value1,key2=value2 # Selector (label query) to filter on, supports '=', '==', and '!='
helm list --date                # Sort by release date
helm list --deployed            # Show deployed releases. If no other is specified, this will be automatically enabled
helm list --pending             # Show pending releases
helm list --failed              # Show failed releases
helm list --uninstalled         # Show uninstalled releases (if 'helm uninstall --keep-history' was used)
helm list --superseded          # Show superseded releases
helm list -o yaml               # Prints the output in the specified format. Allowed values: table, json, yaml (default table)
helm status <release>           # This command shows the status of a named release.
helm status <release> --revision <number>   # if set, display the status of the named release with revision
helm history <release>          # Historical revisions for a given release.
helm env                        # Env prints out all the environment information in use by Helm.
```
-------------------------------------------------------------------------------------------------------------------------------------------------
### Download Release Information

```bash
helm get all <release>      # A human readable collection of information about the notes, hooks, supplied values, and generated manifest file of the given release.
helm get hooks <release>    # This command downloads hooks for a given release. Hooks are formatted in YAML and separated by the YAML '---\n' separator.
helm get manifest <release> # A manifest is a YAML-encoded representation of the Kubernetes resources that were generated from this release's chart(s). If a chart is dependent on other charts, those resources will also be included in the manifest.
helm get notes <release>    # Shows notes provided by the chart of a named release.
helm get values <release>   # Downloads a values file for a given release. use -o to format output
```
-------------------------------------------------------------------------------------------------------------------------------------------------
### Plugin Management

```bash
helm plugin install <path/url>      # Install plugins
helm plugin list                    # View a list of all installed plugins
helm plugin update <plugin>         # Update plugins
helm plugin uninstall <plugin>      # Uninstall a plugin
```
-------------------------------------------------------------------------------------------------------------------------------------------------
</file>

<file path="intro/index.mdx">
---
title: Introduction
sidebar_position: 2
---

# Introduction to Helm

Are you new to Helm? This is the place to start!


import DocCardList from '@theme/DocCardList';

<DocCardList />
</file>

<file path="intro/install.mdx">
---
title: Installing Helm
description: Learn how to install and get running with Helm.
sidebar_position: 2
---

This guide shows how to install the Helm CLI. Helm can be installed either from
source, or from pre-built binary releases.

## From The Helm Project

The Helm project provides two ways to fetch and install Helm. These are the
official methods to get Helm releases. In addition to that, the Helm community
provides methods to install Helm through different package managers.
Installation through those methods can be found below the official methods.

### From the Binary Releases

Every [release](https://github.com/helm/helm/releases) of Helm provides binary
releases for a variety of OSes. These binary versions can be manually downloaded
and installed.

1. Download your [desired version](https://github.com/helm/helm/releases)
2. Unpack it (`tar -zxvf helm-v4.0.0-linux-amd64.tar.gz`)
3. Find the `helm` binary in the unpacked directory, and move it to its desired
   destination (`mv linux-amd64/helm /usr/local/bin/helm`)

From there, you should be able to run the client and [add the stable
chart repository](/intro/quickstart.md#initialize-a-helm-chart-repository):
`helm help`.

**Note:** Helm automated tests are performed for Linux AMD64 only during
GitHub Actions builds and releases. Testing of other OSes are the responsibility of
the community requesting Helm for the OS in question.

### From Script

Helm now has an installer script that will automatically grab the latest version
of Helm and [install it
locally](https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-4).

You can fetch that script, and then execute it locally. It's well documented so
that you can read through it and understand what it is doing before you run it.

```console
$ curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-4
$ chmod 700 get_helm.sh
$ ./get_helm.sh
```

Yes, you can `curl
https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-4 | bash` if
you want to live on the edge.

## Through Package Managers

The Helm community provides the ability to install Helm through operating system
package managers. These are not supported by the Helm project and are not
considered trusted 3rd parties.

### From Homebrew (macOS)

Members of the Helm community have contributed a Helm formula build to Homebrew.
This formula is generally up to date.

```console
brew install helm
```

(Note: There is also a formula for emacs-helm, which is a different project.)

### From Chocolatey (Windows)

Members of the Helm community have contributed a [Helm
package](https://chocolatey.org/packages/kubernetes-helm) build to
[Chocolatey](https://chocolatey.org/). This package is generally up to date.

```console
choco install kubernetes-helm
```

### From Scoop (Windows)

Members of the Helm community have contributed a [Helm
package](https://github.com/ScoopInstaller/Main/blob/master/bucket/helm.json) build to [Scoop](https://scoop.sh). This package is generally up to date.

```console
scoop install helm
```

### From Winget (Windows)

Members of the Helm community have contributed a [Helm
package](https://github.com/microsoft/winget-pkgs/tree/master/manifests/h/Helm/Helm) build to [Winget](https://learn.microsoft.com/en-us/windows/package-manager/). This package is generally up to date.

```console
winget install Helm.Helm
```

### From Apt (Debian/Ubuntu)

Members of the Helm community have contributed an Apt package for Debian/Ubuntu. This package is
generally up to date. Thanks to [Buildkite](https://buildkite.com/organizations/helm-linux/packages/registries/helm-debian) for hosting the repo.

```console
sudo apt-get install curl gpg apt-transport-https --yes
curl -fsSL https://packages.buildkite.com/helm-linux/helm-debian/gpgkey | gpg --dearmor | sudo tee /usr/share/keyrings/helm.gpg > /dev/null
echo "deb [signed-by=/usr/share/keyrings/helm.gpg] https://packages.buildkite.com/helm-linux/helm-debian/any/ any main" | sudo tee /etc/apt/sources.list.d/helm-stable-debian.list
sudo apt-get update
sudo apt-get install helm
```

### From dnf/yum (fedora)
Since Fedora 35, Helm is available on the official repository.
You can install Helm by invoking:

```console
sudo dnf install helm
```

### From Snap

The [Snapcrafters](https://github.com/snapcrafters) community maintains the Snap
version of the [Helm package](https://snapcraft.io/helm):

```console
sudo snap install helm --classic
```

### From pkg (FreeBSD)

Members of the FreeBSD community have contributed a [Helm
package](https://www.freshports.org/sysutils/helm) build to the
[FreeBSD Ports Collection](https://man.freebsd.org/ports).
This package is generally up to date.

```console
pkg install helm
```

### Development Builds

In addition to releases you can download or install development snapshots of
Helm.

### From Canary Builds

"Canary" builds are versions of the Helm software that are built from the latest
`main` branch. They are not official releases, and may not be stable. However,
they offer the opportunity to test the cutting edge features.

Canary Helm binaries are stored at [get.helm.sh](https://get.helm.sh). Here are
links to the common builds:

- [Linux AMD64](https://get.helm.sh/helm-canary-linux-amd64.tar.gz)
- [macOS AMD64](https://get.helm.sh/helm-canary-darwin-amd64.tar.gz)
- [Experimental Windows
  AMD64](https://get.helm.sh/helm-canary-windows-amd64.zip)

### From Source (Linux, macOS)

Building Helm from source is slightly more work, but is the best way to go if
you want to test the latest Helm version.

You must have a working Go environment.

```console
$ git clone https://github.com/helm/helm.git
$ cd helm
$ make
```

If required, it will fetch the dependencies and cache them, and validate
configuration. It will then compile `helm` and place it in `bin/helm`.

## Conclusion

In most cases, installation is as simple as getting a pre-built `helm` binary.
This document covers additional cases for those who want to do more
sophisticated things with Helm.

Once you have the Helm Client successfully installed, you can move on to using
Helm to manage charts and [add the stable
chart repository](/intro/quickstart.md#initialize-a-helm-chart-repository).
</file>

<file path="intro/quickstart.md">
---
title: Quickstart Guide
description: How to install and get started with Helm including instructions for distros, FAQs, and plugins.
sidebar_position: 1
---

This guide covers how you can quickly get started using Helm.

## Prerequisites

The following prerequisites are required for a successful and properly secured
use of Helm.

1. A Kubernetes cluster
2. Deciding what security configurations to apply to your installation, if any
3. Installing and configuring Helm.

### Install Kubernetes or have access to a cluster

- You must have Kubernetes installed. For the latest release of Helm, we
  recommend the latest stable release of Kubernetes, which in most cases is the
  second-latest minor release.
- You should also have a local configured copy of `kubectl`.

See the [Helm Version Support Policy](https://helm.sh/docs/topics/version_skew/) for the maximum version skew supported between Helm and Kubernetes.

## Install Helm

Download a binary release of the Helm client. You can use tools like `homebrew`,
or look at [the official releases page](https://github.com/helm/helm/releases).

For more details, or for other options, see [the installation guide](/intro/install.mdx).

## Initialize a Helm Chart Repository

Once you have Helm ready, you can add a chart repository. Check [Artifact
Hub](https://artifacthub.io/packages/search?kind=0) for available Helm chart
repositories.

```console
$ helm repo add bitnami https://charts.bitnami.com/bitnami
```

Once this is installed, you will be able to list the charts you can install:

```console
$ helm search repo bitnami
NAME                             	CHART VERSION	APP VERSION  	DESCRIPTION
bitnami/bitnami-common           	0.0.9        	0.0.9        	DEPRECATED Chart with custom templates used in ...
bitnami/airflow                  	8.0.2        	2.0.0        	Apache Airflow is a platform to programmaticall...
bitnami/apache                   	8.2.3        	2.4.46       	Chart for Apache HTTP Server
bitnami/aspnet-core              	1.2.3        	3.1.9        	ASP.NET Core is an open-source framework create...
# ... and many more
```

## Install an Example Chart

To install a chart, you can run the `helm install` command. Helm has several
ways to find and install a chart, but the easiest is to use the `bitnami`
charts.

```console
$ helm repo update              # Make sure we get the latest list of charts
$ helm install bitnami/mysql --generate-name
NAME: mysql-1612624192
LAST DEPLOYED: Sat Feb  6 16:09:56 2021
NAMESPACE: default
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES: ...
```

In the example above, the `bitnami/mysql` chart was released, and the name of
our new release is `mysql-1612624192`.

You get a simple idea of the features of this MySQL chart by running `helm show
chart bitnami/mysql`. Or you could run `helm show all bitnami/mysql` to get all
information about the chart.

Whenever you install a chart, a new release is created. So one chart can be
installed multiple times into the same cluster. And each can be independently
managed and upgraded.

The `helm install` command is a very powerful command with many capabilities. To
learn more about it, check out the [Using Helm Guide](/intro/using_helm.mdx)

## Learn About Releases

It's easy to see what has been released using Helm:

```console
$ helm list
NAME            	NAMESPACE	REVISION	UPDATED                             	STATUS  	CHART      	APP VERSION
mysql-1612624192	default  	1       	2021-02-06 16:09:56.283059 +0100 CET	deployed	mysql-8.3.0	8.0.23
```

The `helm list` (or `helm ls`) function will show you a list of all deployed releases.

## Uninstall a Release

To uninstall a release, use the `helm uninstall` command:

```console
$ helm uninstall mysql-1612624192
release "mysql-1612624192" uninstalled
```

This will uninstall `mysql-1612624192` from Kubernetes, which will remove all
resources associated with the release as well as the release history.

If the flag `--keep-history` is provided, release history will be kept. You will
be able to request information about that release:

```console
$ helm status mysql-1612624192
Status: UNINSTALLED
...
```

Because Helm tracks your releases even after you've uninstalled them, you can
audit a cluster's history, and even undelete a release (with `helm rollback`).

## Reading the Help Text

To learn more about the available Helm commands, use `helm help` or type a
command followed by the `-h` flag:

```console
$ helm get -h
```
</file>

<file path="intro/using_helm.mdx">
---
title: Using Helm
description: Explains the basics of Helm.
sidebar_position: 3
---

import Helm4 from "/docs/_v4-in-progress.mdx"

<Helm4/>

This guide explains the basics of using Helm to manage packages on your
Kubernetes cluster. It assumes that you have already [installed](/intro/install.mdx) the Helm client.

If you are simply interested in running a few quick commands, you may wish to
begin with the [Quickstart Guide](/intro/quickstart.md). This chapter
covers the particulars of Helm commands, and explains how to use Helm.

## Three Big Concepts

A *Chart* is a Helm package. It contains all of the resource definitions
necessary to run an application, tool, or service inside of a Kubernetes
cluster. Think of it like the Kubernetes equivalent of a Homebrew formula, an
Apt dpkg, or a Yum RPM file.

A *Repository* is the place where charts can be collected and shared. It's like
Perl's [CPAN archive](https://www.cpan.org) or the [Fedora Package
Database](https://src.fedoraproject.org/), but for Kubernetes packages.

A *Release* is an instance of a chart running in a Kubernetes cluster. One chart
can often be installed many times into the same cluster. And each time it is
installed, a new _release_ is created. Consider a MySQL chart. If you want two
databases running in your cluster, you can install that chart twice. Each one
will have its own _release_, which will in turn have its own _release name_.

With these concepts in mind, we can now explain Helm like this:

Helm installs _charts_ into Kubernetes, creating a new _release_ for each
installation. And to find new charts, you can search Helm chart _repositories_.

## 'helm search': Finding Charts

Helm comes with a powerful search command. It can be used to search two
different types of source:

- `helm search hub` searches [the Artifact Hub](https://artifacthub.io), which
  lists helm charts from dozens of different repositories.
- `helm search repo` searches the repositories that you have added to your local
  helm client (with `helm repo add`). This search is done over local data, and
  no public network connection is needed.

You can find publicly available charts by running `helm search hub`:

```console
$ helm search hub wordpress
URL                                                 CHART VERSION APP VERSION DESCRIPTION
https://hub.helm.sh/charts/bitnami/wordpress        7.6.7         5.2.4       Web publishing platform for building blogs and ...
https://hub.helm.sh/charts/presslabs/wordpress-...  v0.6.3        v0.6.3      Presslabs WordPress Operator Helm Chart
https://hub.helm.sh/charts/presslabs/wordpress-...  v0.7.1        v0.7.1      A Helm chart for deploying a WordPress site on ...
```

The above searches for all `wordpress` charts on Artifact Hub.

With no filter, `helm search hub` shows you all of the available charts.

`helm search hub` exposes the URL to the location on [artifacthub.io](https://artifacthub.io/) but not the actual Helm repo. `helm search hub --list-repo-url` exposes the actual Helm repo URL which comes in handy when you are looking to add a new repo: `helm repo
add [NAME] [URL]`.

Using `helm search repo`, you can find the names of the charts in repositories
you have already added:

```console
$ helm repo add brigade https://brigadecore.github.io/charts
"brigade" has been added to your repositories
$ helm search repo brigade
NAME                          CHART VERSION APP VERSION DESCRIPTION
brigade/brigade               1.3.2         v1.2.1      Brigade provides event-driven scripting of Kube...
brigade/brigade-github-app    0.4.1         v0.2.1      The Brigade GitHub App, an advanced gateway for...
brigade/brigade-github-oauth  0.2.0         v0.20.0     The legacy OAuth GitHub Gateway for Brigade
brigade/brigade-k8s-gateway   0.1.0                     A Helm chart for Kubernetes
brigade/brigade-project       1.0.0         v1.0.0      Create a Brigade project
brigade/kashti                0.4.0         v0.4.0      A Helm chart for Kubernetes
```

Helm search uses a fuzzy string matching algorithm, so you can type parts of
words or phrases:

```console
$ helm search repo kash
NAME            CHART VERSION APP VERSION DESCRIPTION
brigade/kashti  0.4.0         v0.4.0      A Helm chart for Kubernetes
```

Search is a good way to find available packages. Once you have found a package
you want to install, you can use `helm install` to install it.

## 'helm install': Installing a Package

To install a new package, use the `helm install` command. At its simplest, it
takes two arguments: A release name that you pick, and the name of the chart you
want to install.

```console
$ helm install happy-panda bitnami/wordpress
NAME: happy-panda
LAST DEPLOYED: Tue Jan 26 10:27:17 2021
NAMESPACE: default
STATUS: deployed
REVISION: 1
NOTES:
** Please be patient while the chart is being deployed **

Your WordPress site can be accessed through the following DNS name from within your cluster:

    happy-panda-wordpress.default.svc.cluster.local (port 80)

To access your WordPress site from outside the cluster follow the steps below:

1. Get the WordPress URL by running these commands:

  NOTE: It may take a few minutes for the LoadBalancer IP to be available.
        Watch the status with: 'kubectl get svc --namespace default -w happy-panda-wordpress'

   export SERVICE_IP=$(kubectl get svc --namespace default happy-panda-wordpress --template "{{ range (index .status.loadBalancer.ingress 0) }}{{.}}{{ end }}")
   echo "WordPress URL: http://$SERVICE_IP/"
   echo "WordPress Admin URL: http://$SERVICE_IP/admin"

2. Open a browser and access WordPress using the obtained URL.

3. Login with the following credentials below to see your blog:

  echo Username: user
  echo Password: $(kubectl get secret --namespace default happy-panda-wordpress -o jsonpath="{.data.wordpress-password}" | base64 --decode)
```

Now the `wordpress` chart is installed. Note that installing a chart creates a
new _release_ object. The release above is named `happy-panda`. (If you want
Helm to generate a name for you, leave off the release name and use
`--generate-name`.)

During installation, the `helm` client will print useful information about which
resources were created, what the state of the release is, and also whether there
are additional configuration steps you can or should take.

Helm installs resources in the following order:

- Namespace
- NetworkPolicy
- ResourceQuota
- LimitRange
- PodSecurityPolicy
- PodDisruptionBudget
- ServiceAccount
- Secret
- SecretList
- ConfigMap
- StorageClass
- PersistentVolume
- PersistentVolumeClaim
- CustomResourceDefinition
- ClusterRole
- ClusterRoleList
- ClusterRoleBinding
- ClusterRoleBindingList
- Role
- RoleList
- RoleBinding
- RoleBindingList
- Service
- DaemonSet
- Pod
- ReplicationController
- ReplicaSet
- Deployment
- HorizontalPodAutoscaler
- StatefulSet
- Job
- CronJob
- Ingress
- APIService
- MutatingWebhookConfiguration
- ValidatingWebhookConfiguration

Helm does not wait until all of the resources are running before it exits. Many
charts require Docker images that are over 600MB in size, and may take a long
time to install into the cluster.

To keep track of a release's state, or to re-read configuration information, you
can use `helm status`:

```console
$ helm status happy-panda
NAME: happy-panda
LAST DEPLOYED: Tue Jan 26 10:27:17 2021
NAMESPACE: default
STATUS: deployed
REVISION: 1
NOTES:
** Please be patient while the chart is being deployed **

Your WordPress site can be accessed through the following DNS name from within your cluster:

    happy-panda-wordpress.default.svc.cluster.local (port 80)

To access your WordPress site from outside the cluster follow the steps below:

1. Get the WordPress URL by running these commands:

  NOTE: It may take a few minutes for the LoadBalancer IP to be available.
        Watch the status with: 'kubectl get svc --namespace default -w happy-panda-wordpress'

   export SERVICE_IP=$(kubectl get svc --namespace default happy-panda-wordpress --template "{{ range (index .status.loadBalancer.ingress 0) }}{{.}}{{ end }}")
   echo "WordPress URL: http://$SERVICE_IP/"
   echo "WordPress Admin URL: http://$SERVICE_IP/admin"

2. Open a browser and access WordPress using the obtained URL.

3. Login with the following credentials below to see your blog:

  echo Username: user
  echo Password: $(kubectl get secret --namespace default happy-panda-wordpress -o jsonpath="{.data.wordpress-password}" | base64 --decode)
```

The above shows the current state of your release.

### Customizing the Chart Before Installing

Installing the way we have here will only use the default configuration options
for this chart. Many times, you will want to customize the chart to use your
preferred configuration.

To see what options are configurable on a chart, use `helm show values`:

```console
$ helm show values bitnami/wordpress
## Global Docker image parameters
## Please, note that this will override the image parameters, including dependencies, configured to use the global value
## Current available global Docker image parameters: imageRegistry and imagePullSecrets
##
# global:
#   imageRegistry: myRegistryName
#   imagePullSecrets:
#     - myRegistryKeySecretName
#   storageClass: myStorageClass

## Bitnami WordPress image version
## ref: https://hub.docker.com/r/bitnami/wordpress/tags/
##
image:
  registry: docker.io
  repository: bitnami/wordpress
  tag: 5.6.0-debian-10-r35
  [..]
```

You can then override any of these settings in a YAML formatted file, and then
pass that file during installation.

```console
$ echo '{mariadb.auth.database: user0db, mariadb.auth.username: user0}' > values.yaml
$ helm install -f values.yaml bitnami/wordpress --generate-name
```

The above will create a default MariaDB user with the name `user0`, and grant
this user access to a newly created `user0db` database, but will accept all the
rest of the defaults for that chart.

There are two ways to pass configuration data during install:

- `--values` (or `-f`): Specify a YAML file with overrides. This can be
  specified multiple times and the rightmost file will take precedence
- `--set`: Specify overrides on the command line.

If both are used, `--set` values are merged into `--values` with higher
precedence. Overrides specified with `--set` are persisted in a Secret.
Values that have been `--set` can be viewed for a given release with `helm get
values <release-name>`. Values that have been `--set` can be cleared by running
`helm upgrade` with `--reset-values` specified.

#### The Format and Limitations of `--set`

The `--set` option takes zero or more name/value pairs. At its simplest, it is
used like this: `--set name=value`. The YAML equivalent of that is:

```yaml
name: value
```

Multiple values are separated by `,` characters. So `--set a=b,c=d` becomes:

```yaml
a: b
c: d
```

More complex expressions are supported. For example, `--set outer.inner=value`
is translated into this:
```yaml
outer:
  inner: value
```

Lists can be expressed by enclosing values in `{` and `}`. For example, `--set
name={a, b, c}` translates to:

```yaml
name:
  - a
  - b
  - c
```

Certain name/key can be set to be `null` or to be an empty array `[]`. For example, `--set name=[],a=null` translates

```yaml
name:
  - a
  - b
  - c
a: b
```

to

```yaml
name: []
a: null
```

As of Helm 2.5.0, it is possible to access list items using an array index
syntax. For example, `--set servers[0].port=80` becomes:

```yaml
servers:
  - port: 80
```

Multiple values can be set this way. The line `--set
servers[0].port=80,servers[0].host=example` becomes:

```yaml
servers:
  - port: 80
    host: example
```

Sometimes you need to use special characters in your `--set` lines. You can use
a backslash to escape the characters; `--set name=value1\,value2` will become:

```yaml
name: "value1,value2"
```

Similarly, you can escape dot sequences as well, which may come in handy when
charts use the `toYaml` function to parse annotations, labels and node
selectors. The syntax for `--set nodeSelector."kubernetes\.io/role"=master`
becomes:

```yaml
nodeSelector:
  kubernetes.io/role: master
```

Deeply nested data structures can be difficult to express using `--set`. Chart
designers are encouraged to consider the `--set` usage when designing the format
of a `values.yaml` file  (read more about [Values Files](/chart_template_guide/values_files.mdx)).

### More Installation Methods

The `helm install` command can install from several sources:

- A chart repository (as we've seen above)
- A local chart archive (`helm install foo foo-0.1.1.tgz`)
- An unpacked chart directory (`helm install foo path/to/foo`)
- A full URL (`helm install foo https://example.com/charts/foo-1.2.3.tgz`)

## 'helm upgrade' and 'helm rollback': Upgrading a Release, and Recovering on Failure

When a new version of a chart is released, or when you want to change the
configuration of your release, you can use the `helm upgrade` command.

An upgrade takes an existing release and upgrades it according to the
information you provide. Because Kubernetes charts can be large and complex,
Helm tries to perform the least invasive upgrade. It will only update things
that have changed since the last release.

```console
$ helm upgrade -f panda.yaml happy-panda bitnami/wordpress
```

In the above case, the `happy-panda` release is upgraded with the same chart,
but with a new YAML file:

```yaml
mariadb.auth.username: user1
```

We can use `helm get values` to see whether that new setting took effect.

```console
$ helm get values happy-panda
mariadb:
  auth:
    username: user1
```

The `helm get` command is a useful tool for looking at a release in the cluster.
And as we can see above, it shows that our new values from `panda.yaml` were
deployed to the cluster.

Now, if something does not go as planned during a release, it is easy to roll
back to a previous release using `helm rollback [RELEASE] [REVISION]`.

```console
$ helm rollback happy-panda 1
```

The above rolls back our happy-panda to its very first release version. A
release version is an incremental revision. Every time an install, upgrade, or
rollback happens, the revision number is incremented by 1. The first revision
number is always 1. And we can use `helm history [RELEASE]` to see revision
numbers for a certain release.

## Helpful Options for Install/Upgrade/Rollback

There are several other helpful options you can specify for customizing the
behavior of Helm during an install/upgrade/rollback. Please note that this is
not a full list of cli flags. To see a description of all flags, just run `helm
<command> --help`.

- `--timeout`: A [Go duration](https://golang.org/pkg/time/#ParseDuration) value
  to wait for Kubernetes commands to complete. This defaults to `5m0s`.
- `--wait`: Waits until all Pods are in a ready state, PVCs are bound,
  Deployments have minimum (`Desired` minus `maxUnavailable`) Pods in ready
  state and Services have an IP address (and Ingress if a `LoadBalancer`) before
  marking the release as successful. It will wait for as long as the `--timeout`
  value. If timeout is reached, the release will be marked as `FAILED`. Note: In
  scenarios where Deployment has `replicas` set to 1 and `maxUnavailable` is not
  set to 0 as part of rolling update strategy, `--wait` will return as ready as
  it has satisfied the minimum Pod in ready condition.
- `--no-hooks`: This skips running hooks for the command
- `--recreate-pods` (only available for `upgrade` and `rollback`): This flag
  will cause all pods to be recreated (with the exception of pods belonging to
  deployments). (DEPRECATED in Helm 3)

## 'helm uninstall': Uninstalling a Release

When it is time to uninstall a release from the cluster, use the `helm
uninstall` command:

```console
$ helm uninstall happy-panda
```

This will remove the release from the cluster. You can see all of your currently
deployed releases with the `helm list` command:

```console
$ helm list
NAME            VERSION UPDATED                         STATUS          CHART
inky-cat        1       Wed Sep 28 12:59:46 2016        DEPLOYED        alpine-0.1.0
```

From the output above, we can see that the `happy-panda` release was
uninstalled.

In previous versions of Helm, when a release was deleted, a record of its
deletion would remain. In Helm 3, deletion removes the release record as well.
If you wish to keep a deletion release record, use `helm uninstall
--keep-history`. Using `helm list --uninstalled` will only show releases that
were uninstalled with the `--keep-history` flag.

The `helm list --all` flag will show you all release records that Helm has
retained, including records for failed or deleted items (if `--keep-history` was
specified):

```console
$  helm list --all
NAME            VERSION UPDATED                         STATUS          CHART
happy-panda     2       Wed Sep 28 12:47:54 2016        UNINSTALLED     wordpress-10.4.5.6.0
inky-cat        1       Wed Sep 28 12:59:46 2016        DEPLOYED        alpine-0.1.0
kindred-angelf  2       Tue Sep 27 16:16:10 2016        UNINSTALLED     alpine-0.1.0
```

Note that because releases are now deleted by default, it is no longer possible
to rollback an uninstalled resource.

## 'helm repo': Working with Repositories

Helm 3 no longer ships with a default chart repository. The `helm repo` command
group provides commands to add, list, and remove repositories.

You can see which repositories are configured using `helm repo list`:

```console
$ helm repo list
NAME            URL
stable          https://charts.helm.sh/stable
mumoshu         https://mumoshu.github.io/charts
```

And new repositories can be added with `helm repo
add [NAME] [URL]`:

```console
$ helm repo add dev https://example.com/dev-charts
```

Because chart repositories change frequently, at any point you can make sure
your Helm client is up to date by running `helm repo update`.

Repositories can be removed with `helm repo remove`.

## Creating Your Own Charts

The [Chart Development Guide](/topics/charts.mdx) explains how
to develop your own charts. But you can get started quickly by using the `helm
create` command:

```console
$ helm create deis-workflow
Creating deis-workflow
```

Now there is a chart in `./deis-workflow`. You can edit it and create your own
templates.

As you edit your chart, you can validate that it is well-formed by running `helm
lint`.

When it's time to package the chart up for distribution, you can run the `helm
package` command:

```console
$ helm package deis-workflow
deis-workflow-0.1.0.tgz
```

And that chart can now easily be installed by `helm install`:

```console
$ helm install deis-workflow ./deis-workflow-0.1.0.tgz
...
```

Charts that are packaged can be loaded into chart repositories. See the
documentation for [Helm chart
repositories](/topics/chart_repository.md) for more details.

## Conclusion

This chapter has covered the basic usage patterns of the `helm` client,
including searching, installation, upgrading, and uninstalling. It has also
covered useful utility commands like `helm status`, `helm get`, and `helm repo`.

For more information on these commands, take a look at Helm's built-in help:
`helm help`.

In the [next chapter](/howto/charts_tips_and_tricks.md), we look at the process of developing charts.
</file>

<file path="logos/helm-blue-vector.svg">
<?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 22.1.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 620 645.6" style="enable-background:new 0 0 620 645.6;" xml:space="preserve">
<style type="text/css">
	.st0{fill:#277A9F;}
	.st1{fill:none;stroke:#277A9F;stroke-width:30;}
</style>
<title>logo</title>
<desc>Created with Sketch.</desc>
<g id="Page-1">
	<g id="logo_x40_2x" transform="translate(-152.000000, -162.000000)">
		<g id="logo" transform="translate(149.000000, 162.000000)">
			<g id="helm" transform="translate(22.377622, 0.000000)">
				
					<g id="rungs-bottom" transform="translate(41.500000, 108.500000) scale(1, -1) translate(-41.500000, -108.500000) translate(0.000000, 91.000000)">
					<path id="Oval-1" class="st0" d="M417.2-357.5c10.4,7.3,34.3-8.7,53.2-35.8s25.9-55,15.4-62.3c-10.4-7.3-34.3,8.7-53.2,35.8
						C413.7-392.7,406.8-364.8,417.2-357.5z"/>
					<path id="Oval-1-Copy" class="st0" d="M167.6-357.5c-10.4,7.3-34.3-8.7-53.2-35.8c-19-27.1-25.9-55-15.4-62.3
						s34.3,8.7,53.2,35.8S178.1-364.8,167.6-357.5z"/>
					<path id="Oval-1-Copy-4" class="st0" d="M292.3-399.9c-12.7,0-23.1-26.8-23.1-59.9s10.3-59.9,23.1-59.9s23.1,26.8,23.1,59.9
						S305-399.9,292.3-399.9z"/>
				</g>
				<g id="rungs-top">
					<path id="Oval-1_1_" class="st0" d="M417.2,162.5c10.4,7.3,34.3-8.7,53.2-35.8s25.9-55,15.4-62.3c-10.4-7.3-34.3,8.7-53.2,35.8
						S406.8,155.2,417.2,162.5z"/>
					<path id="Oval-1-Copy_1_" class="st0" d="M167.6,162.5c-10.4,7.3-34.3-8.7-53.2-35.8S88.5,71.8,99,64.4s34.3,8.7,53.2,35.8
						S178.1,155.2,167.6,162.5z"/>
					<path id="Oval-1-Copy-4_1_" class="st0" d="M292.3,120.1c-12.7,0-23.1-26.8-23.1-59.9s10.3-59.9,23.1-59.9s23.1,26.8,23.1,59.9
						S305,120.1,292.3,120.1z"/>
				</g>
				<path id="Oval-1_2_" class="st1" d="M470.2,215.6C433,154.4,365.6,113.5,288.7,113.5c-74.9,0-140.7,38.7-178.4,97.2 M114.3,446
					c38.3,55.1,102.1,91.1,174.4,91.1c72.4,0,136.3-36.2,174.6-91.4"/>
			</g>
			<path id="HELM" class="st0" d="M3.6,244.1H48v62.5h50.1v-62.5h44.4V412H98.1v-66.6H48V412H3.6V244.1z M179.8,244.1h108.5v37.2
				h-64.1v26.3H279v37.2h-54.8v30h66.6V412H179.8V244.1z M323.4,244.1h44.4v130.7h63.5V412h-108V244.1z M460.3,244.1h46l26.3,69.7
				l9.3,27.4h1l9.3-27.4l25.3-69.7h46V412h-41.3v-49.6c0-4.3,0.2-9,0.6-14.2c0.4-5.2,0.9-10.5,1.4-15.9c0.5-5.4,1.1-10.7,1.8-15.9
				c0.7-5.2,1.3-9.8,1.8-13.9h-1l-13.9,39.3l-23.2,56.6h-16.5l-23.2-56.6l-13.4-39.3h-1c0.5,4.1,1.1,8.8,1.8,13.9
				c0.7,5.2,1.3,10.5,1.8,15.9c0.5,5.4,1,10.7,1.4,15.9c0.4,5.2,0.6,9.9,0.6,14.2V412h-40.8V244.1z"/>
		</g>
	</g>
</g>
</svg>
</file>

<file path="logos/helm-white-vector.svg">
<?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 22.1.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 620 647.6" style="enable-background:new 0 0 620 647.6;" xml:space="preserve">
<style type="text/css">
	.st0{fill:#FFFFFF;}
	.st1{fill:none;stroke:#FFFFFF;stroke-width:32;}
</style>
<title>logo white</title>
<desc>Created with Sketch.</desc>
<g id="Page-1">
	<g id="logo_x40_2x" transform="translate(-608.000000, -155.000000)">
		<g id="logo-white" transform="translate(604.000000, 155.000000)">
			<g id="helm" transform="translate(25.000000, 0.000000)">
				
					<g id="rungs-bottom" transform="translate(46.500000, 121.500000) scale(1, -1) translate(-46.500000, -121.500000) translate(0.000000, 102.000000)">
					<path id="Oval-1" class="st0" d="M414.2-342.3c10.4,7.3,34.1-8.7,52.9-35.7c18.9-27,25.8-54.7,15.4-61.9
						c-10.4-7.3-34.1,8.7-52.9,35.7S403.8-349.5,414.2-342.3z"/>
					<path id="Oval-1-Copy" class="st0" d="M166.3-342.3c-10.4,7.3-34.1-8.7-52.9-35.7S87.6-432.6,98-439.9
						c10.4-7.3,34.1,8.7,52.9,35.7C169.8-377.3,176.7-349.5,166.3-342.3z"/>
					<path id="Oval-1-Copy-4" class="st0" d="M290.1-384.5c-12.7,0-22.9-26.7-22.9-59.6s10.3-59.6,22.9-59.6
						c12.7,0,22.9,26.7,22.9,59.6S302.8-384.5,290.1-384.5z"/>
				</g>
				<g id="rungs-top">
					<path id="Oval-1_1_" class="st0" d="M414.2,163.8c10.4,7.3,34.1-8.7,52.9-35.7s25.8-54.7,15.4-61.9
						c-10.4-7.3-34.1,8.7-52.9,35.7S403.8,156.5,414.2,163.8z"/>
					<path id="Oval-1-Copy_1_" class="st0" d="M166.3,163.8c-10.4,7.3-34.1-8.7-52.9-35.7S87.6,73.5,98,66.2s34.1,8.7,52.9,35.7
						S176.7,156.5,166.3,163.8z"/>
					<path id="Oval-1-Copy-4_1_" class="st0" d="M290.1,121.6c-12.7,0-22.9-26.7-22.9-59.6s10.3-59.6,22.9-59.6
						C302.8,2.4,313,29.1,313,62S302.8,121.6,290.1,121.6z"/>
				</g>
				<path id="Oval-1_2_" class="st1" d="M466.9,216.7C430,155.7,363,115,286.5,115c-74.4,0-139.8,38.5-177.3,96.7 M113.2,445.9
					c38.1,54.8,101.5,90.7,173.3,90.7c71.9,0,135.4-36,173.5-91"/>
			</g>
			<path id="HELM" class="st0" d="M6,246.1h44.1v62.1H100v-62.1h44.1v166.8H100v-66.2H50.2v66.2H6V246.1z M181.1,246.1h107.8v37
				h-63.7v26.2h54.4v37h-54.4v29.8h66.2v37H181.1V246.1z M323.8,246.1h44.1v129.9H431v37H323.8V246.1z M459.8,246.1h45.7l26.2,69.3
				l9.2,27.2h1l9.2-27.2l25.2-69.3H622v166.8h-41.1v-49.3c0-4.3,0.2-9,0.6-14.1c0.4-5.1,0.9-10.4,1.4-15.8
				c0.5-5.4,1.1-10.7,1.8-15.8c0.7-5.1,1.3-9.8,1.8-13.9h-1l-13.9,39l-23.1,56.2h-16.4l-23.1-56.2l-13.3-39h-1
				c0.5,4.1,1.1,8.7,1.8,13.9c0.7,5.1,1.3,10.4,1.8,15.8c0.5,5.4,1,10.7,1.4,15.8c0.4,5.1,0.6,9.8,0.6,14.1v49.3h-40.6V246.1z"/>
		</g>
	</g>
</g>
</svg>
</file>

<file path="logos/helm.svg">
<?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 22.1.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 2834.6 2834.6" style="enable-background:new 0 0 2834.6 2834.6;" xml:space="preserve">
<style type="text/css">
	.st0{clip-path:url(#SVGID_3_);}
	.st1{clip-path:url(#SVGID_4_);fill:#257A9F;}
	.st2{clip-path:url(#SVGID_7_);}
	.st3{clip-path:url(#SVGID_8_);fill:#257A9F;}
	.st4{clip-path:url(#SVGID_11_);}
	.st5{clip-path:url(#SVGID_12_);fill:#257A9F;}
	.st6{clip-path:url(#SVGID_15_);}
	.st7{clip-path:url(#SVGID_16_);fill:#257A9F;}
	.st8{clip-path:url(#SVGID_19_);}
	.st9{clip-path:url(#SVGID_20_);fill:#257A9F;}
	.st10{clip-path:url(#SVGID_23_);}
	.st11{clip-path:url(#SVGID_24_);fill:#257A9F;}
	.st12{clip-path:url(#SVGID_26_);fill:none;stroke:#257A9F;stroke-width:7.1608;stroke-miterlimit:10;}
	.st13{clip-path:url(#SVGID_29_);}
	.st14{clip-path:url(#SVGID_30_);fill:#257A9F;}
</style>
<g>
	<g>
		<defs>
			<rect id="SVGID_1_" x="1355.8" y="1354" width="121" height="126"/>
		</defs>
		<defs>
			<path id="SVGID_2_" d="M1441.1,1448.1c2-1.4,6.6,1.7,10.3,6.9c3.7,5.3,5,10.7,3,12.1s-6.6-1.7-10.3-6.9
				C1440.4,1455,1439,1449.5,1441.1,1448.1L1441.1,1448.1z"/>
		</defs>
		<clipPath id="SVGID_3_">
			<use xlink:href="#SVGID_1_"  style="overflow:visible;"/>
		</clipPath>
		<clipPath id="SVGID_4_" class="st0">
			<use xlink:href="#SVGID_2_"  style="overflow:visible;"/>
		</clipPath>
		
			<rect x="1438.3" y="1441" transform="matrix(0.8192 -0.5736 0.5736 0.8192 -574.2485 1093.9949)" class="st1" width="19" height="33.2"/>
	</g>
	<g>
		<defs>
			<rect id="SVGID_5_" x="1355.8" y="1354" width="121" height="126"/>
		</defs>
		<defs>
			<path id="SVGID_6_" d="M1392.6,1448.1c-2-1.4-6.6,1.7-10.3,6.9s-5,10.7-3,12.1c2,1.4,6.6-1.7,10.3-6.9
				S1394.7,1449.5,1392.6,1448.1L1392.6,1448.1z"/>
		</defs>
		<clipPath id="SVGID_7_">
			<use xlink:href="#SVGID_5_"  style="overflow:visible;"/>
		</clipPath>
		<clipPath id="SVGID_8_" class="st2">
			<use xlink:href="#SVGID_6_"  style="overflow:visible;"/>
		</clipPath>
		
			<rect x="1369.4" y="1448.2" transform="matrix(0.5736 -0.8192 0.8192 0.5736 -603.0187 1756.8911)" class="st3" width="33.2" height="19"/>
	</g>
	<g>
		<defs>
			<rect id="SVGID_9_" x="1355.8" y="1354" width="121" height="126"/>
		</defs>
		<defs>
			<path id="SVGID_10_" d="M1416.8,1456.4c-2.5,0-4.5,5.2-4.5,11.6s2,11.6,4.5,11.6c2.5,0,4.5-5.2,4.5-11.6
				S1419.3,1456.4,1416.8,1456.4L1416.8,1456.4z"/>
		</defs>
		<clipPath id="SVGID_11_">
			<use xlink:href="#SVGID_9_"  style="overflow:visible;"/>
		</clipPath>
		<clipPath id="SVGID_12_" class="st4">
			<use xlink:href="#SVGID_10_"  style="overflow:visible;"/>
		</clipPath>
		<rect x="1407.3" y="1451.4" class="st5" width="19" height="33.2"/>
	</g>
	<g>
		<defs>
			<rect id="SVGID_13_" x="1355.8" y="1354" width="121" height="126"/>
		</defs>
		<defs>
			<path id="SVGID_14_" d="M1441.1,1385.8c2,1.4,6.6-1.7,10.3-6.9c3.7-5.3,5-10.7,3-12.1c-2-1.4-6.6,1.7-10.3,6.9
				C1440.4,1379,1439,1384.4,1441.1,1385.8L1441.1,1385.8z"/>
		</defs>
		<clipPath id="SVGID_15_">
			<use xlink:href="#SVGID_13_"  style="overflow:visible;"/>
		</clipPath>
		<clipPath id="SVGID_16_" class="st6">
			<use xlink:href="#SVGID_14_"  style="overflow:visible;"/>
		</clipPath>
		
			<rect x="1431.1" y="1366.8" transform="matrix(0.5736 -0.8192 0.8192 0.5736 -510.0697 1772.8038)" class="st7" width="33.2" height="19"/>
	</g>
	<g>
		<defs>
			<rect id="SVGID_17_" x="1355.8" y="1354" width="121" height="126"/>
		</defs>
		<defs>
			<path id="SVGID_18_" d="M1392.6,1385.8c-2,1.4-6.6-1.7-10.3-6.9s-5-10.7-3-12.1c2-1.4,6.6,1.7,10.3,6.9
				S1394.7,1384.4,1392.6,1385.8L1392.6,1385.8z"/>
		</defs>
		<clipPath id="SVGID_19_">
			<use xlink:href="#SVGID_17_"  style="overflow:visible;"/>
		</clipPath>
		<clipPath id="SVGID_20_" class="st8">
			<use xlink:href="#SVGID_18_"  style="overflow:visible;"/>
		</clipPath>
		
			<rect x="1376.5" y="1359.7" transform="matrix(0.8192 -0.5736 0.5736 0.8192 -538.7756 1043.8647)" class="st9" width="19" height="33.2"/>
	</g>
	<g>
		<defs>
			<rect id="SVGID_21_" x="1355.8" y="1354" width="121" height="126"/>
		</defs>
		<defs>
			<path id="SVGID_22_" d="M1416.8,1377.6c-2.5,0-4.5-5.2-4.5-11.6s2-11.6,4.5-11.6c2.5,0,4.5,5.2,4.5,11.6
				S1419.3,1377.6,1416.8,1377.6L1416.8,1377.6z"/>
		</defs>
		<clipPath id="SVGID_23_">
			<use xlink:href="#SVGID_21_"  style="overflow:visible;"/>
		</clipPath>
		<clipPath id="SVGID_24_" class="st10">
			<use xlink:href="#SVGID_22_"  style="overflow:visible;"/>
		</clipPath>
		<rect x="1407.3" y="1349.4" class="st11" width="19" height="33.2"/>
	</g>
	<g>
		<defs>
			<rect id="SVGID_25_" x="1355.8" y="1354" width="121" height="126"/>
		</defs>
		<clipPath id="SVGID_26_">
			<use xlink:href="#SVGID_25_"  style="overflow:visible;"/>
		</clipPath>
		<path class="st12" d="M1451.4,1396.1c-7.2-11.9-20.3-19.8-35.2-19.8c-14.5,0-27.3,7.5-34.6,18.9"/>
		<path class="st12" d="M1382.3,1440.8c7.4,10.7,19.8,17.7,33.8,17.7c14,0,26.5-7,33.9-17.7"/>
	</g>
	<g>
		<defs>
			<rect id="SVGID_27_" x="1355.8" y="1354" width="121" height="126"/>
		</defs>
		<defs>
			<path id="SVGID_28_" d="M1356.5,1401.7h8.6v12.1h9.7v-12.1h8.6v32.6h-8.6v-12.9h-9.7v12.9h-8.6V1401.7L1356.5,1401.7z
				 M1390.6,1401.7h21.1v7.2h-12.4v5.1h10.6v7.2h-10.6v5.8h12.9v7.2h-21.6V1401.7L1390.6,1401.7z M1418.5,1401.7h8.6v25.4h12.3v7.2
				h-21V1401.7L1418.5,1401.7z M1445.1,1401.7h8.9l5.1,13.5l1.8,5.3h0.2l1.8-5.3l4.9-13.5h8.9v32.6h-8v-9.6c0-0.8,0-1.8,0.1-2.8
				c0.1-1,0.2-2,0.3-3.1c0.1-1.1,0.2-2.1,0.4-3.1s0.3-1.9,0.4-2.7h-0.2l-2.7,7.6l-4.5,11h-3.2l-4.5-11l-2.6-7.6h-0.2
				c0.1,0.8,0.2,1.7,0.4,2.7s0.3,2,0.4,3.1c0.1,1.1,0.2,2.1,0.3,3.1c0.1,1,0.1,1.9,0.1,2.8v9.6h-7.9V1401.7L1445.1,1401.7z"/>
		</defs>
		<clipPath id="SVGID_29_">
			<use xlink:href="#SVGID_27_"  style="overflow:visible;"/>
		</clipPath>
		<clipPath id="SVGID_30_" class="st13">
			<use xlink:href="#SVGID_28_"  style="overflow:visible;"/>
		</clipPath>
		<rect x="1351.5" y="1396.7" class="st14" width="130.3" height="42.6"/>
	</g>
</g>
</svg>
</file>

<file path="plugins/developer/index.mdx">
---
title: Plugins Developer Guide
sidebar_label: Developing Plugins
sidebar_position: 3
---

import DocCardList from "@theme/DocCardList";

For an overview of Helm Plugin concepts, and how to structure and configure plugins, read the [Plugins Overview](/plugins/overview.md).

This section focuses on developing Helm Plugins â€“Â it is intended to include [Tutorials](#tutorials), how-to guides, reference guides, and additional developer-focused information for writing Helm Plugins.

:::info
For an intro to the Plugin System codebase, there will be a Plugins page in the [Go SDK](/sdk/index.mdx) section of the docs, coming soon!
:::

## Tutorials

<DocCardList />
</file>

<file path="plugins/developer/tutorial-cli-plugin.mdx">
---
title: "Tutorial: Build a CLI Plugin"
sidebar_label: Build a CLI Plugin
---

import GetVersion from "@site/src/components/GetVersion";
import CodeBlock from "@theme/CodeBlock";

Build a `helm system-info` command that displays system information.

## Subprocess Runtime

Let's start by building a CLI Plugin with the Subprocess runtime.

### Prerequisites

1. Install the latest Helm 4 release: **<GetVersion majorVersion="4" label={false} link={true} />**
2. In your terminal session, alias `helm` to the release you downloaded. `helm version --short` should now show the correct Helm version in this terminal session.

### 1. Create Plugin Directory

You can create this anywhere on your filesystem. For example:

```bash
mkdir -p $HOME/code/helm/plugins/system-info
cd $HOME/code/helm/plugins/system-info
```

### 2. Create plugin manifest

```yaml title="plugin.yaml" showLineNumbers
apiVersion: v1
type: cli/v1
name: "system-info"
version: "0.1.0"
runtime: subprocess
config:
  usage: system-info
  shortHelp: Display system and Helm information
  longHelp: Shows OS info, Helm version, and environment details
runtimeConfig:
  platformCommand:
    - command: ${HELM_PLUGIN_DIR}/system-info.sh
```

### 3. Create Script

```bash title="system-info.sh" showLineNumbers
#!/bin/bash

echo "=== System Information ==="
echo "OS: $(uname -s)"
echo "Architecture: $(uname -m)"

echo ""
echo "=== Helm Information ==="
echo "Plugin Dir: $HELM_PLUGIN_DIR"
echo "Arguments: $*"

echo ""
echo "System info complete!"
```

Make it executable:

```bash
chmod +x system-info.sh
```

### 4. Install in Dev Mode and Test

Installing a plugin from your filesystem installs in local dev mode. This bypasses checking or verifying provenance:

```bash
% helm plugin install $HOME/code/helm/plugins/system-info
Installing plugin from local directory (development mode)
Installed plugin: system-info
```

Local dev mode installation creates a symlink from your source directory to the plugins directory, so you can continue to develop in your preferred location. You can see the symlink by listing the directory location using the internal HELM_PLUGINS env variable:

```bash
% ls -lah $(helm env HELM_PLUGINS)
total 0
drwxr-xr-x@ 3 r6by  staff    96B Nov 10 02:18 .
drwxr-xr-x@ 3 r6by  staff    96B Jan 21  2025 ..
lrwxr-xr-x  1 r6by  staff    41B Nov 10 02:18 system-info -> /Users/r6by/code/helm/plugins/system-info
```

You can see your plugin details in the `helm plugin list` of installed plugins:

```bash
% helm plugin list
NAME       	VERSION	TYPE  	APIVERSION	PROVENANCE	SOURCE
system-info	0.1.0  	cli/v1	v1        	local dev 	unknown
```

You can also now see your plugin in the list of available commands with `helm help`, and see it's own generated help message you defined in your `plugin.yaml`:

```bash
% helm help | grep system-info
  system-info Display system and Helm information

% helm help system-info
Shows OS info, Helm version, and environment details

Usage:
  helm system-info [flags]
```

Let's try running the CLI subcommand:

```bash
% helm system-info
=== System Information ===
OS: Darwin
Architecture: arm64

=== Helm Information ===
Plugin Dir: /Users/r6by/Library/helm/plugins/system-info
Arguments:

System info complete!
```

What you built: A CLI plugin using the Subprocess runtime!

Now let's do it again, this time using Wasm runtimeâ€¦

## Wasm Runtime

### Prerequisites

- Prerequisites from [Subprocess Runtime](#subprocess-runtime)
- Go 1.25 installed

:::warning
To-do: add this section
:::
</file>

<file path="plugins/developer/tutorial-getter-plugin.mdx">
---
title: "Tutorial: Build a Getter Plugin"
sidebar_label: Build a Getter Plugin
---

import GetVersion from "@site/src/components/GetVersion";

Build a `helm system-info` command that displays system information.

## Subprocess Runtime

Let's build a Getter Plugin using the Subprocess runtime.

### Prerequisites

1. Install the latest Helm 4 release: **<GetVersion majorVersion="4" label={false} link={true} />**
2. In your terminal session, alias `helm` to the release you downloaded. `helm version --short` should now show the correct Helm version in this terminal session.

### 1. Create Plugin Directory

You can create this anywhere on your filesystem. For example:

```bash
mkdir -p $HOME/code/helm/plugins/demo-getter
cd $HOME/code/helm/plugins/demo-getter
```

### 2. Create plugin manifest

```yaml title="plugin.yaml" showLineNumbers
apiVersion: v1
type: getter/v1
name: demo-getter
version: 0.1.0
runtime: subprocess
config:
  protocols: ["demo"]
runtimeConfig:
  protocolCommands:
    - protocols:
        - demo
      platformCommand:
        - command: get-demo.sh
```

### 3. Create Script

Getter plugins are responsible for getting/downloading a packaged artifact â€“ in this case a Chart â€“ and returning the path to the downloaded package. For demo purposes, let's use your system's utility to make a temp directory (it will auto-garbage collect in time on it's own), and use the `helm create` and `helm package` commands to just make a demo chart package in the temp dir, and return the package path:

```bash title="get-demo.sh" showLineNumbers
#!/usr/bin/env sh
set -e

URI=$@
TMPDIR="$(mktemp -d)"

# make a fake chart for testing with the passed URL basename
FILENAME=$(basename -- $URI)
helm create $TMPDIR/$FILENAME 1>/dev/null
helm package $TMPDIR/$FILENAME -d $TMPDIR 1>/dev/null
# cat $FILENAME-0.1.0.tgz
# just to not need to know the chart version
rm -r $TMPDIR/$FILENAME 1>/dev/null
cat $TMPDIR/$FILENAME-*
```

Make it executable:

```bash
chmod +x get-demo.sh
```

### 4. Install in Dev Mode and Test

Installing a plugin from your filesystem installs in local dev mode, which does not check the provenance:

```bash
% helm plugin install $HOME/code/helm/plugins/demo-getter
Installing plugin from local directory (development mode)
Installed plugin: demo-getter
```

As we saw in the [CLI Plugin tutorial](/plugins/developer/tutorial-cli-plugin.mdx), local dev mode installation creates a symlink from your plugin source directory to the plugins directory. You now have two plugins installed:

```bash
% ls -lah $(helm env HELM_PLUGINS)
total 0
drwxr-xr-x@ 4 r6by  staff   160B Nov 10 04:04 .
drwxr-xr-x@ 3 r6by  staff    96B Jan 21  2025 ..
lrwxr-xr-x  1 r6by  staff    41B Nov 10 04:04 demo-getter -> /Users/r6by/code/helm/plugins/demo-getter
lrwxr-xr-x  1 r6by  staff    41B Nov 10 02:18 system-info -> /Users/r6by/code/helm/plugins/system-info
```

Unlike the CLI plugin tutorial, you will not see this plugin in the list of available commands with `helm help`. Only CLI Plugin types appear in the `helm` CLI subcommands list.

But like all plugin types, you can see your installed Postrenderer plugin details with `helm plugin list`:

```bash
% helm plugin list
NAME          	VERSION	TYPE           	APIVERSION	PROVENANCE	SOURCE
demo-getter   	0.1.0  	getter/v1      	v1        	local dev 	unknown
system-info   	0.1.0  	cli/v1         	v1        	local dev 	unknown
```

Let's try it out. It should return templated YAML for a chart named "example":

```bash
% helm template example demo://does-not-matter/example
LOTS OF YAML, INCLUDING:
---
# Source: example/templates/tests/test-connection.yaml
```

What you built: A demo Getter plugin using the Subprocess runtime!

Next let's build a version in Wasm runtimeâ€¦

## Wasm Runtime

### Prerequisites

- Prerequisites from [Subprocess Runtime](#subprocess-runtime)
- Go 1.25 installed

Build a custom protocol getter that converts `demo://` URLs to `https://`.

### 1. Set up repository

Scaffold a new repository from the template (or just clone):
https://github.com/gjenkins8/helm-extism-plugin-template

### 2. Update plugin manifest

Similar to the same step for the Subprocess Getter, except you will do this in your own cloned Git repository.

Note the `runtime` and `runtimeConfig` field values will change for Wasm:

```yaml title="plugin.yaml" showLineNumbers
apiVersion: v1
type: getter/v1
name: demo-getter
version: 0.1.0
runtime: extism/v1
config:
  protocols: ["demo"]
runtimeConfig:
  memory:
    maxPages: 16
  timeout: 30000
```

### 3. Update `main.go`

Specify the plugins input/output messages:

```go title="main.go" showLineNumbers
package main

...

type InputMessage struct {
	URL      string `json:"url"`
	Protocol string `json:"protocol"`
}

type OutputMessage struct {
	Data []byte `json:"data"`
}
```

Replace the `replaceMeImplementationGoesHere` function with actual logic:

```go
...

// Delete the `replaceMeImplementationGoesHere` function

func demoDownloader(input InputMessage) (*OutputMessage, error) {

	// Convert demo:// to https://
	downloadURL := strings.Replace(input.URL, "demo://", "https://", 1)
	pdk.Log(pdk.LogLevelInfo, fmt.Sprintf("Converted %s to %s", input.URL, downloadURL))

	// Download content
	resp, err := http.Get(downloadURL)
	if err != nil {
		return nil, fmt.Errorf("failed to download: %w", err)
	}
	defer resp.Body.Close()

	// Read and output content
	data, _ := io.ReadAll(resp.Body)
	output := OutputMessage{Data: data}
	return &output, nil
}

```

Update the runPlugin function to call `demoDownloader` instead:

```go
func runPlugin() error {
	...
	// Remove: output, err := replaceMeImplementationGoesHere(input)
	output, err := demoDownloader(input)
```

### 4. Build WebAssembly

```bash
$ make build
$ ls -la plugin.wasm
```

### 5. Install in Dev Mode and Test

Same as the Subprocess CLI Plugin step.

What you built: A WebAssembly plugin with sandboxed execution and structured communication via Extism PDK!
</file>

<file path="plugins/developer/tutorial-postrenderer-plugin.mdx">
---
title: "Tutorial: Build a Postrenderer Plugin"
sidebar_label: Build a Postrenderer Plugin
---

import GetVersion from "@site/src/components/GetVersion";
import CodeBlock from "@theme/CodeBlock";

Build a plugin that adds custom labels to all Kubernetes resources.

## Subprocess Runtime

Let's start by building a Postrenderer Plugin with the Subprocess runtime.

### Prerequisites

1. Install the latest Helm 4 release: **<GetVersion majorVersion="4" label={false} link={true} />**
2. In your terminal session, alias `helm` to the release you downloaded. `helm version --short` should now show the correct Helm version in this terminal session.
3. Install `mikefarah/yq`: https://github.com/mikefarah/yq/#install

### 1. Create Plugin Directory

You can create this anywhere on your filesystem. For example:

```bash
mkdir -p $HOME/code/helm/plugins/label-injector
cd $HOME/code/helm/plugins/label-injector
```

### 2. Create plugin manifest

```yaml title="plugin.yaml" showLineNumbers
apiVersion: v1
type: postrenderer/v1
name: label-injector
version: 0.1.0
runtime: subprocess
runtimeConfig:
  platformCommand:
    - command: ${HELM_PLUGIN_DIR}/inject-labels.sh
```

### 3. Create Script

```bash title="inject-labels.sh" showLineNumbers
#!/usr/bin/env sh
# set -e
cat <&0 | yq '.metadata.labels.postrendered-by = "helm-label-injector-plugin"'
```

Make it executable:

```bash
chmod +x inject-labels.sh
```

### 4. Install in Dev Mode and Test

Installing a plugin from your filesystem installs in local dev mode, which does not check the provenance:

```bash
% helm plugin install $HOME/code/helm/plugins/label-injector
Installing plugin from local directory (development mode)
Installed plugin: label-injector
```

As we saw in the [CLI Plugin](/plugins/developer/tutorial-cli-plugin.mdx) and [Getter Plugin](/plugins/developer/tutorial-getter-plugin.mdx) tutorials, local dev mode installation creates a symlink from your plugin source directory to the plugins directory. You now have three plugins installed:

```bash
% ls -lah $(helm env HELM_PLUGINS)
total 0
drwxr-xr-x@ 5 r6by  staff   160B Nov 10 04:04 .
drwxr-xr-x@ 3 r6by  staff    96B Jan 21  2025 ..
lrwxr-xr-x  1 r6by  staff    41B Nov 10 04:04 demo-getter -> /Users/r6by/code/helm/plugins/demo-getter
lrwxr-xr-x  1 r6by  staff    44B Nov 10 03:02 label-injector -> /Users/r6by/code/helm/plugins/label-injector
lrwxr-xr-x  1 r6by  staff    41B Nov 10 02:18 system-info -> /Users/r6by/code/helm/plugins/system-info
```

You can now see your installed Postrenderer plugin details along with the installed CLI and Getter plugins, using `helm plugin list`:

```bash
% helm plugin list
NAME          	VERSION	TYPE           	APIVERSION	PROVENANCE	SOURCE
demo-getter   	0.1.0  	getter/v1      	v1        	local dev 	unknown
label-injector	0.1.0  	postrenderer/v1	v1        	local dev 	unknown
system-info   	0.1.0  	cli/v1         	v1        	local dev 	unknown
```

Let's try it out:

```bash
% helm create ../mychart
% helm template ../mychart --post-renderer label-injector
```

You should see labels like this in the output:

```yaml
metadata:
  labels:
    postrendered-by: helm-label-injector-plugin
```

What you built: A Postrenderer plugin using the Subprocess runtime!

Let's do this one in Wasm runtime now tooâ€¦

## Wasm Runtime

### Prerequisites

- Prerequisites from [Subprocess Runtime](#subprocess-runtime)
- Go 1.25 installed

:::warning
To-do: add this section
:::
</file>

<file path="plugins/user/index.md">
---
title: Plugins User Guide
sidebar_label: Using Plugins
sidebar_position: 2
---

For an overview of Helm Plugin concepts, how to read their structure, and how to understand what their configurations mean for you as a user, read the [Plugins Overview](/plugins/overview.md).

This section focuses on using Helm Plugins as an end-user.

## Finding Plugins

You can already find [Helm Plugins on ArtifactHub](https://artifacthub.io/packages/search?kind=6).

The Helm 4 Plugin system is brand new. In the near future, you should be able to search plugins by type and runtime on ArtifactHub. Stay tuned for updates on this!

## Plugin Security

Depending on the plugin runtime, you should inspect any plugin from third parties before running on your system.

- Subprocess runtime has as much access to your system as the user running the commands. Be sure to carefully inspect the plugin code before installing a plugin, uninstalling a plugin, or running any helm commands that could also run these plugins.
- Wasm runtime, by contrast, runs in a secure sandbox with only the access to your system that you explicitly approve. This plugin runtime has much stronger controls and an inherently higher level of built-in safety. You should still inspect `plugin.yaml` to know what permissions the plugin is requesting.

In both cases, it is highly recommended to verify the provenance of even a Wasm runtime plugin before installing it, so that you can trust where it is downloaded from and who created it. This not only protects you from accidentally installing plugins from spoofed URL attacks, but also network hijacking attacks. Plugin verification allows you to cryptographically ensure a chart has not been compromised before you install it.

See the `--verify` flag in `helm plugin install --help`.

You may also verify the provenance of already installed plugins with `helm plugin verify --help`, in case verification was bypassed during installation (for development purposes), as well as to help provide you with security compliance information at any time.

The `helm plugin list` command also includes high-level provenance information at a glance.

## Installing Plugins

Helm has a build-in command to install plugins that defaults to secure installation. However, be sure to read [Plugin Security](#plugin-security) to understand what to check before installing.

See `helm plugin install --help` for more information.

## Listing Installed Plugins

The command to list plugins includes the plugin's name, version, type, API version, provenance, and source.

See `helm plugin list --help` for more information.

## Uninstalling Plugins

Uninstalling plugins is intended to be straightforward and easy. However, be sure to read [Plugin Security](#plugin-security) to understand the risks of uninstalling as well.

See `helm plugin uninstall --help`.
</file>

<file path="plugins/index.mdx">
---
title: Plugins Guide
sidebar_label: Plugins
sidebar_position: 5.5
---

This guide explains what Helm plugins are, how to use them, and how to build them.

import DocCardList from "@theme/DocCardList";

<DocCardList />
</file>

<file path="plugins/overview.md">
---
title: Plugins Overview
sidebar_label: Overview
sidebar_position: 1
---

Helm Plugins allow users to extend the core feature set of Helm, without requiring every new feature to be written in Go and added to Helm core.

They can be written in any programming language, and can be added and removed from a Helm installation without breaking Helm core functionality.

## Plugin Types

Helm currently has 3 types of Plugins:

- [CLI plugins](#cli-plugins): allow users to add additional `helm` CLI sub-commands
- [Getter plugins](#getter-plugins): allow users to use Charts and even other Plugins in locations Helm core doesn't have built-in support for
- [Postrenderer plugins](#postrenderer-plugins): allow users to modify Chart rendered manifests before being sent to the Kubernetes API

Starting with Helm 4, the plugin system is set up to more easily allow adding additional plugin types, which would allow users to modify other areas of Helm functionality.

### CLI plugins

What is the advantage of using a plugin to create `helm` CLI subcommands as opposed to using separate scripts, or tools with their own standalone commands?

The main reason is plugins that add `helm` CLI sub-commands can leverage Helm-specific configuration, context, and functionality that standalone scripts and tools would otherwise need to develop themselves. They can allow a more seamless extension of `helm` CLI user workflows.

### Getter Plugins

Helm has build-in support for working with [Charts](/glossary/index.mdx#chart) and Plugins on your local filesystem or stored as artifacts in [OCI Registries](/topics/registries.mdx). Charts can additionally be stored in [HTTP repositories](/topics/chart_repository.md), and plugins can additionally be stored in VCS repositories like Git.

Helm Getter plugins allow you to extend this storage and download behavior to support other storage locations. There are community Getter plugins for storing Charts and Plugins in [s3 buckets](/community/related#helm-plugins), and elsewhere. You will want to use getter plugins if you need additional storage options for your Helm workflows.

### PostRenderer plugins

Helm allows users to configure charts by supplying custom values. These user-provided values are what Charts use to render the manifests that allow Helm to manage your applications in Kubernetes.

If you write your own charts, you can update the templates whenever you need additional configurability for your rendered manifests. However, if you are using community charts that you don't own, post-rendering allows you to modify the manifests after the charts have rendered them but before Helm uses them to manage your Kubernetes resources. Starting with Helm 4, postrenderer plugins are the way to do this.

## Plugin API Versions

Starting with Helm 4, the `plugin.yaml` file included with every plugin now has an `apiVersion` field, currently at `v1`.

Legacy plugins (prior to API versioning) will still be supported throughout the life of Helm 4, so your existing plugins from Helm 3 will still work until Helm 5. However, you should ask authors of your favorite plugins to update their plugins to the new versioning system.

If you are a plugin developer, read more about this in the [Plugins Developer Guide](/plugins/developer/index.mdx).

## Plugin Runtimes

Helm currently supports 2 plugin runtimes:

- Subprocess runtime
- Wasm runtime

See the relevant information about each runtime in either the [Plugins User Guide](/plugins/user/index.md) or [Plugins Developer Guide](/plugins/developer/index.mdx).

## File structure

All of the files for a plugin live within a single directory, which is used for developing, packaging, and installing.

Inside the plugin's directory, Helm expects this structure:

```
example-plugin
â”œâ”€â”€ plugin.yaml # REQUIRED
â”œâ”€â”€ plugin.sh   # OPTIONAL for Subprocess runtime
â””â”€â”€ plugin.wasm # REQUIRED for Wasm runtime
```

- The only required file is [plugin.yaml](#pluginyaml).
- [Subprocess runtime](#plugin-runtimes) can optionally contain one or more custom executable files containing your plugin code (can be Node, Python, Go, etc). For this runtime, you can alternatively call any executable already available in the user's PATH, directly from the `plugin.yaml` [runtime configuration](#runtime-configuration) `platformCommand` field.
- For [Wasm runtime](#plugin-runtimes), you will need to include a `.wasm` file. This is your plugin code (can be Node, Python, Go, etc) compiled to Wasm.

## Plugin.yaml

The `plugin.yaml` file is required for a plugin. It is a YAML file containing metadata and configuration for the plugin.

### Metadata Information

```yaml
apiVersion: REQUIRED - The Plugin API version. Must be "v1"
type: REQUIRED - The versioned Plugin Type. Can be "cli/v1", "getter/v1", or "postrenderer/v1"
name: REQUIRED - The name of the plugin
version: REQUIRED - The version of the plugin
runtime: REQUIRED - The runtime for the plugin. Can be "subprocess" or "extism/v1" (Wasm)
sourceURL: OPTIONAL - A URL pointing to the source code for your plugin
config: DEPENDS ON PLUGIN TYPE
runtimeConfig: DEPENDS ON RUNTIME
```

- The `config` field is for [Plugin Type Configuration](#plugin-type-configuration), with a structure that differs per [Plugin Type](#plugin-types) as defined by the `type` field.
- The `runtimeConfig` field is for [Runtime Configuration](#runtime-configuration), with a structure that differs per [Runtime](#plugin-runtimes) as defined by the `runtime` field.
- ðŸ’¡ While the `sourceURL` field is optional, plugin authors are strongly encouraged to point to the plugin source code because it helps plugin users understand what the code does, and contribute to the plugin if it accepts open source contributions.

### Plugin Type Configuration

The `config` field of [plugin.yaml](#pluginyaml) has different options per [Plugin Type](#plugin-types). A plugin's type is defined by the `type` field.

#### CLI Plugin Configuration

If `type` field is `cli/v1`, it is a [CLI Plugin type](#cli-plugins), and the following plugin type configurations are allowed:

```yaml
usage: OPTIONAL - The single-line usage text shown in help
shortHelp: The short description shown in the 'helm help' output
longHelp: The long message shown in the 'helm help <this-command>' output
ignoreFlags: Ignores any flags passed in from Helm
```

- `usage` is optional. Defaults to "helm PLUGIN_NAME [flags]" if not overridden with a custom usage string. For recommended syntax, see [spf13/cobra.command.Command] Use field comment: https://pkg.go.dev/github.com/spf13/cobra#Command
- `ignoreFlags` switch tells Helm to not pass flags to the plugin. So if a plugin is called with `helm myplugin --foo` and `ignoreFlags: true`, then `--foo` is silently discarded.

#### Getter Plugin Configuration

If `type` field is `getter/v1`, it is a [Getter Plugin type](#cli-plugins), and the following plugin type configurations are allowed:

```yaml
protocols: The list of schemes from the charts URL that this plugin supports.
```

#### Postrenderer Plugin Configuration

If `type` field is `postrenderer/v1`, it is a [Postrenderer Plugin type](#cli-plugins), and does not have any configuration options.

### Runtime Configuration

The `runtimeConfig` field of [plugin.yaml](#pluginyaml) has different options per [Plugin Runtime](#plugin-runtimes). A plugin's runtime is defined by the `runtime` field.

#### Subprocess Runtime Configuration

If the `runtime` field is `subprocess`, it is a [Subprocess Runtime](#plugin-runtimes) plugin and the following runtime configurations are allowed:

```yaml
runtimeconfig:
    platformCommand: # Configure command to run based on the platform
        - os: OS match, can be empty or omitted to match any OS
          arch: Architecture match, can be empty or omitted to match any architecture
          command: Plugin command to execute
          args: Plugin command arguments
    platformHooks: # Configure plugin lifecycle hooks based on the platform
        install: # Install lifecycle commands
            - os: OS match, can be empty or omitted to match any OS
              arch: Architecture match, can be empty or omitted to match any architecture
              command: Plugin install command to execute
              args: Plugin install command arguments
        update: # Update lifecycle commands
            - os: OS match, can be empty or omitted to match any OS
              arch: Architecture match, can be empty or omitted to match any architecture
              command: Plugin update command to execute
              args: Plugin update command arguments
        delete: # Delete lifecycle commands
            - os: OS match, can be empty or omitted to match any OS
              arch: Architecture match, can be empty or omitted to match any architecture
              command: Plugin delete command to execute
              args: Plugin delete command arguments
    protocolCommands: # Obsolete/deprecated
        - protocols: [] # Protocols are the list of schemes from the charts URL.
          platformCommand: [] # Same structure as "platformCommand" above
```

- âš ï¸ `protocolCommands` is marked `obsolete/deprecated`, and will be removed in future versions of the plugin system after `apiVersion: v1`. It only applies to the "getter/v1" plugin type. This is a compatibility hangover from the old plugin downloader mechanism, which was extended to support multiple protocols in a given plugin. The command supplied in PlatformCommand should implement protocol specific logic by inspecting the download URL.

#### Wasm Runtime Configuration

If the `runtime` field is `extism/v1`, it is a [Wasm Runtime](#plugin-runtimes) plugin and the following runtime configurations are allowed:

```yaml
runtimeconfig:
    memory: # Describes the limits on the memory the plugin may be allocated
        maxPages: The max amount of pages the plugin can allocate. One page is 64Kib. e.g. 16 pages would require 1MiB. Default is 4 pages (256KiB).
        maxHttpResponseBytes: The max size of an Extism HTTP response in bytes. Default is 4096 bytes (4KiB).
        maxVarBytes: The max size of all Extism vars in bytes. Default is 4096 bytes (4KiB).
    config: {} # A free-form map that can be passed to the plugin.
    allowedHosts: [] # An optional set of hosts this plugin can communicate with. Defaults to no hosts allowed.
    fileSystem:
        createTempDir: Whether to create a temporary directory on the filesystem. Can be "true" or "false".
    timeout: The timeout in milliseconds for the plugin to execute
    hostFunctions: HostFunction names exposed in Helm the plugin may access. See https://extism.org/docs/concepts/host-functions/
    entryFuncName: The name of entry function name to call in the plugin. Defaults to "helm_plugin_main".
```

- `allowedHosts` only has an effect if the plugin makes HTTP requests. If not specified, then no hosts are allowed.
</file>

<file path="sdk/examples.mdx">
---
title: Examples
description: Examples of various features of the Helm SDK
sidebar_position: 2
---
import CodeBlock from '@theme/CodeBlock';

import MainExampleGo from '!!raw-loader!/sdkexamples/main.go';
import InstallExampleGo from '!!raw-loader!/sdkexamples/install.go';
import ListExampleGo from '!!raw-loader!/sdkexamples/list.go';
import PullExampleGo from '!!raw-loader!/sdkexamples/pull.go';
import UninstallExampleGo from '!!raw-loader!/sdkexamples/uninstall.go';
import UpgradeExampleGo from '!!raw-loader!/sdkexamples/upgrade.go';

This document runs though a series of examples of using the Helm SDK.
Intended to document various SDK functionalities.

The final example shows `main.go` driver ([link](#driver)). That runs the below actions and includes necessary helper functions.

The code for the examples lives in the [helm/helm-www/sdkexamples/](https://github.com/helm/helm-www/tree/main/sdkexamples) directory.
And is intended to be fully functional.

## Actions

### Install Action

This example installs the given chart/release, for the given version and values:

<CodeBlock language="go" title="sdkexamples/install.go" showLineNumbers>{InstallExampleGo}</CodeBlock>

### Upgrade Action

This example upgrades the given release, with the given chart, version and values:

<CodeBlock language="go" title="sdkexamples/upgrade.go" showLineNumbers>{UpgradeExampleGo}</CodeBlock>

### Uninstall Action

This example uninstalls the given release:

<CodeBlock language="go" title="sdkexamples/uninstall.go" showLineNumbers>{UninstallExampleGo}</CodeBlock>

### List Action

This example lists all released charts (in the currently configured namespace):

<CodeBlock language="go" title="sdkexamples/list.go" showLineNumbers>{ListExampleGo}</CodeBlock>

### Pull Action

This example pulls a chart from an OCI repository:

<CodeBlock language="go" title="sdkexamples/pull.go" showLineNumbers>{PullExampleGo}</CodeBlock>

## Driver

The driver here shows the necessary auxiliary functions needed for the Helm SDK actions to function. And shows the above examples in action, to pull, install, update, and uninstall the 'podinfo' chart from an OCI repository:

<CodeBlock language="go" title="sdkexamples/main.go" showLineNumbers>{MainExampleGo}</CodeBlock>
</file>

<file path="sdk/gosdk.mdx">
---
title: Introduction
description: Introduces the Helm Go SDK
sidebar_position: 1
---

Helm's Go SDK enables custom software to leverage Helm charts and Helm's functionality for managing Kubernetes software deployment
(In fact, the Helm CLI is effectively just one such tool!).

Currently, the SDK has been functionally separated from the Helm CLI.
And the SDK can (and is) used by standalone tooling.
The Helm project has committed to API stability for the SDK.
As a warning, the SDK has some rough edges remaining from the initial work to separate the CLI and the SDK. Which the Helm project aims to improve and over time.

Full API documentation can be found at [https://pkg.go.dev/helm.sh/helm/v4](https://pkg.go.dev/helm.sh/helm/v4).

A brief overview of some of the main types of packages and a simple example follows below.
See the [Examples](/sdk/examples.mdx) section for more examples and a more full featured 'driver'.

## Main package overview

- [pkg/action](https://pkg.go.dev/helm.sh/helm/v4/pkg/action):
  Contains the main â€œclientâ€ for performing Helm actions.
  This is the same package that the CLI is using underneath the hood.
  If you just need to perform basic Helm commands from another Go program, this package is for you.
- [pkg/chart](https://pkg.go.dev/helm.sh/helm/v4/pkg/chart), [pkg/chartutil](https://pkg.go.dev/helm.sh/helm/v4/pkg/chart/v2/util):
  Methods and helpers used for loading and manipulating charts.
- [pkg/cli](https://pkg.go.dev/helm.sh/helm/v4/pkg/cli) and its subpackages:
  Contains all the handlers for the standard Helm environment variables and its subpackages contain output and values file handling.
- [pkg/release](https://pkg.go.dev/helm.sh/helm/v4/pkg/release):
  Defines the `Release` object and statuses.

There are many more packages besides these, so go check out the documentation for more information!

### Simple example
This is a simple example of doing a `helm list` using the Go SDK.
See the [Examples](/sdk/examples.mdx) section for more full featured examples.

```go
package main

import (
    "log"
    "os"

    "helm.sh/helm/v4/pkg/action"
    "helm.sh/helm/v4/pkg/cli"
)

func main() {
    settings := cli.New()

    actionConfig := new(action.Configuration)
    // You can pass an empty string instead of settings.Namespace() to list
    // all namespaces
    if err := actionConfig.Init(settings.RESTClientGetter(), settings.Namespace(), os.Getenv("HELM_DRIVER"), log.Printf); err != nil {
        log.Printf("%+v", err)
        os.Exit(1)
    }

    client := action.NewList(actionConfig)
    // Only list deployed
    client.Deployed = true
    results, err := client.Run()
    if err != nil {
        log.Printf("%+v", err)
        os.Exit(1)
    }

    for _, rel := range results {
        log.Printf("%+v", rel)
    }
}

```


## Compatibility

The Helm SDK explicitly follows the Helm backwards compatibility guarantees:

https://github.com/helm/community/blob/main/hips/hip-0004.md

That is, breaking changes will only be made with a major version release or to remediate a security issue.
</file>

<file path="sdk/index.mdx">
---
title: Go SDK
sidebar_position: 7
---

import DocCardList from '@theme/DocCardList';

<DocCardList />
</file>

<file path="topics/advanced.mdx">
---
title: Advanced Helm Techniques
description: Explains various advanced features for Helm power users
sidebar_position: 9
---

import Helm4 from "/docs/_v4-in-progress.mdx"

<Helm4/>

This section explains various advanced features and techniques for using Helm.
The information in this section is intended for "power users" of Helm that wish
to do advanced customization and manipulation of their charts and releases. Each
of these advanced features comes with their own tradeoffs and caveats, so each
one must be used carefully and with deep knowledge of Helm. Or in other words,
remember the [Peter Parker
principle](https://en.wikipedia.org/wiki/With_great_power_comes_great_responsibility)

## Post Rendering
Post rendering gives chart installers the ability to manually manipulate,
configure, and/or validate rendered manifests before they are installed by Helm.
This allows users with advanced configuration needs to be able to use tools like
[`kustomize`](https://kustomize.io) to apply configuration changes without the
need to fork a public chart or requiring chart maintainers to specify every last
configuration option for a piece of software. There are also use cases for
injecting common tools and side cars in enterprise environments or analysis of
the manifests before deployment.

### Prerequisites
- Helm 3.1+

### Usage
A post-renderer can be any executable that accepts rendered Kubernetes manifests
on STDIN and returns valid Kubernetes manifests on STDOUT. It should return an
non-0 exit code in the event of a failure. This is the only "API" between the
two components. It allows for great flexibility in what you can do with your
post-render process.

A post-renderer can be used with `install`, `upgrade`, and `template`. To use a
post-renderer, use the `--post-renderer` flag with a path to the renderer
executable you wish to use:

```shell
$ helm install mychart stable/wordpress --post-renderer ./path/to/executable
```

If the path does not contain any separators, it will search in $PATH, otherwise
it will resolve any relative paths to a fully qualified path

If you wish to use multiple post-renderers, call all of them in a script or
together in whatever binary tool you have built. In bash, this would be as
simple as `renderer1 | renderer2 | renderer3`.

You can see an example of using `kustomize` as a post-renderer
[here](https://github.com/thomastaylor312/advanced-helm-demos/tree/master/post-render).

#### Filenames
Each manifest passed to the post-renderer includes a temporary annotation:
```yaml
metadata:
  annotations:
    postrenderer.helm.sh/postrender-filename: <original-template-filename>
```

Helm uses this annotation when reading back the post-rendererâ€™s output to determine which filename to associate with each manifest for further processing. If the annotation is missing, Helm auto-generates a filename in the format `generated-by-postrender-<id>.yaml`. Finally, Helm removes the annotation before sending the manifests to Kubernetes.

### Caveats
When using post renderers, there are several important things to keep in mind.
The most important of these is that when using a post-renderer, all people
modifying that release **MUST** use the same renderer in order to have
repeatable builds. This feature is purposefully built to allow any user to
switch out which renderer they are using or to stop using a renderer, but this
should be done deliberately to avoid accidental modification or data loss.

One other important note is around security. If you are using a post-renderer,
you should ensure it is coming from a reliable source (as is the case for any
other arbitrary executable). Using non-trusted or non-verified renderers is NOT
recommended as they have full access to rendered templates, which often contain
secret data.

### Custom Post Renderers
The post render step offers even more flexibility when used in the Go SDK. Any
post renderer only needs to implement the following Go interface:

```go
type PostRenderer interface {
    // Run expects a single buffer filled with Helm rendered manifests. It
    // expects the modified results to be returned on a separate buffer or an
    // error if there was an issue or failure while running the post render step
    Run(renderedManifests *bytes.Buffer) (modifiedManifests *bytes.Buffer, err error)
}
```

For more information on using the Go SDK, See the [Go SDK section](#go-sdk)

## Go SDK
Helm 3 debuted a completely restructured Go SDK for a better experience when
building software and tools that leverage Helm. Full documentation can be found
in the [Go SDK Section](/sdk/gosdk.mdx).

## Storage backends

By default, release information is stored in Secrets in the
namespace of the release. The subsections which follow
show how to configure different backends. This configuration is based on the
`HELM_DRIVER` environment variable. It can be set to one of the values:
`[configmap, secret, sql]`.

### ConfigMap storage backend

To enable the ConfigMap backend, you'll need to set the environmental variable
`HELM_DRIVER` to `configmap`.

You can set it in a shell as follows:

```shell
export HELM_DRIVER=configmap
```

If you want to switch from the default backend to the ConfigMap backend, you'll
have to do the migration for this on your own. You can retrieve release
information with the following command:

```shell
kubectl get secret --all-namespaces -l "owner=helm"
```

**PRODUCTION NOTES**: The release information includes the contents of charts and
values files, and therefore might contain sensitive data (like
passwords, private keys, and other credentials) that needs to be protected from
unauthorized access. When managing Kubernetes authorization, for instance with
[RBAC](https://kubernetes.io/docs/reference/access-authn-authz/rbac/), it is
possible to grant broader access to ConfigMap resources, while restricting
access to Secret resources. For instance, the default [user-facing
role](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles)
"view" grants access to most resources, but not to Secrets. Furthermore, secrets
data can be configured for [encrypted
storage](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/).
Please keep that in mind if you decide to switch to the ConfigMap backend, as it
could expose your application's sensitive data.

### SQL storage backend

There is a ***beta*** SQL storage backend that stores release information in an SQL
database.

Using such a storage backend is particularly useful if your release information
weighs more than 1MB (in which case, it can't be stored in ConfigMaps/Secrets
because of internal limits in Kubernetes' underlying etcd key-value store).

To enable the SQL backend, you'll need to deploy a SQL database and set the
environmental variable `HELM_DRIVER` to `sql`. The DB details are set with the
environmental variable `HELM_DRIVER_SQL_CONNECTION_STRING`.

You can set it in a shell as follows:

```shell
export HELM_DRIVER=sql
export HELM_DRIVER_SQL_CONNECTION_STRING=postgresql://helm-postgres:5432/helm?user=helm&password=changeme
```

> Note: Only PostgreSQL is supported at this moment.

**PRODUCTION NOTES**: It is recommended to:
- Make your database production ready. For PostgreSQL, refer to the [Server Administration](https://www.postgresql.org/docs/12/admin.html) docs for more details
- Enable [permission management](/topics/permissions_sql_storage_backend.md) to
mirror Kubernetes RBAC for release information

If you want to switch from the default backend to the SQL backend, you'll have
to do the migration for this on your own. You can retrieve release information
with the following command:

```shell
kubectl get secret --all-namespaces -l "owner=helm"
```
</file>

<file path="topics/architecture.md">
---
title: Helm Architecture
description: Describes the Helm architecture at a high level.
sidebar_position: 8
---

# Helm Architecture

This document describes the Helm architecture at a high level.

## The Purpose of Helm

Helm is a tool for managing Kubernetes packages called _charts_. Helm can do the
following:

- Create new charts from scratch
- Package charts into chart archive (tgz) files
- Interact with chart repositories where charts are stored
- Install and uninstall charts into an existing Kubernetes cluster
- Manage the release cycle of charts that have been installed with Helm

For Helm, there are three important concepts:

1. The _chart_ is a bundle of information necessary to create an instance of a
   Kubernetes application.
2. The _config_ contains configuration information that can be merged into a
   packaged chart to create a releasable object.
3. A _release_ is a running instance of a _chart_, combined with a specific
   _config_.

## Components

Helm is an executable which is implemented into two distinct parts:

**The Helm Client** is a command-line client for end users. The client is
responsible for the following:

- Local chart development
- Managing repositories
- Managing releases
- Interfacing with the Helm library
  - Sending charts to be installed
  - Requesting upgrading or uninstalling of existing releases

**The Helm Library** provides the logic for executing all Helm operations. It
interfaces with the Kubernetes API server and provides the following capability:

- Combining a chart and configuration to build a release
- Installing charts into Kubernetes, and providing the subsequent release object
- Upgrading and uninstalling charts by interacting with Kubernetes

The standalone Helm library encapsulates the Helm logic so that it can be
leveraged by different clients.

## Implementation

The Helm client and library is written in the Go programming language.

The library uses the Kubernetes client library to communicate with Kubernetes.
Currently, that library uses REST+JSON. It stores information in Secrets located
inside of Kubernetes. It does not need its own database.

Configuration files are, when possible, written in YAML.
</file>

<file path="topics/chart_repository.md">
---
title: The Chart Repository Guide
description: How to create and work with Helm chart repositories.
sidebar_position: 6
---

This section explains how to create and work with Helm chart repositories. At a
high level, a chart repository is a location where packaged charts can be stored
and shared.

The distributed community Helm chart repository is located at
[Artifact Hub](https://artifacthub.io/packages/search?kind=0) and welcomes
participation. But Helm also makes it possible to create and run your own chart
repository. This guide explains how to do so. If you are considering creating a
chart repository, you may want to consider using an
[OCI registry](/topics/registries.mdx) instead.

## Prerequisites

* Go through the [Quickstart](/intro/quickstart.md) Guide
* Read through the [Charts](/topics/charts.mdx) document

## Create a chart repository

A _chart repository_ is an HTTP server that houses an `index.yaml` file and
optionally some packaged charts.  When you're ready to share your charts, the
preferred way to do so is by uploading them to a chart repository.

As of Helm 2.2.0, client-side SSL auth to a repository is supported. Other
authentication protocols may be available as plugins.

Because a chart repository can be any HTTP server that can serve YAML and tar
files and can answer GET requests, you have a plethora of options when it comes
down to hosting your own chart repository. For example, you can use a Google
Cloud Storage (GCS) bucket, Amazon S3 bucket, GitHub Pages, or even create your
own web server.

### The chart repository structure

A chart repository consists of packaged charts and a special file called
`index.yaml` which contains an index of all of the charts in the repository.
Frequently, the charts that `index.yaml` describes are also hosted on the same
server, as are the [provenance files](/topics/provenance.mdx).

For example, the layout of the repository `https://example.com/charts` might
look like this:

```
charts/
  |
  |- index.yaml
  |
  |- alpine-0.1.2.tgz
  |
  |- alpine-0.1.2.tgz.prov
```

In this case, the index file would contain information about one chart, the
Alpine chart, and provide the download URL
`https://example.com/charts/alpine-0.1.2.tgz` for that chart.

It is not required that a chart package be located on the same server as the
`index.yaml` file. However, doing so is often the easiest.

### The index file

The index file is a yaml file called `index.yaml`. It contains some metadata
about the package, including the contents of a chart's `Chart.yaml` file. A
valid chart repository must have an index file. The index file contains
information about each chart in the chart repository. The `helm repo index`
command will generate an index file based on a given local directory that
contains packaged charts.

This is an example of an index file:

```yaml
apiVersion: v1
entries:
  alpine:
    - created: 2016-10-06T16:23:20.499814565-06:00
      description: Deploy a basic Alpine Linux pod
      digest: 99c76e403d752c84ead610644d4b1c2f2b453a74b921f422b9dcb8a7c8b559cd
      home: https://helm.sh/helm
      name: alpine
      sources:
      - https://github.com/helm/helm
      urls:
      - https://technosophos.github.io/tscharts/alpine-0.2.0.tgz
      version: 0.2.0
    - created: 2016-10-06T16:23:20.499543808-06:00
      description: Deploy a basic Alpine Linux pod
      digest: 515c58e5f79d8b2913a10cb400ebb6fa9c77fe813287afbacf1a0b897cd78727
      home: https://helm.sh/helm
      name: alpine
      sources:
      - https://github.com/helm/helm
      urls:
      - https://technosophos.github.io/tscharts/alpine-0.1.0.tgz
      version: 0.1.0
  nginx:
    - created: 2016-10-06T16:23:20.499543808-06:00
      description: Create a basic nginx HTTP server
      digest: aaff4545f79d8b2913a10cb400ebb6fa9c77fe813287afbacf1a0b897cdffffff
      home: https://helm.sh/helm
      name: nginx
      sources:
      - https://github.com/helm/charts
      urls:
      - https://technosophos.github.io/tscharts/nginx-1.1.0.tgz
      version: 1.1.0
generated: 2016-10-06T16:23:20.499029981-06:00
```

## Hosting Chart Repositories

This part shows several ways to serve a chart repository.

### Google Cloud Storage

The first step is to **create your GCS bucket**. We'll call ours
`fantastic-charts`.

![Create a GCS Bucket](/img/helm2/create-a-bucket.png)

Next, make your bucket public by **editing the bucket permissions**.

![Edit Permissions](/img/helm2/edit-permissions.png)

Insert this line item to **make your bucket public**:

![Make Bucket Public](/img/helm2/make-bucket-public.png)

Congratulations, now you have an empty GCS bucket ready to serve charts!

You may upload your chart repository using the Google Cloud Storage command
line tool, or using the GCS web UI. A public GCS bucket can be accessed via
simple HTTPS at this address: `https://bucket-name.storage.googleapis.com/`.

### Cloudsmith

You can also set up chart repositories using Cloudsmith. Read more about
chart repositories with Cloudsmith
[here](https://help.cloudsmith.io/docs/helm-chart-repository)

### JFrog Artifactory

Similarly, you can also set up chart repositories using JFrog Artifactory. Read more about
chart repositories with JFrog Artifactory
[here](https://www.jfrog.com/confluence/display/RTF/Helm+Chart+Repositories)

### GitHub Pages example

In a similar way you can create charts repository using GitHub Pages.

GitHub allows you to serve static web pages in two different ways:

- By configuring a project to serve the contents of its `docs/` directory
- By configuring a project to serve a particular branch

We'll take the second approach, though the first is just as easy.

The first step will be to **create your gh-pages branch**.  You can do that
locally as.

```console
$ git checkout -b gh-pages
```

Or via web browser using **Branch** button on your GitHub repository:

![Create GitHub Pages branch](/img/helm2/create-a-gh-page-button.png)

Next, you'll want to make sure your **gh-pages branch** is set as GitHub Pages,
click on your repo **Settings** and scroll down to **GitHub pages** section and
set as per below:

![Create GitHub Pages branch](/img/helm2/set-a-gh-page.png)

By default **Source** usually gets set to **gh-pages branch**. If this is not
set by default, then select it.

You can use a **custom domain** there if you wish so.

And check that **Enforce HTTPS** is ticked, so the **HTTPS** will be used when
charts are served.

In such setup you can use your default branch to store your charts code, and
**gh-pages branch** as charts repository, e.g.:
`https://USERNAME.github.io/REPONAME`. The demonstration [TS
Charts](https://github.com/technosophos/tscharts) repository is accessible at
`https://technosophos.github.io/tscharts/`.

If you have decided to use GitHub pages to host the chart repository, check out
[Chart Releaser Action](/howto/chart_releaser_action.md).
Chart Releaser Action is a GitHub Action workflow to turn a GitHub project into
a self-hosted Helm chart repo, using
[helm/chart-releaser](https://github.com/helm/chart-releaser) CLI tool.

### Ordinary web servers

To configure an ordinary web server to serve Helm charts, you merely need to do
the following:

- Put your index and charts in a directory that the server can serve
- Make sure the `index.yaml` file can be accessed with no authentication
  requirement
- Make sure `yaml` files are served with the correct content type (`text/yaml`
  or `text/x-yaml`)

For example, if you want to serve your charts out of `$WEBROOT/charts`, make
sure there is a `charts/` directory in your web root, and put the index file and
charts inside of that folder.

### ChartMuseum Repository Server

ChartMuseum is an open-source Helm Chart Repository server written in Go
(Golang), with support for cloud storage backends, including [Google Cloud
Storage](https://cloud.google.com/storage/), [Amazon
S3](https://aws.amazon.com/s3/), [Microsoft Azure Blob
Storage](https://azure.microsoft.com/en-us/services/storage/blobs/), [Alibaba
Cloud OSS Storage](https://www.alibabacloud.com/product/oss), [Openstack Object
Storage](https://developer.openstack.org/api-ref/object-store/), [Oracle Cloud
Infrastructure Object Storage](https://cloud.oracle.com/storage), [Baidu Cloud
BOS Storage](https://cloud.baidu.com/product/bos.html), [Tencent Cloud Object
Storage](https://intl.cloud.tencent.com/product/cos), [DigitalOcean
Spaces](https://www.digitalocean.com/products/spaces/),
[Minio](https://min.io/), and [etcd](https://etcd.io/).

You can also use the
[ChartMuseum](https://chartmuseum.com/docs/#using-with-local-filesystem-storage)
server to host a chart repository from a local file system.

### GitLab Package Registry

With GitLab you can publish Helm charts in your projectâ€™s Package Registry.
Read more about setting up a helm package repository with GitLab [here](https://docs.gitlab.com/ee/user/packages/helm_repository/).

## Managing Chart Repositories

Now that you have a chart repository, the last part of this guide explains how
to maintain charts in that repository.


### Store charts in your chart repository

Now that you have a chart repository, let's upload a chart and an index file to
the repository.  Charts in a chart repository must be packaged (`helm package
chart-name/`) and versioned correctly (following [SemVer 2](https://semver.org/)
guidelines).

These next steps compose an example workflow, but you are welcome to use
whatever workflow you fancy for storing and updating charts in your chart
repository.

Once you have a packaged chart ready, create a new directory, and move your
packaged chart to that directory.

```console
$ helm package docs/examples/alpine/
$ mkdir fantastic-charts
$ mv alpine-0.1.0.tgz fantastic-charts/
$ helm repo index fantastic-charts --url https://fantastic-charts.storage.googleapis.com
```

The last command takes the path of the local directory that you just created and
the URL of your remote chart repository and composes an `index.yaml` file inside
the given directory path.

Now you can upload the chart and the index file to your chart repository using a
sync tool or manually. If you're using Google Cloud Storage, check out this
[example workflow](/howto/chart_repository_sync_example.md)
using the gsutil client. For GitHub, you can simply put the charts in the
appropriate destination branch.

### Add new charts to an existing repository

Each time you want to add a new chart to your repository, you must regenerate
the index. The `helm repo index` command will completely rebuild the
`index.yaml` file from scratch, including only the charts that it finds locally.

However, you can use the `--merge` flag to incrementally add new charts to an
existing `index.yaml` file (a great option when working with a remote repository
like GCS). Run `helm repo index --help` to learn more,

Make sure that you upload both the revised `index.yaml` file and the chart. And
if you generated a provenance file, upload that too.

### Share your charts with others

When you're ready to share your charts, simply let someone know what the URL of
your repository is.

From there, they will add the repository to their helm client via the `helm repo
add [NAME] [URL]` command with any name they would like to use to reference the
repository.

```console
$ helm repo add fantastic-charts https://fantastic-charts.storage.googleapis.com
$ helm repo list
fantastic-charts    https://fantastic-charts.storage.googleapis.com
```

If the charts are backed by HTTP basic authentication, you can also supply the
username and password here:

```console
$ helm repo add fantastic-charts https://fantastic-charts.storage.googleapis.com --username my-username --password my-password
$ helm repo list
fantastic-charts    https://fantastic-charts.storage.googleapis.com
```

**Note:** A repository will not be added if it does not contain a valid
`index.yaml`.

**Note:** If your helm repository is e.g. using a self signed
certificate, you can use `helm repo add --insecure-skip-tls-verify ...` in order
to skip the CA verification.

After that, your users will be able to search through your charts. After you've
updated the repository, they can use the `helm repo update` command to get the
latest chart information.

*Under the hood, the `helm repo add` and `helm repo update` commands are
fetching the index.yaml file and storing them in the
`$XDG_CACHE_HOME/helm/repository/cache/` directory. This is where the `helm
search` function finds information about charts.*
</file>

<file path="topics/chart_tests.md">
---
title: Chart Tests
description: Describes how to run and test your charts.
sidebar_position: 3
---

A chart contains a number of Kubernetes resources and components that work
together. As a chart author, you may want to write some tests that validate that
your chart works as expected when it is installed. These tests also help the
chart consumer understand what your chart is supposed to do.

A **test** in a helm chart lives under the `templates/` directory and is a job
definition that specifies a container with a given command to run. The container
should exit successfully (exit 0) for a test to be considered a success. The job
definition must contain the helm test hook annotation: `helm.sh/hook: test`.

Note that until Helm v3, the job definition needed to contain one of these helm
test hook annotations: `helm.sh/hook: test-success` or `helm.sh/hook: test-failure`.
`helm.sh/hook: test-success` is still accepted as a backwards-compatible
alternative to `helm.sh/hook: test`.

Example tests:

- Validate that your configuration from the values.yaml file was properly
  injected.
  - Make sure your username and password work correctly
  - Make sure an incorrect username and password does not work
- Assert that your services are up and correctly load balancing
- etc.

You can run the pre-defined tests in Helm on a release using the command `helm
test <RELEASE_NAME>`. For a chart consumer, this is a great way to check that
their release of a chart (or application) works as expected.

## Example Test

The [helm create](/helm/helm_create.md) command will automatically create a number of folders and files. To try the helm test functionality, first create a demo helm chart. 

```console
$ helm create demo
```

You will now be able to see the following structure in your demo helm chart.

```
demo/
  Chart.yaml
  values.yaml
  charts/
  templates/
  templates/tests/test-connection.yaml
```

In `demo/templates/tests/test-connection.yaml` you'll see a test you can try. You can see the helm test pod definition here:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: "{{ include "demo.fullname" . }}-test-connection"
  labels:
    {{- include "demo.labels" . | nindent 4 }}
  annotations:
    "helm.sh/hook": test
spec:
  containers:
    - name: wget
      image: busybox
      command: ['wget']
      args: ['{{ include "demo.fullname" . }}:{{ .Values.service.port }}']
  restartPolicy: Never

```

## Steps to Run a Test Suite on a Release

First, install the chart on your cluster to create a release. You may have to
wait for all pods to become active; if you test immediately after this install,
it is likely to show a transitive failure, and you will want to re-test.

```console
$ helm install demo demo --namespace default
$ helm test demo
NAME: demo
LAST DEPLOYED: Mon Feb 14 20:03:16 2022
NAMESPACE: default
STATUS: deployed
REVISION: 1
TEST SUITE:     demo-test-connection
Last Started:   Mon Feb 14 20:35:19 2022
Last Completed: Mon Feb 14 20:35:23 2022
Phase:          Succeeded
[...]
```

## Notes

- You can define as many tests as you would like in a single yaml file or spread
  across several yaml files in the `templates/` directory.
- You are welcome to nest your test suite under a `tests/` directory like
  `<chart-name>/templates/tests/` for more isolation.
- A test is a [Helm hook](/topics/charts_hooks.md), so annotations like
  `helm.sh/hook-weight` and `helm.sh/hook-delete-policy` may be used with test
  resources.
- Often the contents in the `tests/` directory does not need to be packaged and published. Consider adding `tests/` to the `.helmignore` file.
</file>

<file path="topics/charts_hooks.md">
---
title: Chart Hooks
description: Describes how to work with chart hooks.
sidebar_position: 2
---

Helm provides a _hook_ mechanism to allow chart developers to intervene at
certain points in a release's life cycle. For example, you can use hooks to:

- Load a ConfigMap or Secret during install before any other charts are loaded.
- Execute a Job to back up a database before installing a new chart, and then
  execute a second job after the upgrade in order to restore data.
- Run a Job before deleting a release to gracefully take a service out of
  rotation before removing it.

Hooks work like regular templates, but they have special annotations that cause
Helm to utilize them differently. In this section, we cover the basic usage
pattern for hooks.

## The Available Hooks

The following hooks are defined:

| Annotation Value | Description                                                                                           |
| ---------------- | ----------------------------------------------------------------------------------------------------- |
| `pre-install`    | Executes after templates are rendered, but before any resources are created in Kubernetes             |
| `post-install`   | Executes after all resources are loaded into Kubernetes                                               |
| `pre-delete`     | Executes on a deletion request before any resources are deleted from Kubernetes                       |
| `post-delete`    | Executes on a deletion request after all of the release's resources have been deleted                 |
| `pre-upgrade`    | Executes on an upgrade request after templates are rendered, but before any resources are updated     |
| `post-upgrade`   | Executes on an upgrade request after all resources have been upgraded                                 |
| `pre-rollback`   | Executes on a rollback request after templates are rendered, but before any resources are rolled back |
| `post-rollback`  | Executes on a rollback request after all resources have been modified                                 |
| `test`           | Executes when the Helm test subcommand is invoked ([view test docs](/topics/chart_tests.md))              |

_Note that the `crd-install` hook has been removed in favor of the `crds/`
directory in Helm 3._

## Hooks and the Release Lifecycle

Hooks allow you, the chart developer, an opportunity to perform operations at
strategic points in a release lifecycle. For example, consider the lifecycle for
a `helm install`. By default, the lifecycle looks like this:

1. User runs `helm install foo`
2. The Helm library install API is called
3. After some verification, the library renders the `foo` templates
4. The library loads the resulting resources into Kubernetes
5. The library returns the release object (and other data) to the client
6. The client exits

Helm defines two hooks for the `install` lifecycle: `pre-install` and
`post-install`. If the developer of the `foo` chart implements both hooks, the
lifecycle is altered like this:

1. User runs `helm install foo`
2. The Helm library install API is called
3. CRDs in the `crds/` directory are installed
4. After some verification, the library renders the `foo` templates
5. The library prepares to execute the `pre-install` hooks (loading hook
   resources into Kubernetes)
6. The library sorts hooks by weight (assigning a weight of 0 by default), 
   by resource kind and finally by name in ascending order.
7. The library then loads the hook with the lowest weight first (negative to
   positive)
8. The library waits until the hook is "Ready" (except for CRDs)
9. The library loads the resulting resources into Kubernetes. Note that if the
   `--wait` flag is set, the library will wait until all resources are in a
   ready state and will not run the `post-install` hook until they are ready.
10. The library executes the `post-install` hook (loading hook resources)
11. The library waits until the hook is "Ready"
12. The library returns the release object (and other data) to the client
13. The client exits

What does it mean to wait until a hook is ready? This depends on the resource
declared in the hook. If the resource is a `Job` or `Pod` kind, Helm will wait
until it successfully runs to completion. And if the hook fails, the release
will fail. This is a _blocking operation_, so the Helm client will pause while
the Job is run.

For all other kinds, as soon as Kubernetes marks the resource as loaded (added
or updated), the resource is considered "Ready". When many resources are
declared in a hook, the resources are executed serially. If they have hook
weights (see below), they are executed in weighted order. 
Starting from Helm 3.2.0 hook resources with same weight are installed in the same 
order as normal non-hook resources. Otherwise, ordering is
not guaranteed. (In Helm 2.3.0 and after, they are sorted alphabetically. That
behavior, though, is not considered binding and could change in the future.) It
is considered good practice to add a hook weight, and set it to `0` if weight is
not important.

### Hook resources are not managed with corresponding releases

The resources that a hook creates are currently not tracked or managed as part
of the release. Once Helm verifies that the hook has reached its ready state, it
will leave the hook resource alone. Garbage collection of hook resources when
the corresponding release is deleted may be added to Helm 3 in the future, so
any hook resources that must never be deleted should be annotated with
`helm.sh/resource-policy: keep`.

Practically speaking, this means that if you create resources in a hook, you
cannot rely upon `helm uninstall` to remove the resources. To destroy such
resources, you need to either [add a custom `helm.sh/hook-delete-policy`
annotation](#hook-deletion-policies) to the hook template file, or [set the time
to live (TTL) field of a Job
resource](https://kubernetes.io/docs/concepts/workloads/controllers/ttlafterfinished/).

## Writing a Hook

Hooks are just Kubernetes manifest files with special annotations in the
`metadata` section. Because they are template files, you can use all of the
normal template features, including reading `.Values`, `.Release`, and
`.Template`.

For example, this template, stored in `templates/post-install-job.yaml`,
declares a job to be run on `post-install`:

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: "{{ .Release.Name }}"
  labels:
    app.kubernetes.io/managed-by: {{ .Release.Service | quote }}
    app.kubernetes.io/instance: {{ .Release.Name | quote }}
    app.kubernetes.io/version: {{ .Chart.AppVersion }}
    helm.sh/chart: "{{ .Chart.Name }}-{{ .Chart.Version }}"
  annotations:
    # This is what defines this resource as a hook. Without this line, the
    # job is considered part of the release.
    "helm.sh/hook": post-install
    "helm.sh/hook-weight": "-5"
    "helm.sh/hook-delete-policy": hook-succeeded
spec:
  template:
    metadata:
      name: "{{ .Release.Name }}"
      labels:
        app.kubernetes.io/managed-by: {{ .Release.Service | quote }}
        app.kubernetes.io/instance: {{ .Release.Name | quote }}
        helm.sh/chart: "{{ .Chart.Name }}-{{ .Chart.Version }}"
    spec:
      restartPolicy: Never
      containers:
      - name: post-install-job
        image: "alpine:3.3"
        command: ["/bin/sleep","{{ default "10" .Values.sleepyTime }}"]

```

What makes this template a hook is the annotation:

```yaml
annotations:
  "helm.sh/hook": post-install
```

One resource can implement multiple hooks:

```yaml
annotations:
  "helm.sh/hook": post-install,post-upgrade
```

Similarly, there is no limit to the number of different resources that may
implement a given hook. For example, one could declare both a secret and a
config map as a pre-install hook.

When subcharts declare hooks, those are also evaluated. There is no way for a
top-level chart to disable the hooks declared by subcharts.

It is possible to define a weight for a hook which will help build a
deterministic executing order. Weights are defined using the following
annotation:

```yaml
annotations:
  "helm.sh/hook-weight": "5"
```

Hook weights can be positive or negative numbers but must be represented as
strings. When Helm starts the execution cycle of hooks of a particular Kind it
will sort those hooks in ascending order.

### Hook deletion policies

It is possible to define policies that determine when to delete corresponding
hook resources. Hook deletion policies are defined using the following
annotation:

```yaml
annotations:
  "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
```

You can choose one or more defined annotation values:

| Annotation Value       | Description                                                          |
| ---------------------- | -------------------------------------------------------------------- |
| `before-hook-creation` | Delete the previous resource before a new hook is launched (default) |
| `hook-succeeded`       | Delete the resource after the hook is successfully executed          |
| `hook-failed`          | Delete the resource if the hook failed during execution              |

If no hook deletion policy annotation is specified, the `before-hook-creation`
behavior applies by default.
</file>

<file path="topics/charts.mdx">
---
title: Charts
description: Explains the chart format, and provides basic guidance for building charts with Helm.
sidebar_position: 1
---

import Helm4 from "/docs/_v4-in-progress.mdx"

<Helm4/>

Helm uses a packaging format called _charts_. A chart is a collection of files
that describe a related set of Kubernetes resources. A single chart might be
used to deploy something simple, like a memcached pod, or something complex,
like a full web app stack with HTTP servers, databases, caches, and so on.

Charts are created as files laid out in a particular directory tree. They can be
packaged into versioned archives to be deployed.

If you want to download and look at the files for a published chart, without
installing it, you can do so with `helm pull chartrepo/chartname`.

This document explains the chart format, and provides basic guidance for
building charts with Helm.

## The Chart File Structure

A chart is organized as a collection of files inside of a directory. The
directory name is the name of the chart (without versioning information). Thus,
a chart describing WordPress would be stored in a `wordpress/` directory.

Inside of this directory, Helm will expect a structure that matches this:

```text
wordpress/
  Chart.yaml          # A YAML file containing information about the chart
  LICENSE             # OPTIONAL: A plain text file containing the license for the chart
  README.md           # OPTIONAL: A human-readable README file
  values.yaml         # The default configuration values for this chart
  values.schema.json  # OPTIONAL: A JSON Schema for imposing a structure on the values.yaml file
  charts/             # A directory containing any charts upon which this chart depends.
  crds/               # Custom Resource Definitions
  templates/          # A directory of templates that, when combined with values,
                      # will generate valid Kubernetes manifest files.
  templates/NOTES.txt # OPTIONAL: A plain text file containing short usage notes
```

Helm reserves use of the `charts/`, `crds/`, and `templates/` directories, and
of the listed file names. Other files will be left as they are.

## The Chart.yaml File

The `Chart.yaml` file is required for a chart. It contains the following fields:

```yaml
apiVersion: The chart API version (required)
name: The name of the chart (required)
version: The version of the chart (required)
kubeVersion: A SemVer range of compatible Kubernetes versions (optional)
description: A single-sentence description of this project (optional)
type: The type of the chart (optional)
keywords:
  - A list of keywords about this project (optional)
home: The URL of this projects home page (optional)
sources:
  - A list of URLs to source code for this project (optional)
dependencies: # A list of the chart requirements (optional)
  - name: The name of the chart (nginx)
    version: The version of the chart ("1.2.3")
    repository: (optional) The repository URL ("https://example.com/charts") or alias ("@repo-name")
    condition: (optional) A yaml path that resolves to a boolean, used for enabling/disabling charts (e.g. subchart1.enabled )
    tags: # (optional)
      - Tags can be used to group charts for enabling/disabling together
    import-values: # (optional)
      - ImportValues holds the mapping of source values to parent key to be imported. Each item can be a string or pair of child/parent sublist items.
    alias: (optional) Alias to be used for the chart. Useful when you have to add the same chart multiple times
maintainers: # (optional)
  - name: The maintainers name (required for each maintainer)
    email: The maintainers email (optional for each maintainer)
    url: A URL for the maintainer (optional for each maintainer)
icon: A URL to an SVG or PNG image to be used as an icon (optional).
appVersion: The version of the app that this contains (optional). Needn't be SemVer. Quotes recommended.
deprecated: Whether this chart is deprecated (optional, boolean)
annotations:
  example: A list of annotations keyed by name (optional).
```

As of [v3.3.2](https://github.com/helm/helm/releases/tag/v3.3.2), additional
fields are not allowed.
The recommended approach is to add custom metadata in `annotations`.

### Charts and Versioning

Every chart must have a version number. A version should follow the [SemVer
2](https://semver.org/spec/v2.0.0.html) standard but it is not strictly enforced. Unlike Helm Classic, Helm v2
and later uses version numbers as release markers. Packages in repositories are
identified by name plus version.

For example, an `nginx` chart whose version field is set to `version: 1.2.3`
will be named:

```text
nginx-1.2.3.tgz
```

More complex SemVer 2 names are also supported, such as `version:
1.2.3-alpha.1+ef365`. But non-SemVer names are explicitly disallowed by the
system. Subject to exception are versions in format `x` or `x.y`.
For example, if there is a leading v or a version listed without all 3 parts (e.g. v1.2) it will attempt to coerce it into a valid semantic version (e.g., v1.2.0).

**NOTE:** Whereas Helm Classic and Deployment Manager were both very GitHub
oriented when it came to charts, Helm v2 and later does not rely upon or require
GitHub or even Git. Consequently, it does not use Git SHAs for versioning at
all.

The `version` field inside of the `Chart.yaml` is used by many of the Helm
tools, including the CLI. When generating a package, the `helm package` command
will use the version that it finds in the `Chart.yaml` as a token in the package
name. The system assumes that the version number in the chart package name
matches the version number in the `Chart.yaml`. Failure to meet this assumption
will cause an error.

### The `apiVersion` Field

The `apiVersion` field should be `v2` for Helm charts that require at least Helm
3. Charts supporting previous Helm versions have an `apiVersion` set to `v1` and
are still installable by Helm 3.

Changes from `v1` to `v2`:

- A `dependencies` field defining chart dependencies, which were located in a
  separate `requirements.yaml` file for `v1` charts (see [Chart
  Dependencies](#chart-dependencies)).
- The `type` field, discriminating application and library charts (see [Chart
  Types](#chart-types)).

### The `appVersion` Field

Note that the `appVersion` field is not related to the `version` field. It is a
way of specifying the version of the application. For example, the `drupal`
chart may have an `appVersion: "8.2.1"`, indicating that the version of Drupal
included in the chart (by default) is `8.2.1`. This field is informational, and
has no impact on chart version calculations. Wrapping the version in quotes is highly recommended. It forces the YAML parser to treat the version number as a string. Leaving it unquoted can lead to parsing issues in some cases. For example, YAML interprets `1.0` as a floating point value, and a git commit SHA like `1234e10` as scientific notation.

As of Helm v3.5.0, `helm create` wraps the default `appVersion` field in quotes.

### The `kubeVersion` Field

The optional `kubeVersion` field can define semver constraints on supported
Kubernetes versions. Helm will validate the version constraints when installing
the chart and fail if the cluster runs an unsupported Kubernetes version.

Version constraints may comprise space separated AND comparisons such as
```
>= 1.13.0 < 1.15.0
```
which themselves can be combined with the OR `||` operator like in the following
example
```
>= 1.13.0 < 1.14.0 || >= 1.14.1 < 1.15.0
```
In this example the version `1.14.0` is excluded, which can make sense if a bug
in certain versions is known to prevent the chart from running properly.

Apart from version constrains employing operators `=` `!=` `>` `<` `>=` `<=` the
following shorthand notations are supported

 * hyphen ranges for closed intervals, where `1.1 - 2.3.4` is equivalent to `>=
   1.1 <= 2.3.4`.
 * wildcards `x`, `X` and `*`, where `1.2.x` is equivalent to `>= 1.2.0 <
   1.3.0`.
 * tilde ranges (patch version changes allowed), where `~1.2.3` is equivalent to
   `>= 1.2.3 < 1.3.0`.
 * caret ranges (minor version changes allowed), where `^1.2.3` is equivalent to
   `>= 1.2.3 < 2.0.0`.

For a detailed explanation of supported semver constraints see
[Masterminds/semver](https://github.com/Masterminds/semver).

### Deprecating Charts

When managing charts in a Chart Repository, it is sometimes necessary to
deprecate a chart. The optional `deprecated` field in `Chart.yaml` can be used
to mark a chart as deprecated. If the **latest** version of a chart in the
repository is marked as deprecated, then the chart as a whole is considered to
be deprecated. The chart name can be later reused by publishing a newer version
that is not marked as deprecated. The workflow for deprecating charts is:

1. Update chart's `Chart.yaml` to mark the chart as deprecated, bumping the
   version
2. Release the new chart version in the Chart Repository
3. Remove the chart from the source repository (e.g. git)

### Chart Types

The `type` field defines the type of chart. There are two types: `application`
and `library`. Application is the default type and it is the standard chart
which can be operated on fully. The [library chart](/topics/library_charts.md) provides utilities or functions for the
chart builder. A library chart differs from an application chart because it is
not installable and usually doesn't contain any resource objects.

**Note:** An application chart can be used as a library chart. This is enabled
by setting the type to `library`. The chart will then be rendered as a library
chart where all utilities and functions can be leveraged. All resource objects
of the chart will not be rendered.

## Chart LICENSE, README and NOTES

Charts can also contain files that describe the installation, configuration,
usage and license of a chart.

A LICENSE is a plain text file containing the
[license](https://en.wikipedia.org/wiki/Software_license) for the chart. The
chart can contain a license as it may have programming logic in the templates
and would therefore not be configuration only. There can also be separate
license(s) for the application installed by the chart, if required.

A README for a chart should be formatted in Markdown (README.md), and should
generally contain:

- A description of the application or service the chart provides
- Any prerequisites or requirements to run the chart
- Descriptions of options in `values.yaml` and default values
- Any other information that may be relevant to the installation or
  configuration of the chart

When hubs and other user interfaces display details about a chart that detail is
pulled from the content in the `README.md` file.

The chart can also contain a short plain text `templates/NOTES.txt` file that
will be printed out after installation, and when viewing the status of a
release. This file is evaluated as a [template](#templates-and-values), and can
be used to display usage notes, next steps, or any other information relevant to
a release of the chart. For example, instructions could be provided for
connecting to a database, or accessing a web UI. Since this file is printed to
STDOUT when running `helm install` or `helm status`, it is recommended to keep
the content brief and point to the README for greater detail.

## Chart Dependencies

In Helm, one chart may depend on any number of other charts. These dependencies
can be dynamically linked using the `dependencies` field in `Chart.yaml` or
brought in to the `charts/` directory and managed manually.

### Managing Dependencies with the `dependencies` field

The charts required by the current chart are defined as a list in the
`dependencies` field.

```yaml
dependencies:
  - name: apache
    version: 1.2.3
    repository: https://example.com/charts
  - name: mysql
    version: 3.2.1
    repository: https://another.example.com/charts
```

- The `name` field is the name of the chart you want.
- The `version` field is the version of the chart you want.
- The `repository` field is the full URL to the chart repository. Note that you
  must also use `helm repo add` to add that repo locally.
- You might use the name of the repo instead of URL

```console
$ helm repo add fantastic-charts https://charts.helm.sh/incubator
```

```yaml
dependencies:
  - name: awesomeness
    version: 1.0.0
    repository: "@fantastic-charts"
```

Once you have defined dependencies, you can run `helm dependency update` and it
will use your dependency file to download all the specified charts into your
`charts/` directory for you.

```console
$ helm dep up foochart
Hang tight while we grab the latest from your chart repositories...
...Successfully got an update from the "local" chart repository
...Successfully got an update from the "stable" chart repository
...Successfully got an update from the "example" chart repository
...Successfully got an update from the "another" chart repository
Update Complete. Happy Helming!
Saving 2 charts
Downloading apache from repo https://example.com/charts
Downloading mysql from repo https://another.example.com/charts
```

When `helm dependency update` retrieves charts, it will store them as chart
archives in the `charts/` directory. So for the example above, one would expect
to see the following files in the charts directory:

```text
charts/
  apache-1.2.3.tgz
  mysql-3.2.1.tgz
```

#### Alias field in dependencies

In addition to the other fields above, each requirements entry may contain the
optional field `alias`.

Adding an alias for a dependency chart would put a chart in dependencies using
alias as name of new dependency.

One can use `alias` in cases where they need to access a chart with other
name(s).

```yaml
# parentchart/Chart.yaml

dependencies:
  - name: subchart
    repository: http://localhost:10191
    version: 0.1.0
    alias: new-subchart-1
  - name: subchart
    repository: http://localhost:10191
    version: 0.1.0
    alias: new-subchart-2
  - name: subchart
    repository: http://localhost:10191
    version: 0.1.0
```

In the above example we will get 3 dependencies in all for `parentchart`:

```text
subchart
new-subchart-1
new-subchart-2
```

The manual way of achieving this is by copy/pasting the same chart in the
`charts/` directory multiple times with different names.

#### Tags and Condition fields in dependencies

In addition to the other fields above, each requirements entry may contain the
optional fields `tags` and `condition`.

All charts are loaded by default. If `tags` or `condition` fields are present,
they will be evaluated and used to control loading for the chart(s) they are
applied to.

Condition - The condition field holds one or more YAML paths (delimited by
commas). If this path exists in the top parent's values and resolves to a
boolean value, the chart will be enabled or disabled based on that boolean
value.  Only the first valid path found in the list is evaluated and if no paths
exist then the condition has no effect.

Tags - The tags field is a YAML list of labels to associate with this chart. In
the top parent's values, all charts with tags can be enabled or disabled by
specifying the tag and a boolean value.

```yaml
# parentchart/Chart.yaml

dependencies:
  - name: subchart1
    repository: http://localhost:10191
    version: 0.1.0
    condition: subchart1.enabled,global.subchart1.enabled
    tags:
      - front-end
      - subchart1
  - name: subchart2
    repository: http://localhost:10191
    version: 0.1.0
    condition: subchart2.enabled,global.subchart2.enabled
    tags:
      - back-end
      - subchart2
```

```yaml
# parentchart/values.yaml

subchart1:
  enabled: true
tags:
  front-end: false
  back-end: true
```

In the above example all charts with the tag `front-end` would be disabled but
since the `subchart1.enabled` path evaluates to 'true' in the parent's values,
the condition will override the `front-end` tag and `subchart1` will be enabled.

Since `subchart2` is tagged with `back-end` and that tag evaluates to `true`,
`subchart2` will be enabled. Also note that although `subchart2` has a condition
specified, there is no corresponding path and value in the parent's values so
that condition has no effect.

##### Using the CLI with Tags and Conditions

The `--set` parameter can be used as usual to alter tag and condition values.

```console
helm install --set tags.front-end=true --set subchart2.enabled=false
```

##### Tags and Condition Resolution

- **Conditions (when set in values) always override tags.** The first condition
  path that exists wins and subsequent ones for that chart are ignored.
- Tags are evaluated as 'if any of the chart's tags are true then enable the
  chart'.
- Tags and conditions values must be set in the top parent's values.
- The `tags:` key in values must be a top level key. Globals and nested `tags:`
  tables are not currently supported.

#### Importing Child Values via dependencies

In some cases it is desirable to allow a child chart's values to propagate to
the parent chart and be shared as common defaults. An additional benefit of
using the `exports` format is that it will enable future tooling to introspect
user-settable values.

The keys containing the values to be imported can be specified in the parent
chart's `dependencies` in the field `import-values` using a YAML list. Each item
in the list is a key which is imported from the child chart's `exports` field.

To import values not contained in the `exports` key, use the
[child-parent](#using-the-child-parent-format) format. Examples of both formats
are described below.

##### Using the exports format

If a child chart's `values.yaml` file contains an `exports` field at the root,
its contents may be imported directly into the parent's values by specifying the
keys to import as in the example below:

```yaml
# parent's Chart.yaml file

dependencies:
  - name: subchart
    repository: http://localhost:10191
    version: 0.1.0
    import-values:
      - data
```

```yaml
# child's values.yaml file

exports:
  data:
    myint: 99
```

Since we are specifying the key `data` in our import list, Helm looks in the
`exports` field of the child chart for `data` key and imports its contents.

The final parent values would contain our exported field:

```yaml
# parent's values

myint: 99
```

Please note the parent key `data` is not contained in the parent's final values.
If you need to specify the parent key, use the 'child-parent' format.

##### Using the child-parent format

To access values that are not contained in the `exports` key of the child
chart's values, you will need to specify the source key of the values to be
imported (`child`) and the destination path in the parent chart's values
(`parent`).

The `import-values` in the example below instructs Helm to take any values found
at `child:` path and copy them to the parent's values at the path specified in
`parent:`

```yaml
# parent's Chart.yaml file

dependencies:
  - name: subchart1
    repository: http://localhost:10191
    version: 0.1.0
    ...
    import-values:
      - child: default.data
        parent: myimports
```

In the above example, values found at `default.data` in the subchart1's values
will be imported to the `myimports` key in the parent chart's values as detailed
below:

```yaml
# parent's values.yaml file

myimports:
  myint: 0
  mybool: false
  mystring: "helm rocks!"
```

```yaml
# subchart1's values.yaml file

default:
  data:
    myint: 999
    mybool: true
```

The parent chart's resulting values would be:

```yaml
# parent's final values

myimports:
  myint: 999
  mybool: true
  mystring: "helm rocks!"
```

The parent's final values now contains the `myint` and `mybool` fields imported
from subchart1.

### Managing Dependencies manually via the `charts/` directory

If more control over dependencies is desired, these dependencies can be
expressed explicitly by copying the dependency charts into the `charts/`
directory.

A dependency should be an unpacked chart directory but its name cannot start 
with `_` or `.`. Such files are ignored by the chart loader.

For example, if the WordPress chart depends on the Apache chart, the Apache
chart (of the correct version) is supplied in the WordPress chart's `charts/`
directory:

```yaml
wordpress:
  Chart.yaml
  # ...
  charts/
    apache/
      Chart.yaml
      # ...
    mysql/
      Chart.yaml
      # ...
```

The example above shows how the WordPress chart expresses its dependency on
Apache and MySQL by including those charts inside of its `charts/` directory.

**TIP:** _To drop a dependency into your `charts/` directory, use the `helm
pull` command_

### Operational aspects of using dependencies

The above sections explain how to specify chart dependencies, but how does this
affect chart installation using `helm install` and `helm upgrade`?

Suppose that a chart named "A" creates the following Kubernetes objects

- namespace "A-Namespace"
- statefulset "A-StatefulSet"
- service "A-Service"

Furthermore, A is dependent on chart B that creates objects

- namespace "B-Namespace"
- replicaset "B-ReplicaSet"
- service "B-Service"

After installation/upgrade of chart A a single Helm release is created/modified.
The release will create/update all of the above Kubernetes objects in the
following order:

- A-Namespace
- B-Namespace
- A-Service
- B-Service
- B-ReplicaSet
- A-StatefulSet

This is because when Helm installs/upgrades charts, the Kubernetes objects from
the charts and all its dependencies are

- aggregated into a single set; then
- sorted by type followed by name; and then
- created/updated in that order.

Hence a single release is created with all the objects for the chart and its
dependencies.

The install order of Kubernetes types is given by the enumeration InstallOrder
in kind_sorter.go (see [the Helm source
file](https://github.com/helm/helm/blob/484d43913f97292648c867b56768775a55e4bba6/pkg/releaseutil/kind_sorter.go)).

## Templates and Values

Helm Chart templates are written in the [Go template
language](https://golang.org/pkg/text/template/), with the addition of 50 or so
add-on template functions [from the Sprig
library](https://github.com/Masterminds/sprig) and a few other [specialized
functions](/howto/charts_tips_and_tricks.md).

All template files are stored in a chart's `templates/` folder. When Helm
renders the charts, it will pass every file in that directory through the
template engine.

Values for the templates are supplied two ways:

- Chart developers may supply a file called `values.yaml` inside of a chart.
  This file can contain default values.
- Chart users may supply a YAML file that contains values. This can be provided
  on the command line with `helm install`.

When a user supplies custom values, these values will override the values in the
chart's `values.yaml` file.

### Template Files

Template files follow the standard conventions for writing Go templates (see
[the text/template Go package
documentation](https://golang.org/pkg/text/template/) for details). An example
template file might look something like this:

```yaml
apiVersion: v1
kind: ReplicationController
metadata:
  name: deis-database
  namespace: deis
  labels:
    app.kubernetes.io/managed-by: deis
spec:
  replicas: 1
  selector:
    app.kubernetes.io/name: deis-database
  template:
    metadata:
      labels:
        app.kubernetes.io/name: deis-database
    spec:
      serviceAccount: deis-database
      containers:
        - name: deis-database
          image: {{ .Values.imageRegistry }}/postgres:{{ .Values.dockerTag }}
          imagePullPolicy: {{ .Values.pullPolicy }}
          ports:
            - containerPort: 5432
          env:
            - name: DATABASE_STORAGE
              value: {{ default "minio" .Values.storage }}
```

The above example, based loosely on
[https://github.com/deis/charts](https://github.com/deis/charts), is a template
for a Kubernetes replication controller. It can use the following four template
values (usually defined in a `values.yaml` file):

- `imageRegistry`: The source registry for the Docker image.
- `dockerTag`: The tag for the docker image.
- `pullPolicy`: The Kubernetes pull policy.
- `storage`: The storage backend, whose default is set to `"minio"`

All of these values are defined by the template author. Helm does not require or
dictate parameters.

To see many working charts, check out the CNCF [Artifact
Hub](https://artifacthub.io/packages/search?kind=0).

### Predefined Values

Values that are supplied via a `values.yaml` file (or via the `--set` flag) are
accessible from the `.Values` object in a template. But there are other
pre-defined pieces of data you can access in your templates.

The following values are pre-defined, are available to every template, and
cannot be overridden. As with all values, the names are _case sensitive_.

- `Release.Name`: The name of the release (not the chart)
- `Release.Namespace`: The namespace the chart was released to.
- `Release.Service`: The service that conducted the release.
- `Release.IsUpgrade`: This is set to true if the current operation is an
  upgrade or rollback.
- `Release.IsInstall`: This is set to true if the current operation is an
  install.
- `Chart`: The contents of the `Chart.yaml`. Thus, the chart version is
  obtainable as `Chart.Version` and the maintainers are in `Chart.Maintainers`.
- `Files`: A map-like object containing all non-special files in the chart. This
  will not give you access to templates, but will give you access to additional
  files that are present (unless they are excluded using `.helmignore`). Files
  can be accessed using `{{ index .Files "file.name" }}` or using the
  `{{.Files.Get name }}` function. You can also access the contents of the file
  as `[]byte` using `{{ .Files.GetBytes }}`
- `Capabilities`: A map-like object that contains information about the versions
  of Kubernetes (`{{ .Capabilities.KubeVersion }}`) and the supported Kubernetes
  API versions (`{{ .Capabilities.APIVersions.Has "batch/v1" }}`)

**NOTE:** Any unknown `Chart.yaml` fields will be dropped. They will not be
accessible inside of the `Chart` object. Thus, `Chart.yaml` cannot be used to
pass arbitrarily structured data into the template. The values file can be used
for that, though.

### Values files

Considering the template in the previous section, a `values.yaml` file that
supplies the necessary values would look like this:

```yaml
imageRegistry: "quay.io/deis"
dockerTag: "latest"
pullPolicy: "Always"
storage: "s3"
```

A values file is formatted in YAML. A chart may include a default `values.yaml`
file. The Helm install command allows a user to override values by supplying
additional YAML values:

```console
$ helm install --generate-name --values=myvals.yaml wordpress
```

When values are passed in this way, they will be merged into the default values
file. For example, consider a `myvals.yaml` file that looks like this:

```yaml
storage: "gcs"
```

When this is merged with the `values.yaml` in the chart, the resulting generated
content will be:

```yaml
imageRegistry: "quay.io/deis"
dockerTag: "latest"
pullPolicy: "Always"
storage: "gcs"
```

Note that only the last field was overridden.

**NOTE:** The default values file included inside of a chart _must_ be named
`values.yaml`. But files specified on the command line can be named anything.

**NOTE:** If the `--set` flag is used on `helm install` or `helm upgrade`, those
values are simply converted to YAML on the client side.

**NOTE:** If any required entries in the values file exist, they can be declared
as required in the chart template by using the ['required' function](/howto/charts_tips_and_tricks.md)

Any of these values are then accessible inside of templates using the `.Values`
object:

```yaml
apiVersion: v1
kind: ReplicationController
metadata:
  name: deis-database
  namespace: deis
  labels:
    app.kubernetes.io/managed-by: deis
spec:
  replicas: 1
  selector:
    app.kubernetes.io/name: deis-database
  template:
    metadata:
      labels:
        app.kubernetes.io/name: deis-database
    spec:
      serviceAccount: deis-database
      containers:
        - name: deis-database
          image: {{ .Values.imageRegistry }}/postgres:{{ .Values.dockerTag }}
          imagePullPolicy: {{ .Values.pullPolicy }}
          ports:
            - containerPort: 5432
          env:
            - name: DATABASE_STORAGE
              value: {{ default "minio" .Values.storage }}
```

### Scope, Dependencies, and Values

Values files can declare values for the top-level chart, as well as for any of
the charts that are included in that chart's `charts/` directory. Or, to phrase
it differently, a values file can supply values to the chart as well as to any
of its dependencies. For example, the demonstration WordPress chart above has
both `mysql` and `apache` as dependencies. The values file could supply values
to all of these components:

```yaml
title: "My WordPress Site" # Sent to the WordPress template

mysql:
  max_connections: 100 # Sent to MySQL
  password: "secret"

apache:
  port: 8080 # Passed to Apache
```

Charts at a higher level have access to all of the variables defined beneath. So
the WordPress chart can access the MySQL password as `.Values.mysql.password`.
But lower level charts cannot access things in parent charts, so MySQL will not
be able to access the `title` property. Nor, for that matter, can it access
`apache.port`.

Values are namespaced, but namespaces are pruned. So for the WordPress chart, it
can access the MySQL password field as `.Values.mysql.password`. But for the
MySQL chart, the scope of the values has been reduced and the namespace prefix
removed, so it will see the password field simply as `.Values.password`.

#### Global Values

As of 2.0.0-Alpha.2, Helm supports special "global" value. Consider this
modified version of the previous example:

```yaml
title: "My WordPress Site" # Sent to the WordPress template

global:
  app: MyWordPress

mysql:
  max_connections: 100 # Sent to MySQL
  password: "secret"

apache:
  port: 8080 # Passed to Apache
```

The above adds a `global` section with the value `app: MyWordPress`. This value
is available to _all_ charts as `.Values.global.app`.

For example, the `mysql` templates may access `app` as `{{
.Values.global.app}}`, and so can the `apache` chart. Effectively, the values
file above is regenerated like this:

```yaml
title: "My WordPress Site" # Sent to the WordPress template

global:
  app: MyWordPress

mysql:
  global:
    app: MyWordPress
  max_connections: 100 # Sent to MySQL
  password: "secret"

apache:
  global:
    app: MyWordPress
  port: 8080 # Passed to Apache
```

This provides a way of sharing one top-level variable with all subcharts, which
is useful for things like setting `metadata` properties like labels.

If a subchart declares a global variable, that global will be passed _downward_
(to the subchart's subcharts), but not _upward_ to the parent chart. There is no
way for a subchart to influence the values of the parent chart.

Also, global variables of parent charts take precedence over the global
variables from subcharts.

### Schema Files

Sometimes, a chart maintainer might want to define a structure on their values.
This can be done by defining a schema in the `values.schema.json` file. A schema
is represented as a [JSON Schema](https://json-schema.org/). It might look
something like this:

```json
{
  "$schema": "https://json-schema.org/draft-07/schema#",
  "properties": {
    "image": {
      "description": "Container Image",
      "properties": {
        "repo": {
          "type": "string"
        },
        "tag": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "name": {
      "description": "Service name",
      "type": "string"
    },
    "port": {
      "description": "Port",
      "minimum": 0,
      "type": "integer"
    },
    "protocol": {
      "type": "string"
    }
  },
  "required": [
    "protocol",
    "port"
  ],
  "title": "Values",
  "type": "object"
}
```

This schema will be applied to the values to validate it. Validation occurs when
any of the following commands are invoked:

- `helm install`
- `helm upgrade`
- `helm lint`
- `helm template`

An example of a `values.yaml` file that meets the requirements of this schema
might look something like this:

```yaml
name: frontend
protocol: https
port: 443
```

Note that the schema is applied to the final `.Values` object, and not just to
the `values.yaml` file. This means that the following `yaml` file is valid,
given that the chart is installed with the appropriate `--set` option shown
below.

```yaml
name: frontend
protocol: https
```

```console
helm install --set port=443
```

Furthermore, the final `.Values` object is checked against *all* subchart
schemas. This means that restrictions on a subchart can't be circumvented by a
parent chart. This also works backwards - if a subchart has a requirement that
is not met in the subchart's `values.yaml` file, the parent chart *must* satisfy
those restrictions in order to be valid.

Schema validation can be disabled by setting the option shown below.
This is particularly useful in air-gapped environments when a chart's JSON Schema file contains remote references.
```console
helm install --skip-schema-validation
```

### References

When it comes to writing templates, values, and schema files, there are several
standard references that will help you out.

- [Go templates](https://godoc.org/text/template)
- [Extra template functions](https://godoc.org/github.com/Masterminds/sprig)
- [The YAML format](https://yaml.org/spec/)
- [JSON Schema](https://json-schema.org/)

## Custom Resource Definitions (CRDs)

Kubernetes provides a mechanism for declaring new types of Kubernetes objects.
Using CustomResourceDefinitions (CRDs), Kubernetes developers can declare custom
resource types.

In Helm 3, CRDs are treated as a special kind of object. They are installed
before the rest of the chart, and are subject to some limitations.

CRD YAML files should be placed in the `crds/` directory inside of a chart.
Multiple CRDs (separated by YAML start and end markers) may be placed in the
same file. Helm will attempt to load _all_ of the files in the CRD directory
into Kubernetes.

CRD files _cannot be templated_. They must be plain YAML documents.

When Helm installs a new chart, it will upload the CRDs, pause until the CRDs
are made available by the API server, and then start the template engine, render
the rest of the chart, and upload it to Kubernetes. Because of this ordering,
CRD information is available in the `.Capabilities` object in Helm templates,
and Helm templates may create new instances of objects that were declared in
CRDs.

For example, if your chart had a CRD for `CronTab` in the `crds/` directory, you
may create instances of the `CronTab` kind in the `templates/` directory:

```text
crontabs/
  Chart.yaml
  crds/
    crontab.yaml
  templates/
    mycrontab.yaml
```

The `crontab.yaml` file must contain the CRD with no template directives:

```yaml
kind: CustomResourceDefinition
metadata:
  name: crontabs.stable.example.com
spec:
  group: stable.example.com
  versions:
    - name: v1
      served: true
      storage: true
  scope: Namespaced
  names:
    plural: crontabs
    singular: crontab
    kind: CronTab
```

Then the template `mycrontab.yaml` may create a new `CronTab` (using templates
as usual):

```yaml
apiVersion: stable.example.com
kind: CronTab
metadata:
  name: {{ .Values.name }}
spec:
   # ...
```

Helm will make sure that the `CronTab` kind has been installed and is available
from the Kubernetes API server before it proceeds installing the things in
`templates/`.

### Limitations on CRDs

Unlike most objects in Kubernetes, CRDs are installed globally. For that reason,
Helm takes a very cautious approach in managing CRDs. CRDs are subject to the
following limitations:

- CRDs are never reinstalled. If Helm determines that the CRDs in the `crds/`
  directory are already present (regardless of version), Helm will not attempt
  to install or upgrade.
- CRDs are never installed on upgrade or rollback. Helm will only create CRDs on
  installation operations.
- CRDs are never deleted. Deleting a CRD automatically deletes all of the CRD's
  contents across all namespaces in the cluster. Consequently, Helm will not
  delete CRDs.

Operators who want to upgrade or delete CRDs are encouraged to do this manually
and with great care.

## Using Helm to Manage Charts

The `helm` tool has several commands for working with charts.

It can create a new chart for you:

```console
$ helm create mychart
Created mychart/
```

Once you have edited a chart, `helm` can package it into a chart archive for
you:

```console
$ helm package mychart
Archived mychart-0.1.-.tgz
```

You can also use `helm` to help you find issues with your chart's formatting or
information:

```console
$ helm lint mychart
No issues found
```

## Chart Repositories

A _chart repository_ is an HTTP server that houses one or more packaged charts.
While `helm` can be used to manage local chart directories, when it comes to
sharing charts, the preferred mechanism is a chart repository.

Any HTTP server that can serve YAML files and tar files and can answer GET
requests can be used as a repository server. The Helm team has tested some
servers, including Google Cloud Storage with website mode enabled, and S3 with
website mode enabled.

A repository is characterized primarily by the presence of a special file called
`index.yaml` that has a list of all of the packages supplied by the repository,
together with metadata that allows retrieving and verifying those packages.

On the client side, repositories are managed with the `helm repo` commands.
However, Helm does not provide tools for uploading charts to remote repository
servers. This is because doing so would add substantial requirements to an
implementing server, and thus raise the barrier for setting up a repository.

## Chart Starter Packs

The `helm create` command takes an optional `--starter` option that lets you
specify a "starter chart". Also, the starter option has a short alias `-p`.

Examples of usage:

```console
helm create my-chart --starter starter-name
helm create my-chart -p starter-name
helm create my-chart -p /absolute/path/to/starter-name
```

Starters are just regular charts, but are located in
`$XDG_DATA_HOME/helm/starters`. As a chart developer, you may author charts that
are specifically designed to be used as starters. Such charts should be designed
with the following considerations in mind:

- The `Chart.yaml` will be overwritten by the generator.
- Users will expect to modify such a chart's contents, so documentation should
  indicate how users can do so.
- All occurrences of `<CHARTNAME>` will be replaced with the specified chart name so that starter charts can be used as templates, except for some variable files. For example, if you use custom files in the `vars` directory or certain `README.md` files, `<CHARTNAME>` will NOT override inside them. Additionally, the chart description is not inherited.

Currently the only way to add a chart to `$XDG_DATA_HOME/helm/starters` is to
manually copy it there. In your chart's documentation, you may want to explain
that process.
</file>

<file path="topics/index.mdx">
---
title: Topics
sidebar_position: 3
---

# Topic Guides

Here youâ€™ll find introductions to all the key parts of Helm youâ€™ll need or want
to know.


import DocCardList from '@theme/DocCardList';

<DocCardList />
</file>

<file path="topics/kubernetes_apis.md">
---
title: Deprecated Kubernetes APIs
description: Explains deprecated Kubernetes APIs in Helm
---

Kubernetes is an API-driven system and the API evolves over time to reflect the
evolving understanding of the problem space. This is common practice across
systems and their APIs. An important part of evolving APIs is a good deprecation
policy and process to inform users of how changes to APIs are implemented. In
other words, consumers of your API need to know in advance and in what release
an API will be removed or changed. This removes the element of surprise and
breaking changes to consumers.

The [Kubernetes deprecation
policy](https://kubernetes.io/docs/reference/using-api/deprecation-policy/)
documents how Kubernetes handles the changes to its API versions. The policy for
deprecation states the timeframe that API versions will be supported following a
deprecation announcement. It is therefore important to be aware of deprecation
announcements and know when API versions will be removed, to help minimize the
effect.

This is an example of an announcement [for the removal of deprecated API
versions in Kubernetes
1.16](https://kubernetes.io/blog/2019/07/18/api-deprecations-in-1-16/) and was
advertised a few months prior to the release. These API versions would have been
announced for deprecation prior to this again. This shows that there is a good
policy in place which informs consumers of API version support.

Helm templates specify a [Kubernetes API
group](https://kubernetes.io/docs/concepts/overview/kubernetes-api/#api-groups)
when defining a Kubernetes object, similar to a Kubernetes manifest file. It is
specified in the `apiVersion` field of the template and it identifies the API
version of the Kubernetes object. This means that Helm users and chart
maintainers need to be aware when Kubernetes API versions have been deprecated
and in what Kubernetes version they will be removed.

## Chart Maintainers

You should audit your charts checking for Kubernetes API versions that are
deprecated or are removed in a Kubernetes version. The API versions found as due
to be or that are now out of support, should be updated to the supported version
and a new version of the chart released. The API version is defined by the
`kind` and `apiVersion` fields. For example, here is a removed `Deployment`
object API version in Kubernetes 1.16:

```yaml
apiVersion: apps/v1beta1
kind: Deployment
```

## Helm Users

You should audit the charts that you use (similar to [chart
maintainers](#chart-maintainers)) and identify any charts where API versions are
deprecated or removed in a Kubernetes version. For the charts identified, you
need to check for the latest version of the chart (which has supported API
versions) or update the chart yourself.

Additionally, you also need to audit any charts deployed (i.e. Helm releases)
checking again for any deprecated or removed API versions. This can be done by
getting details of a release using the `helm get manifest` command.

The means for updating a Helm release to supported APIs depends on your findings
as follows:

1. If you find deprecated API versions only then:
  - Perform a `helm upgrade` with a version of the chart with supported
    Kubernetes API versions
  - Add a description in the upgrade, something along the lines to not perform a
    rollback to a Helm version prior to this current version
2.  If you find any API version(s) that is/are removed in a Kubernetes version
    then:
  - If you are running a Kubernetes version where the API version(s) are still
    available (for example, you are on Kubernetes 1.15 and found you use APIs
    that will be removed in Kubernetes 1.16):
    - Follow the step 1 procedure
  - Otherwise (for example, you are already running a Kubernetes version where
    some API versions reported by `helm get manifest` are no longer available):
    - You need to edit the release manifest that is stored in the cluster to
      update the API versions to supported APIs. See [Updating API Versions of a
      Release Manifest](#updating-api-versions-of-a-release-manifest) for more
      details

> Note: In all cases of updating a Helm release with supported APIs, you should
never rollback the release to a version prior to the release version with the
supported APIs.

> Recommendation: The best practice is to upgrade releases using deprecated API
versions to supported API versions, prior to upgrading to a kubernetes cluster
that removes those API versions.

If you don't update a release as suggested previously, you will have an error
similar to the following when trying to upgrade a release in a Kubernetes
version where its API version(s) is/are removed:

```
Error: UPGRADE FAILED: current release manifest contains removed kubernetes api(s)
for this kubernetes version and it is therefore unable to build the kubernetes
objects for performing the diff. error from kubernetes: unable to recognize "":
no matches for kind "Deployment" in version "apps/v1beta1"
```

Helm fails in this scenario because it attempts to create a diff patch between
the current deployed release (which contains the Kubernetes APIs that are
removed in this Kubernetes version) against the chart you are passing with the
updated/supported API versions. The underlying reason for failure is that when
Kubernetes removes an API version, the Kubernetes Go client library can no
longer parse the deprecated objects and Helm therefore fails when calling the
library. Helm unfortunately is unable to recover from this situation and is no
longer able to manage such a release. See [Updating API Versions of a Release
Manifest](#updating-api-versions-of-a-release-manifest) for more details on how
to recover from this scenario.

## Updating API Versions of a Release Manifest

The manifest is a property of the Helm release object which is stored in the
data field of a Secret (default) or ConfigMap in the cluster. The data field
contains a gzipped object which is base 64 encoded (there is an additional base
64 encoding for a Secret). There is a Secret/ConfigMap per release
version/revision in the namespace of the release.

You can use the Helm [mapkubeapis](https://github.com/helm/helm-mapkubeapis)
plugin to perform the update of a release to supported APIs. Check out the
readme for more details.

Alternatively, you can follow these manual steps to perform an update of the API
versions of a release manifest. Depending on your configuration you will follow
the steps for the Secret or ConfigMap backend.

- Get the name of the Secret or Configmap associated with the latest deployed
  release:
  - Secrets backend: `kubectl get secret -l
    owner=helm,status=deployed,name=<release_name> --namespace
    <release_namespace> | awk '{print $1}' | grep -v NAME`
  - ConfigMap backend: `kubectl get configmap -l
    owner=helm,status=deployed,name=<release_name> --namespace
    <release_namespace> | awk '{print $1}' | grep -v NAME`
- Get latest deployed release details:
  - Secrets backend: `kubectl get secret <release_secret_name> -n
    <release_namespace> -o yaml > release.yaml`
  - ConfigMap backend: `kubectl get configmap <release_configmap_name> -n
    <release_namespace> -o yaml > release.yaml`
- Backup the release in case you need to restore if something goes wrong:
  - `cp release.yaml release.bak`
  - In case of emergency, restore: `kubectl apply -f release.bak -n
    <release_namespace>`
- Decode the release object:
  - Secrets backend:`cat release.yaml | grep -oP '(?<=release: ).*' | base64 -d
    | base64 -d | gzip -d > release.data.decoded`
  - ConfigMap backend: `cat release.yaml | grep -oP '(?<=release: ).*' | base64
    -d | gzip -d > release.data.decoded`
- Change API versions of the manifests. Can use any tool (e.g. editor) to make
  the changes. This is in the `manifest` field of your decoded release object
  (`release.data.decoded`)
- Encode the release object:
  - Secrets backend: `cat release.data.decoded | gzip | base64 | base64`
  - ConfigMap backend: `cat release.data.decoded | gzip | base64`
- Replace `data.release` property value in the deployed release file
  (`release.yaml`) with the new encoded release object
- Apply file to namespace: `kubectl apply -f release.yaml -n
  <release_namespace>`
- Perform a `helm upgrade` with a version of the chart with supported Kubernetes
  API versions
- Add a description in the upgrade, something along the lines to not perform a
  rollback to a Helm version prior to this current version
</file>

<file path="topics/kubernetes_distros.md">
---
title: Kubernetes Distribution Guide
description: Captures information about using Helm in specific Kubernetes environments.
sidebar_position: 10
---

Helm should work with any [conformant version of
Kubernetes](https://github.com/cncf/k8s-conformance) (whether
[certified](https://www.cncf.io/certification/software-conformance/) or not).

This document captures information about using Helm in specific Kubernetes
environments. Please contribute more details about any distros (sorted
alphabetically) if desired.


## AKS

Helm works with [Azure Kubernetes
Service](https://docs.microsoft.com/en-us/azure/aks/kubernetes-helm).

## DC/OS

Helm has been tested and is working on Mesospheres DC/OS 1.11 Kubernetes
platform, and requires no additional configuration.

## EKS

Helm works with Amazon Elastic Kubernetes Service (Amazon EKS):
[Using Helm with Amazon
EKS](https://docs.aws.amazon.com/eks/latest/userguide/helm.html).

## GKE

Google's GKE hosted Kubernetes platform is known to work with Helm, and requires
no additional configuration.

## `scripts/local-cluster` and Hyperkube

Hyperkube configured via `scripts/local-cluster.sh` is known to work. For raw
Hyperkube you may need to do some manual configuration.

## IKS

Helm works with [IBM Cloud Kubernetes
Service](https://cloud.ibm.com/docs/containers?topic=containers-helm).

## KIND (Kubernetes IN Docker)

Helm is regularly tested on [KIND](https://github.com/kubernetes-sigs/kind).

## KubeOne

Helm works in clusters that are set up by KubeOne without caveats.

## Kubermatic

Helm works in user clusters that are created by Kubermatic without caveats.
Since seed cluster can be set up in different ways Helm support depends on their
configuration.

## MicroK8s

Helm can be enabled in [MicroK8s](https://microk8s.io) using the command:
`microk8s.enable helm3`

## Minikube

Helm is tested and known to work with
[Minikube](https://github.com/kubernetes/minikube). It requires no additional
configuration.

## Openshift

Helm works straightforward on OpenShift Online, OpenShift Dedicated, OpenShift
Container Platform (version >= 3.6) or OpenShift Origin (version >= 3.6). To
learn more read [this
blog](https://blog.openshift.com/getting-started-helm-openshift/) post.

## Platform9

Helm is pre-installed with [Platform9 Managed
Kubernetes](https://platform9.com/managed-kubernetes/?utm_source=helm_distro_notes).
Platform9 provides access to all official Helm charts through the App Catalog UI
and native Kubernetes CLI. Additional repositories can be manually added.
Further details are available in this [Platform9 App Catalog
article](https://platform9.com/support/deploying-kubernetes-apps-platform9-managed-kubernetes/?utm_source=helm_distro_notes).

## Ubuntu with `kubeadm`

Kubernetes bootstrapped with `kubeadm` is known to work on the following Linux
distributions:

- Ubuntu 16.04
- Fedora release 25

Some versions of Helm (v2.0.0-beta2) require you to `export
KUBECONFIG=/etc/kubernetes/admin.conf` or create a `~/.kube/config`.

## VMware Tanzu Kubernetes Grid

Helm runs on VMware Tanzu Kubernetes Grid, TKG, without needing configuration changes.
The Tanzu CLI can manage installing packages for [helm-controller](https://fluxcd.io/flux/components/helm/) allowing for declaratively managing Helm chart releases.
Further details available in the TKG documentation for [CLI-Managed Packages](https://docs.vmware.com/en/VMware-Tanzu-Kubernetes-Grid/1.6/vmware-tanzu-kubernetes-grid-16/GUID-packages-user-managed-index.html#package-locations-and-dependencies-5).
</file>

<file path="topics/library_charts.md">
---
title: Library Charts
description: Explains library charts and examples of usage
sidebar_position: 4
---

A library chart is a type of [Helm chart](/topics/charts.mdx)
that defines chart primitives or definitions which can be shared by Helm
templates in other charts. This allows users to share snippets of code that can
be re-used across charts, avoiding repetition and keeping charts
[DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself).

The library chart was introduced in Helm 3 to formally recognize common or
helper charts that have been used by chart maintainers since Helm 2. By
including it as a chart type, it provides:
- A means to explicitly distinguish between common and application charts
- Logic to prevent installation of a common chart
- No rendering of templates in a common chart which may contain release
  artifacts
- Allow for dependent charts to use the importer's context

A chart maintainer can define a common chart as a library chart and now be
confident that Helm will handle the chart in a standard consistent fashion. It
also means that definitions in an application chart can be shared by changing
the chart type.

## Create a Simple Library Chart

As mentioned previously, a library chart is a type of [Helm chart](/topics/charts.mdx). This means that you can start off by creating a
scaffold chart:

```console
$ helm create mylibchart
Creating mylibchart
```

You will first remove all the files in `templates` directory as we will create
our own templates definitions in this example.

```console
$ rm -rf mylibchart/templates/*
```

The values file will not be required either.

```console
$ rm -f mylibchart/values.yaml
```

Before we jump into creating common code, lets do a quick review of some
relevant Helm concepts. A [named template](/chart_template_guide/named_templates.md) (sometimes called a partial
or a subtemplate) is simply a template defined inside of a file, and given a
name.  In the `templates/` directory, any file that begins with an underscore(_)
is not expected to output a Kubernetes manifest file. So by convention, helper
templates and partials are placed in a `_*.tpl` or `_*.yaml` files.

In this example, we will code a common ConfigMap which creates an empty
ConfigMap resource. We will define the common ConfigMap in file
`mylibchart/templates/_configmap.yaml` as follows:

```yaml
{{- define "mylibchart.configmap.tpl" -}}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name | printf "%s-%s" .Chart.Name }}
data: {}
{{- end -}}
{{- define "mylibchart.configmap" -}}
{{- include "mylibchart.util.merge" (append . "mylibchart.configmap.tpl") -}}
{{- end -}}
```

The ConfigMap construct is defined in named template `mylibchart.configmap.tpl`.
It is a simple ConfigMap with an empty resource, `data`. Within this file there
is another named template called `mylibchart.configmap`. This named template
includes another named template `mylibchart.util.merge` which will take 2 named
templates as arguments, the template calling `mylibchart.configmap` and
`mylibchart.configmap.tpl`.

The helper function `mylibchart.util.merge` is a named template in
`mylibchart/templates/_util.yaml`. It is a handy util from [The Common Helm
Helper Chart](#the-common-helm-helper-chart) because it merges the 2 templates
and overrides any common parts in both:

```yaml
{{- /*
mylibchart.util.merge will merge two YAML templates and output the result.
This takes an array of three values:
- the top context
- the template name of the overrides (destination)
- the template name of the base (source)
*/}}
{{- define "mylibchart.util.merge" -}}
{{- $top := first . -}}
{{- $overrides := fromYaml (include (index . 1) $top) | default (dict ) -}}
{{- $tpl := fromYaml (include (index . 2) $top) | default (dict ) -}}
{{- toYaml (merge $overrides $tpl) -}}
{{- end -}}
```

This is important when a chart wants to use common code that it needs to
customize with its configuration.

Finally, lets change the chart type to `library`. This requires editing
`mylibchart/Chart.yaml` as follows:

```yaml
apiVersion: v2
name: mylibchart
description: A Helm chart for Kubernetes

# A chart can be either an 'application' or a 'library' chart.
#
# Application charts are a collection of templates that can be packaged into versioned archives
# to be deployed.
#
# Library charts provide useful utilities or functions for the chart developer. They're included as
# a dependency of application charts to inject those utilities and functions into the rendering
# pipeline. Library charts do not define any templates and therefore cannot be deployed.
# type: application
type: library

# This is the chart version. This version number should be incremented each time you make changes
# to the chart and its templates, including the app version.
version: 0.1.0

# This is the version number of the application being deployed. This version number should be
# incremented each time you make changes to the application and it is recommended to use it with quotes.
appVersion: "1.16.0"
```

The library chart is now ready to be shared and its ConfigMap definition to be
re-used.

Before moving on, it is worth checking if Helm recognizes the chart as a library
chart:

```console
$ helm install mylibchart mylibchart/
Error: library charts are not installable
```

## Use the Simple Library Chart

It is time to use the library chart. This means creating a scaffold chart again:

```console
$ helm create mychart
Creating mychart
```

Lets clean out the template files again as we want to create a ConfigMap only:

```console
$ rm -rf mychart/templates/*
```

When we want to create a simple ConfigMap in a Helm template, it could look
similar to the following:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name | printf "%s-%s" .Chart.Name }}
data:
  myvalue: "Hello World"
```

We are however going to re-use the common code already created in `mylibchart`.
The ConfigMap can be created in the file `mychart/templates/configmap.yaml` as
follows:

```yaml
{{- include "mylibchart.configmap" (list . "mychart.configmap") -}}
{{- define "mychart.configmap" -}}
data:
  myvalue: "Hello World"
{{- end -}}
```

You can see that it simplifies the work we have to do by inheriting the common
ConfigMap definition which adds standard properties for ConfigMap. In our
template we add the configuration, in this case the data key `myvalue` and its
value. The configuration override the empty resource of the common ConfigMap.
This is feasible because of the helper function `mylibchart.util.merge` we
mentioned in the previous section.

To be able to use the common code, we need to add `mylibchart` as a dependency.
Add the following to the end of the file `mychart/Chart.yaml`:

```yaml
# My common code in my library chart
dependencies:
- name: mylibchart
  version: 0.1.0
  repository: file://../mylibchart
```

This includes the library chart as a dynamic dependency from the filesystem
which is at the same parent path as our application chart. As we are including
the library chart as a dynamic dependency, we need to run `helm dependency
update`. It will copy the library chart into your `charts/` directory.

```console
$ helm dependency update mychart/
Hang tight while we grab the latest from your chart repositories...
...Successfully got an update from the "stable" chart repository
Update Complete. âŽˆHappy Helming!âŽˆ
Saving 1 charts
Deleting outdated charts
```

We are now ready to deploy our chart. Before installing, it is worth checking
the rendered template first.

```console
$ helm install mydemo mychart/ --debug --dry-run
install.go:159: [debug] Original chart version: ""
install.go:176: [debug] CHART PATH: /root/test/helm-charts/mychart

NAME: mydemo
LAST DEPLOYED: Tue Mar  3 17:48:47 2020
NAMESPACE: default
STATUS: pending-install
REVISION: 1
TEST SUITE: None
USER-SUPPLIED VALUES:
{}

COMPUTED VALUES:
affinity: {}
fullnameOverride: ""
image:
  pullPolicy: IfNotPresent
  repository: nginx
imagePullSecrets: []
ingress:
  annotations: {}
  enabled: false
  hosts:
  - host: chart-example.local
    paths: []
  tls: []
mylibchart:
  global: {}
nameOverride: ""
nodeSelector: {}
podSecurityContext: {}
replicaCount: 1
resources: {}
securityContext: {}
service:
  port: 80
  type: ClusterIP
serviceAccount:
  annotations: {}
  create: true
  name: null
tolerations: []

HOOKS:
MANIFEST:
---
# Source: mychart/templates/configmap.yaml
apiVersion: v1
data:
  myvalue: Hello World
kind: ConfigMap
metadata:
  labels:
    app: mychart
    chart: mychart-0.1.0
    release: mydemo
  name: mychart-mydemo
```

This looks like the ConfigMap we want with data override of `myvalue: Hello
World`. Lets install it:

```console
$ helm install mydemo mychart/
NAME: mydemo
LAST DEPLOYED: Tue Mar  3 17:52:40 2020
NAMESPACE: default
STATUS: deployed
REVISION: 1
TEST SUITE: None
```

We can retrieve the release and see that the actual template was loaded.

```console
$ helm get manifest mydemo
---
# Source: mychart/templates/configmap.yaml
apiVersion: v1
data:
  myvalue: Hello World
kind: ConfigMap
metadata:
  labels:
    app: mychart
    chart: mychart-0.1.0
    release: mydemo
  name: mychart-mydemo
  ```

## Library Chart Benefits
Because of their inability to act as standalone charts, library charts can leverage the following functionality:
- The `.Files` object references the file paths on the parent chart, rather than the path local to the library chart
- The `.Values` object is the same as the parent chart, in contrast to application [subcharts](/chart_template_guide/subcharts_and_globals.md) which receive the section of values configured under their header in the parent.


## The Common Helm Helper Chart

```markdown
Note: The Common Helm Helper Chart repo on Github is no longer actively maintained, and the repo has been deprecated and archived.
```

This [chart](https://github.com/helm/charts/tree/master/incubator/common) was
the original pattern for common charts. It provides utilities that reflect best
practices of Kubernetes chart development. Best of all it can be used off the
bat by you when developing your charts to give you handy shared code.

Here is a quick way to use it. For more details, have a look at the
[README](https://github.com/helm/charts/blob/master/incubator/common/README.md).

Create a scaffold chart again:

```console
$ helm create demo
Creating demo
```

Lets use the common code from the helper chart. First, edit deployment
`demo/templates/deployment.yaml` as follows:

```yaml
{{- template "common.deployment" (list . "demo.deployment") -}}
{{- define "demo.deployment" -}}
## Define overrides for your Deployment resource here, e.g.
apiVersion: apps/v1
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      {{- include "demo.selectorLabels" . | nindent 6 }}
  template:
    metadata:
      labels:
        {{- include "demo.selectorLabels" . | nindent 8 }}

{{- end -}}
```

And now the service file, `demo/templates/service.yaml` as follows:

```yaml
{{- template "common.service" (list . "demo.service") -}}
{{- define "demo.service" -}}
## Define overrides for your Service resource here, e.g.
# metadata:
#   labels:
#     custom: label
# spec:
#   ports:
#   - port: 8080
{{- end -}}
```

These templates show how inheriting the common code from the helper chart
simplifies your coding down to your configuration or customization of the
resources.

To be able to use the common code, we need to add `common` as a dependency. Add
the following to the end of the file `demo/Chart.yaml`:

```yaml
dependencies:
- name: common
  version: "^0.0.5"
  repository: "https://charts.helm.sh/incubator/"
```

Note: You will need to add the `incubator` repo to the Helm repository list
(`helm repo add`).

As we are including the chart as a dynamic dependency, we need to run `helm
dependency update`. It will copy the helper chart into your `charts/` directory.

As helper chart is using some Helm 2 constructs, you will need to add the
following to `demo/values.yaml` to enable the `nginx` image to be loaded as this
was updated in Helm 3 scaffold chart:

```yaml
image:
  tag: 1.16.0
```

You can test that the chart templates are correct prior to deploying using the `helm lint` and `helm template` commands.

If it's good to go, deploy away using `helm install`!
</file>

<file path="topics/permissions_sql_storage_backend.md">
---
title: Permissions management for SQL storage backend
description: Get to know how to setup permissions when using SQL storage backend.
---

This document aims to provide guidance to users for setting up and managing
permissions when using the SQL storage backend.

## Introduction

To handle permissions, Helm leverages the RBAC feature of Kubernetes. When using
the SQL storage backend, Kubernetes' roles can't be used to determine whether or
not an user can access a given resource. This document shows how to create and
manage these permissions.

## Initialization

The first time the Helm CLI will make connect to your database, the client will
make sure that it was previously initialized. If it is not, it will take care of
the necessary setup automatically. This initialization requires admin privileges
on the public schema, or at least to be able to:

* create a table
* grant privileges on the public schema

After the migration was run against your database, all the other roles can use
the client.

## Grant privileges to a non admin user in PostgreSQL

To manage permissions, the SQL backend driver leverages the
[RLS](https://www.postgresql.org/docs/9.5/ddl-rowsecurity.html)(Row Security
Level) feature of PostgreSQL. RLS allows all users to be able to read/write
from/to the same table, without being able to manipulate the same rows if they
are not explicitly allowed to. By default, any role that has not been
explicitly granted with the right privileges will always return an empty list
when running `helm list` and will not be able to retrieve or modify any resource
in the cluster.

Let's see how to grant a given role access to specific namespaces:

```sql
CREATE POLICY <name> ON releases_v1 FOR ALL TO <role> USING (namespace = 'default');
```

This command will grant the permissions to read and write all resources that
meet the `namespace = 'default'` condition to the role `role`. After creating
this policy, the user being connected to the database on the behalf of the role
`role` will therefore be able to see all the releases living in the `default`
namespace when running `helm list`, and to modify and delete them.

Privileges can be managed granularly with RLS, and one might be interested in
restraining access given the different columns of the table:
* key
* type
* body
* name
* namespace
* version
* status
* owner
* createdAt
* modifiedAt
</file>

<file path="topics/plugins.mdx">
---
title: The Helm Plugins Guide
description: Introduces how to use and create plugins to extend Helm's functionality.
sidebar_position: 12
---

import Helm4 from "/docs/_v4-in-progress.mdx"

<Helm4/>

A Helm plugin is a tool that can be accessed through the `helm` CLI, but which
is not part of the built-in Helm codebase.

Existing plugins can be found on [related](/community/related#helm-plugins) section or by searching
[GitHub](https://github.com/search?q=topic%3Ahelm-plugin&type=Repositories).

This guide explains how to use and create plugins.

## An Overview

Helm plugins are add-on tools that integrate seamlessly with Helm. They provide
a way to extend the core feature set of Helm, but without requiring every new
feature to be written in Go and added to the core tool.

Helm plugins have the following features:

- They can be added and removed from a Helm installation without impacting the
  core Helm tool.
- They can be written in any programming language.
- They integrate with Helm, and will show up in `helm help` and other places.

Helm plugins live in `$HELM_PLUGINS`. You can find the current value of this,
including the default value when not set in the environment, using the
`helm env` command.

The Helm plugin model is partially based on Git's plugin model. To that end,
you may sometimes hear `helm` referred to as the _porcelain_ layer, with plugins
being the _plumbing_. This is a shorthand way of suggesting that Helm provides
the user experience and top level processing logic, while the plugins do the
"detail work" of performing a desired action.

## Installing a Plugin

Plugins are installed using the `$ helm plugin install <path|url>` command. You
can pass in a path to a plugin on your local file system or a url of a remote
VCS repo. The `helm plugin install` command clones or copies the plugin at the
path/url given into `$HELM_PLUGINS`. If you are installing from a VCS you can specify
the version with the `--version` argument.

```console
$ helm plugin install https://github.com/adamreese/helm-env
```

If you have a plugin tar distribution, simply untar the plugin into the
`$HELM_PLUGINS` directory. You can also install tarball plugins
directly from url by issuing `helm plugin install
https://domain/path/to/plugin.tar.gz`

## The Plugin File Structure

In many ways, a plugin is similar to a chart. Each plugin has a top-level
directory containing a `plugin.yaml` file. Additional files may be present but
only the `plugin.yaml` file is required.

```console
$HELM_PLUGINS/
  |- last/
      |- plugin.yaml
```

## The plugin.yaml File

The plugin.yaml file is required for a plugin. It contains the following fields:

```yaml
name: The name of the plugin (REQUIRED)
version: A SemVer 2 version (REQUIRED)
usage: Single line usage text shown in help
description: Long description shown in places like helm help
ignoreFlags: Ignore flags passed in from Helm
platformCommand: # Configure command to run based on the platform
  - os: OS match, can be empty or omitted to match all OS'
    arch: Architecture match, can be empty or omitted to match all architectures
    command: Plugin command to execute
    args: Plugin command arguments
command: (DEPRECATED) Plugin command, use platformCommand instead
platformHooks: # Configure plugin lifecycle hooks based on the platform
  install: # Install lifecycle commands
    - os: OS match, can be empty or omitted to match all OS'
      arch: Architecture match, can be empty or omitted to match all architectures
      command: Plugin install command to execute
      args: Plugin install command arguments
  update: # Update lifecycle commands
    - os: OS match, can be empty or omitted to match all OS'
      arch: Architecture match, can be empty or omitted to match all architectures
      command: Plugin update command to execute
      args: Plugin update command arguments
  delete: # Delete lifecycle commands
    - os: OS match, can be empty or omitted to match all OS'
      arch: Architecture match, can be empty or omitted to match all architectures
      command: Plugin delete command to execute
      args: Plugin delete command arguments
hooks: # (Deprecated) Plugin lifecycle hooks, use platformHooks instead
  install: Command to install plugin
  update: Command to update plugin
  delete: Command to delete plugin
downloaders: # Configure downloaders capability
  - command: Command to invoke
    protocols:
      - Protocol schema supported
```

### The `name` Field

The `name` is the name of the plugin. When Helm executes this plugin, this is
the name it will use (e.g. `helm NAME` will invoke this plugin).

_`name` should match the directory name._ In our example above, that means the
plugin with `name: last` should be contained in a directory named `last`.

Restrictions on `name`:

- `name` cannot duplicate one of the existing `helm` top-level commands.
- `name` must be restricted to the characters ASCII a-z, A-Z, 0-9, `_` and `-`.

### The `version` Field

The `version` is the SemVer 2 version of the plugin. `usage` and `description` are
both used to generate the help text of a command.

### The `ignoreFlags` Field

The `ignoreFlags` switch tells Helm to _not_ pass flags to the plugin. So if a
plugin is called with `helm myplugin --foo` and `ignoreFlags: true`, then
`--foo` is silently discarded.

### The `platformCommand` Field

The `platformCommand` configures the command that the plugin will execute when
it is called. You can't set both `platformCommand` & `command` as this will result
in an error. The following rules will apply in deciding which command to use:

- If `platformCommand` is present, it will be used.
  - If both `os` and `arch` match the current platform, search will stop and the
  command will be used.
  - If `os` matches and `arch` is empty, the command will be used.
  - If `os` and `arch` are both empty, the command will be used.
  - If there is no match, Helm will exit with an error.
- If `platformCommand` is not present and the deprecated `command` is present
it will be used.
  - If the command is empty, Helm will exit with an error.

### The `platformHooks` Field

The `platformHooks` configures the commands that the plugin will execute for lifecycle
events. You can't set both `platformHooks` & `hooks` as this will resultin an error.
The following rules will apply in deciding which hook command to use:

- If `platformHooks` is present, it will be used and the commands for the lifecycle
event will be processed.
  - If both `os` and `arch` match the current platform, search will stop and the
  command will be used.
  - If `os` matches and `arch` is empty, the command will be used.
  - If `os` and `arch` are both empty, the command will be used.
  - If there is no match, Helm will skip the event.
- If `platformHooks` is not present and the deprecated `hooks` is present the command
for the lifecycle event will be used.
  - If the command is empty, Helm will skip the event.

## Building a Plugin

Here is the plugin YAML for a simple plugin that helps get the last release name:

```yaml
name: last
version: 0.1.0
usage: get the last release name
description: get the last release name
ignoreFlags: false
platformCommand:
  - command: ${HELM_BIN}
    args:
      - list
      - --short
      - --max=1
      - --date
      - -r
```

Plugins may require additional scripts and executables.
Scripts can be included in the plugin directory and executables can be downloaded
via a hook. The following is an example plugin:

```console
$HELM_PLUGINS/
  |- myplugin/
    |- scripts/
      |- install.ps1
      |- install.sh
    |- plugin.yaml
```

```yaml
name: myplugin
version: 0.1.0
usage: example plugin
description: example plugin
ignoreFlags: false
platformCommand:
  - command: ${HELM_PLUGIN_DIR}/bin/myplugin
  - os: windows
    command: ${HELM_PLUGIN_DIR}\bin\myplugin.exe
platformHooks:
  install:
    - command: ${HELM_PLUGIN_DIR}/scripts/install.sh
    - os: windows
      command: pwsh
      args:
        - -c
        - ${HELM_PLUGIN_DIR}\scripts\install.ps1
  update:
    - command: ${HELM_PLUGIN_DIR}/scripts/install.sh
      args:
        - -u
    - os: windows
      command: pwsh
      args:
        - -c
        - ${HELM_PLUGIN_DIR}\scripts\install.ps1
        - -Update
```

Environment variables are interpolated before the plugin is executed. The
pattern above illustrates the preferred way to indicate where the plugin program
lives.

### Plugin Commands

There are some strategies for working with plugin commands:

- If a plugin includes an executable, the executable for a `platformCommand:` or
  should be packaged in the plugin directory or installed via a hook.
- The `platformCommand:` or `command:` line will have any environment variables
  expanded before execution. `$HELM_PLUGIN_DIR` will point to the plugin
  directory.
- The command itself is not executed in a shell. So you can't oneline a shell
  script.
- Helm injects lots of configuration into environment variables. Take a look at
  the environment to see what information is available.
- Helm makes no assumptions about the language of the plugin. You can write it
  in whatever you prefer.
- Commands are responsible for implementing specific help text for `-h` and
  `--help`. Helm will use `usage` and `description` for `helm help` and `helm
  help myplugin`, but will not handle `helm myplugin --help`.

### Testing a Local Plugin

First you need to find your `HELM_PLUGINS` path to do it run the following command:

``` bash
helm env
```

Change your current directory to the director that `HELM_PLUGINS` is set to.

Now you can add a symbolic link to your build output of your plugin in this example
we did it for `mapkubeapis`.

``` bash
ln -s ~/GitHub/helm-mapkubeapis ./helm-mapkubeapis
```

## Downloader Plugins

By default, Helm is able to pull Charts using HTTP/S. As of Helm 2.4.0, plugins
can have a special capability to download Charts from arbitrary sources.

Plugins shall declare this special capability in the `plugin.yaml` file (top
level):

```yaml
downloaders:
- command: "bin/mydownloader"
  protocols:
  - "myprotocol"
  - "myprotocols"
```

If such plugin is installed, Helm can interact with the repository using the
specified protocol scheme by invoking the `command`. The special repository
shall be added similarly to the regular ones: `helm repo add favorite
myprotocol://example.com/` The rules for the special repos are the same to the
regular ones: Helm must be able to download the `index.yaml` file in order to
discover and cache the list of available Charts.

The defined command will be invoked with the following scheme: `command certFile
keyFile caFile full-URL`. The SSL credentials are coming from the repo
definition, stored in `$HELM_REPOSITORY_CONFIG`
(i.e., `$HELM_CONFIG_HOME/repositories.yaml`). A Downloader plugin
is expected to dump the raw content to stdout and report errors on stderr.

The downloader command also supports sub-commands or arguments, allowing you to
specify for example `bin/mydownloader subcommand -d` in the `plugin.yaml`. This
is useful if you want to use the same executable for the main plugin command and
the downloader command, but with a different sub-command for each.

## Environment Variables

When Helm executes a plugin, it passes the outer environment to the plugin, and
also injects some additional environment variables.

Variables like `KUBECONFIG` are set for the plugin if they are set in the outer
environment.

The following variables are guaranteed to be set:

- `HELM_PLUGINS`: The path to the plugins directory.
- `HELM_PLUGIN_NAME`: The name of the plugin, as invoked by `helm`. So `helm
  myplug` will have the short name `myplug`.
- `HELM_PLUGIN_DIR`: The directory that contains the plugin.
- `HELM_BIN`: The path to the `helm` command (as executed by the user).
- `HELM_DEBUG`: Indicates if the debug flag was set by helm.
- `HELM_REGISTRY_CONFIG`: The location for the registry configuration (if
  using). Note that the use of Helm with registries is an experimental feature.
- `HELM_REPOSITORY_CACHE`: The path to the repository cache files.
- `HELM_REPOSITORY_CONFIG`: The path to the repository configuration file.
- `HELM_NAMESPACE`: The namespace given to the `helm` command (generally using
  the `-n` flag).
- `HELM_KUBECONTEXT`: The name of the Kubernetes config context given to the
  `helm` command.

Additionally, if a Kubernetes configuration file was explicitly specified, it
will be set as the `KUBECONFIG` variable

## A Note on Flag Parsing

When executing a plugin, Helm will parse global flags for its own use. None of
these flags are passed on to the plugin.
- `--burst-limit`: This is converted to `$HELM_BURST_LIMIT`
- `--debug`: If this is specified, `$HELM_DEBUG` is set to `1`
- `--kube-apiserver`: This is converted to `$HELM_KUBEAPISERVER`
- `--kube-as-group`: These are converted to `$HELM_KUBEASGROUPS`
- `--kube-as-user`: This is converted to `$HELM_KUBEASUSER`
- `--kube-ca-file`: This is converted to `$HELM_KUBECAFILE`
- `--kube-context`: This is converted to `$HELM_KUBECONTEXT`
- `--kube-insecure-skip-tls-verify`: This is converted to `$HELM_KUBEINSECURE_SKIP_TLS_VERIFY`
- `--kube-tls-server-name`: This is converted to `$HELM_KUBETLS_SERVER_NAME`
- `--kube-token`: This is converted to `$HELM_KUBETOKEN`
- `--kubeconfig`: This is converted to `$KUBECONFIG`
- `--namespace` and `-n`: This is converted to `$HELM_NAMESPACE`
- `--qps`: This is converted to `$HELM_QPS`
- `--registry-config`: This is converted to `$HELM_REGISTRY_CONFIG`
- `--repository-cache`: This is converted to `$HELM_REPOSITORY_CACHE`
- `--repository-config`: This is converted to `$HELM_REPOSITORY_CONFIG`

Plugins _should_ display help text and then exit for `-h` and `--help`. In all
other cases, plugins may use flags as appropriate.

## Providing shell auto-completion

As of Helm 3.2, a plugin can optionally provide support for shell
auto-completion as part of Helm's existing auto-completion mechanism.

### Static auto-completion

If a plugin provides its own flags and/or sub-commands, it can inform Helm of
them by having a `completion.yaml` file located in the plugin's root directory.
The `completion.yaml` file has the form:

```yaml
name: <pluginName>
flags:
- <flag 1>
- <flag 2>
validArgs:
- <arg value 1>
- <arg value 2>
commands:
  name: <commandName>
  flags:
  - <flag 1>
  - <flag 2>
  validArgs:
  - <arg value 1>
  - <arg value 2>
  commands:
     <and so on, recursively>
```

Notes:

1. All sections are optional but should be provided if applicable.
1. Flags should not include the `-` or `--` prefix.
1. Both short and long flags can and should be specified. A short flag need not
   be associated with its corresponding long form, but both forms should be
   listed.
1. Flags need not be ordered in any way, but need to be listed at the correct
   point in the sub-command hierarchy of the file.
1. Helm's existing global flags are already handled by Helm's auto-completion
   mechanism, therefore plugins need not specify the following flags `--debug`,
   `--namespace` or `-n`, `--kube-context`, and `--kubeconfig`, or any other
   global flag.
1. The `validArgs` list provides a static list of possible completions for the
   first parameter following a sub-command.  It is not always possible to
   provide such a list in advance (see the [Dynamic
   Completion](#dynamic-completion) section below), in which case the
   `validArgs` section can be omitted.

The `completion.yaml` file is entirely optional.  If it is not provided, Helm
will simply not provide shell auto-completion for the plugin (unless [Dynamic
Completion](#dynamic-completion) is supported by the plugin).  Also, adding a
`completion.yaml` file is backwards-compatible and will not impact the behavior
of the plugin when using older helm versions.

As an example, for the [`fullstatus
plugin`](https://github.com/marckhouzam/helm-fullstatus) which has no
sub-commands but accepts the same flags as the `helm status` command, the
`completion.yaml` file is:

```yaml
name: fullstatus
flags:
- o
- output
- revision
```

### Dynamic completion

Also starting with Helm 3.2, plugins can provide their own dynamic shell
auto-completion. Dynamic shell auto-completion is the completion of parameter
values or flag values that cannot be defined in advance.  For example,
completion of the names of helm releases currently available on the cluster.

For the plugin to support dynamic auto-completion, it must provide an
**executable** file called `plugin.complete` in its root directory. When the
Helm completion script requires dynamic completions for the plugin, it will
execute the `plugin.complete` file, passing it the command-line that needs to be
completed.  The `plugin.complete` executable will need to have the logic to
determine what the proper completion choices are and output them to standard
output to be consumed by the Helm completion script.

The `plugin.complete` file is entirely optional.  If it is not provided, Helm
will simply not provide dynamic auto-completion for the plugin.  Also, adding a
`plugin.complete` file is backwards-compatible and will not impact the behavior
of the plugin when using older helm versions.

The output of the `plugin.complete` script should be a new-line separated list
such as:

```console
rel1
rel2
rel3
```

When `plugin.complete` is called, the plugin environment is set just like when
the plugin's main script is called. Therefore, the variables `$HELM_NAMESPACE`,
`$HELM_KUBECONTEXT`, and all other plugin variables will already be set, and
their corresponding global flags will be removed.

The `plugin.complete` file can be in any executable form; it can be a shell
script, a Go program, or any other type of program that Helm can execute. The
`plugin.complete` file ***must*** have executable permissions for the user. The
`plugin.complete` file ***must*** exit with a success code (value 0).

In some cases, dynamic completion will require to obtain information from the
Kubernetes cluster.  For example, the `helm fullstatus` plugin requires a
release name as input. In the `fullstatus` plugin, for its `plugin.complete`
script to provide completion for current release names, it can simply run `helm
list -q` and output the result.

If it is desired to use the same executable for plugin execution and for plugin
completion, the `plugin.complete` script can be made to call the main plugin
executable with some special parameter or flag; when the main plugin executable
detects the special parameter or flag, it will know to run the completion. In
our example, `plugin.complete` could be implemented like this:

```sh
#!/usr/bin/env sh

# "$@" is the entire command-line that requires completion.
# It is important to double-quote the "$@" variable to preserve a possibly empty last parameter.
$HELM_PLUGIN_DIR/status.sh --complete "$@"
```

The `fullstatus` plugin's real script (`status.sh`) must then look for the
`--complete` flag and if found, printout the proper completions.

### Tips and tricks

1. The shell will automatically filter out completion choices that don't match
   user input. A plugin can therefore return all relevant completions without
   removing the ones that don't match the user input.  For example, if the
   command-line is `helm fullstatus ngin<TAB>`, the `plugin.complete` script can
   print *all* release names (of the `default` namespace), not just the ones
   starting with `ngin`; the shell will only retain the ones starting with
   `ngin`.
1. To simplify dynamic completion support, especially if you have a complex
   plugin, you can have your  `plugin.complete` script call your main plugin
   script and request completion choices.  See the [Dynamic
   Completion](#dynamic-completion) section above for an example.
1. To debug dynamic completion and the `plugin.complete` file, one can run the
   following to see the completion results :
    - `helm __complete <pluginName> <arguments to complete>`.  For example:
    - `helm __complete fullstatus --output js<ENTER>`,
    - `helm __complete fullstatus -o json ""<ENTER>`
</file>

<file path="topics/provenance.mdx">
---
title: Helm Provenance and Integrity
description: Describes how to verify the integrity and origin of a Chart.
sidebar_position: 5
---

import Helm4 from "/docs/_v4-in-progress.mdx"

<Helm4/>

Helm has provenance tools which help chart users verify the integrity and origin
of a package. Using industry-standard tools based on PKI, GnuPG, and
well-respected package managers, Helm can generate and verify signature files.

## Overview

Integrity is established by comparing a chart to a provenance record. Provenance
records are stored in _provenance files_, which are stored alongside a packaged
chart. For example, if a chart is named `myapp-1.2.3.tgz`, its provenance file
will be `myapp-1.2.3.tgz.prov`.

Provenance files are generated at packaging time (`helm package --sign ...`),
and can be checked by multiple commands, notably `helm install --verify`.

## The Workflow

This section describes a potential workflow for using provenance data
effectively.

Prerequisites:

- A valid PGP keypair in a binary (not ASCII-armored) format
- The `helm` command line tool
- GnuPG command line tools (optional)
- Keybase command line tools (optional)

**NOTE:** If your PGP private key has a passphrase, you will be prompted to
enter that passphrase for any commands that support the `--sign` option.

Creating a new chart is the same as before:

```console
$ helm create mychart
Creating mychart
```

Once ready to package, add the `--sign` flag to `helm package`. Also, specify
the name under which the signing key is known and the keyring containing the
corresponding private key:

```console
$ helm package --sign --key 'John Smith' --keyring path/to/keyring.secret mychart
```

**Note:** The value of the `--key` argument must be a substring of the desired
key's `uid` (in the output of `gpg --list-keys`), for example the name or email.
**The fingerprint _cannot_ be used.**

**TIP:** for GnuPG users, your secret keyring is in `~/.gnupg/secring.gpg`. You
can use `gpg --list-secret-keys` to list the keys you have.

**Warning:**  the GnuPG v2 store your secret keyring using a new format `kbx` on
the default location  `~/.gnupg/pubring.kbx`. Please use the following command
to convert your keyring to the legacy gpg format:

```console
$ gpg --export >~/.gnupg/pubring.gpg
$ gpg --export-secret-keys >~/.gnupg/secring.gpg
```

At this point, you should see both `mychart-0.1.0.tgz` and
`mychart-0.1.0.tgz.prov`. Both files should eventually be uploaded to your
desired chart repository.

You can verify a chart using `helm verify`:

```console
$ helm verify mychart-0.1.0.tgz
```

A failed verification looks like this:

```console
$ helm verify topchart-0.1.0.tgz
Error: sha256 sum does not match for topchart-0.1.0.tgz: "sha256:1939fbf7c1023d2f6b865d137bbb600e0c42061c3235528b1e8c82f4450c12a7" != "sha256:5a391a90de56778dd3274e47d789a2c84e0e106e1a37ef8cfa51fd60ac9e623a"
```

To verify during an install, use the `--verify` flag.

```console
$ helm install --generate-name --verify mychart-0.1.0.tgz
```

If the keyring containing the public key associated with the signed chart is not
in the default location, you may need to point to the keyring with `--keyring
PATH` as in the `helm package` example.

If verification fails, the install will be aborted before the chart is even
rendered.

### Using Keybase.io credentials

The [Keybase.io](https://keybase.io) service makes it easy to establish a chain
of trust for a cryptographic identity. Keybase credentials can be used to sign
charts.

Prerequisites:

- A configured Keybase.io account
- GnuPG installed locally
- The `keybase` CLI installed locally

#### Signing packages

The first step is to import your keybase keys into your local GnuPG keyring:

```console
$ keybase pgp export -s | gpg --import
```

This will convert your Keybase key into the OpenPGP format, and then import it
locally into your `~/.gnupg/secring.gpg` file.

You can double check by running `gpg --list-secret-keys`.

```console
$ gpg --list-secret-keys
/Users/mattbutcher/.gnupg/secring.gpg
-------------------------------------
sec   2048R/1FC18762 2016-07-25
uid                  technosophos (keybase.io/technosophos) <technosophos@keybase.io>
ssb   2048R/D125E546 2016-07-25
```

Note that your secret key will have an identifier string:

```
technosophos (keybase.io/technosophos) <technosophos@keybase.io>
```

That is the full name of your key.

Next, you can package and sign a chart with `helm package`. Make sure you use at
least part of that name string in `--key`.

```console
$ helm package --sign --key technosophos --keyring ~/.gnupg/secring.gpg mychart
```

As a result, the `package` command should produce both a `.tgz` file and a
`.tgz.prov` file.

#### Verifying packages

You can also use a similar technique to verify a chart signed by someone else's
Keybase key. Say you want to verify a package signed by
`keybase.io/technosophos`. To do this, use the `keybase` tool:

```console
$ keybase follow technosophos
$ keybase pgp pull
```

The first command above tracks the user `technosophos`. Next `keybase pgp pull`
downloads the OpenPGP keys of all of the accounts you follow, placing them in
your GnuPG keyring (`~/.gnupg/pubring.gpg`).

At this point, you can now use `helm verify` or any of the commands with a
`--verify` flag:

```console
$ helm verify somechart-1.2.3.tgz
```

### Reasons a chart may not verify

These are common reasons for failure.

- The `.prov` file is missing or corrupt. This indicates that something is
  misconfigured or that the original maintainer did not create a provenance
  file.
- The key used to sign the file is not in your keyring. This indicate that the
  entity who signed the chart is not someone you've already signaled that you
  trust.
- The verification of the `.prov` file failed. This indicates that something is
  wrong with either the chart or the provenance data.
- The file hashes in the provenance file do not match the hash of the archive
  file. This indicates that the archive has been tampered with.

If a verification fails, there is reason to distrust the package.

## The Provenance File

The provenance file contains a chartâ€™s YAML file plus several pieces of
verification information. Provenance files are designed to be automatically
generated.

The following pieces of provenance data are added:

* The chart file (`Chart.yaml`) is included to give both humans and tools an
  easy view into the contents of the chart.
* The signature (SHA256, just like Docker) of the chart package (the `.tgz`
  file) is included, and may be used to verify the integrity of the chart
  package.
* The entire body is signed using the algorithm used by OpenPGP (see
  [Keybase.io](https://keybase.io) for an emerging way of making crypto
  signing and verification easy).

The combination of this gives users the following assurances:

* The package itself has not been tampered with (checksum package `.tgz`).
* The entity who released this package is known (via the GnuPG/PGP signature).

The format of the file looks something like this:

```
Hash: SHA512

apiVersion: v2
appVersion: "1.16.0"
description: Sample chart
name: mychart
type: application
version: 0.1.0

...
files:
  mychart-0.1.0.tgz: sha256:d31d2f08b885ec696c37c7f7ef106709aaf5e8575b6d3dc5d52112ed29a9cb92
-----BEGIN PGP SIGNATURE-----

wsBcBAEBCgAQBQJdy0ReCRCEO7+YH8GHYgAAfhUIADx3pHHLLINv0MFkiEYpX/Kd
nvHFBNps7hXqSocsg0a9Fi1LRAc3OpVh3knjPfHNGOy8+xOdhbqpdnB+5ty8YopI
mYMWp6cP/Mwpkt7/gP1ecWFMevicbaFH5AmJCBihBaKJE4R1IX49/wTIaLKiWkv2
cR64bmZruQPSW83UTNULtdD7kuTZXeAdTMjAK0NECsCz9/eK5AFggP4CDf7r2zNi
hZsNrzloIlBZlGGns6mUOTO42J/+JojnOLIhI3Psd0HBD2bTlsm/rSfty4yZUs7D
qtgooNdohoyGSzR5oapd7fEvauRQswJxOA0m0V+u9/eyLR0+JcYB8Udi1prnWf8=
=aHfz
-----END PGP SIGNATURE-----
```

Note that the YAML section contains two documents (separated by `...\n`). The
first file is the content of `Chart.yaml`. The second is the checksums, a map of
filenames to SHA-256 digests of that file's content at packaging time.

The signature block is a standard PGP signature, which provides [tamper
resistance](https://www.rossde.com/PGP/pgp_signatures.html).

## Chart Repositories

Chart repositories serve as a centralized collection of Helm charts.

Chart repositories must make it possible to serve provenance files over HTTP via
a specific request, and must make them available at the same URI path as the
chart.

For example, if the base URL for a package is
`https://example.com/charts/mychart-1.2.3.tgz`, the provenance file, if it
exists, MUST be accessible at
`https://example.com/charts/mychart-1.2.3.tgz.prov`.

From the end user's perspective, `helm install --verify myrepo/mychart-1.2.3`
should result in the download of both the chart and the provenance file with no
additional user configuration or action.

### Signatures in OCI-based registries

When publishing charts to an [OCI-based registry](/topics/registries.mdx), the
[`helm-sigstore` plugin](https://github.com/sigstore/helm-sigstore/) can be used 
to publish provenance to [sigstore](https://sigstore.dev/).  [As described in the
documentation](https://github.com/sigstore/helm-sigstore/blob/main/USAGE.md), the
process of creating provenance and signing with a GPG key are common, but the
`helm sigstore upload` command can be used to publish the provenance to an
immutable transparency log.

## Establishing Authority and Authenticity

When dealing with chain-of-trust systems, it is important to be able to
establish the authority of a signer. Or, to put this plainly, the system above
hinges on the fact that you trust the person who signed the chart. That, in
turn, means you need to trust the public key of the signer.

One of the design decisions with Helm has been that the Helm project would not
insert itself into the chain of trust as a necessary party. We don't want to be
"the certificate authority" for all chart signers. Instead, we strongly favor a
decentralized model, which is part of the reason we chose OpenPGP as our
foundational technology. So when it comes to establishing authority, we have
left this step more-or-less undefined in Helm 2 (a decision carried forward in
Helm 3).

However, we have some pointers and recommendations for those interested in using
the provenance system:

- The [Keybase](https://keybase.io) platform provides a public centralized
  repository for trust information.
  - You can use Keybase to store your keys or to get the public keys of others.
  - Keybase also has fabulous documentation available
  - While we haven't tested it, Keybase's "secure website" feature could be used
    to serve Helm charts.
  - The basic idea is that an official "chart reviewer" signs charts with her or
    his key, and the resulting provenance file is then uploaded to the chart
    repository.
  - There has been some work on the idea that a list of valid signing keys may
    be included in the `index.yaml` file of a repository.
</file>

<file path="topics/rbac.md">
---
title: Role-based Access Control
description: Explains how Helm interacts with Kubernetes' Role-Based Access Control.
sidebar_position: 11
---

In Kubernetes, granting roles to a user or an application-specific service
account is a best practice to ensure that your application is operating in the
scope that you have specified. Read more about service account permissions [in
the official Kubernetes
docs](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#service-account-permissions).

From Kubernetes 1.6 onwards, Role-based Access Control is enabled by default.
RBAC allows you to specify which types of actions are permitted depending on the
user and their role in your organization.

With RBAC, you can

- grant privileged operations (creating cluster-wide resources, like new roles)
  to administrators
- limit a user's ability to create resources (pods, persistent volumes,
  deployments) to specific namespaces, or in cluster-wide scopes (resource
  quotas, roles, custom resource definitions)
- limit a user's ability to view resources either in specific namespaces or at a
  cluster-wide scope.

This guide is for administrators who want to restrict the scope of a user's
interaction with the Kubernetes API.

## Managing user accounts

All Kubernetes clusters have two categories of users: service accounts managed
by Kubernetes, and normal users.

Normal users are assumed to be managed by an outside, independent service. An
administrator distributing private keys, a user store like Keystone or Google
Accounts, even a file with a list of usernames and passwords. In this regard,
Kubernetes does not have objects which represent normal user accounts. Normal
users cannot be added to a cluster through an API call.

In contrast, service accounts are users managed by the Kubernetes API. They are
bound to specific namespaces, and created automatically by the API server or
manually through API calls. Service accounts are tied to a set of credentials
stored as Secrets, which are mounted into pods allowing in-cluster processes to
talk to the Kubernetes API.

API requests are tied to either a normal user or a service account, or are
treated as anonymous requests. This means every process inside or outside the
cluster, from a human user typing `kubectl` on a workstation, to kubelets on
nodes, to members of the control plane, must authenticate when making requests
to the API server, or be treated as an anonymous user.

## Roles, ClusterRoles, RoleBindings, and ClusterRoleBindings

In Kubernetes, user accounts and service accounts can only view and edit
resources they have been granted access to. This access is granted through the
use of Roles and RoleBindings. Roles and RoleBindings are bound to a particular
namespace, which grant users the ability to view and/or edit resources within
that namespace the Role provides them access to.

At a cluster scope, these are called ClusterRoles and ClusterRoleBindings.
Granting a user a ClusterRole grants them access to view and/or edit resources
across the entire cluster. It is also required to view and/or edit resources at
the cluster scope (namespaces, resource quotas, nodes).

ClusterRoles can be bound to a particular namespace through reference in a
RoleBinding. The `admin`, `edit` and `view` default ClusterRoles are commonly
used in this manner.

These are a few ClusterRoles available by default in Kubernetes. They are
intended to be user-facing roles. They include super-user roles
(`cluster-admin`), and roles with more granular access (`admin`, `edit`,
`view`).

| Default ClusterRole | Default ClusterRoleBinding | Description
|---------------------|----------------------------|-------------
| `cluster-admin`     | `system:masters` group     | Allows super-user access to perform any action on any resource. When used in a ClusterRoleBinding, it gives full control over every resource in the cluster and in all namespaces. When used in a RoleBinding, it gives full control over every resource in the rolebinding's namespace, including the namespace itself.
| `admin`             | None                       | Allows admin access, intended to be granted within a namespace using a RoleBinding. If used in a RoleBinding, allows read/write access to most resources in a namespace, including the ability to create roles and rolebindings within the namespace. It does not allow write access to resource quota or to the namespace itself.
| `edit`              | None                       | Allows read/write access to most objects in a namespace. It does not allow viewing or modifying roles or rolebindings.
| `view`              | None                       | Allows read-only access to see most objects in a namespace. It does not allow viewing roles or rolebindings. It does not allow viewing secrets, since those are escalating.

## Restricting a user account's access using RBAC

Now that we understand the basics of Role-based Access Control, let's discuss
how an administrator can restrict a user's scope of access.

### Example: Grant a user read/write access to a particular namespace

To restrict a user's access to a particular namespace, we can use either the
`edit` or the `admin` role. If your charts create or interact with Roles and
Rolebindings, you'll want to use the `admin` ClusterRole.

Additionally, you may also create a RoleBinding with `cluster-admin` access.
Granting a user `cluster-admin` access at the namespace scope provides full
control over every resource in the namespace, including the namespace itself.

For this example, we will create a user with the `edit` Role. First, create the
namespace:

```console
$ kubectl create namespace foo
```

Now, create a RoleBinding in that namespace, granting the user the `edit` role.

```console
$ kubectl create rolebinding sam-edit
    --clusterrole edit \â€‹
    --user sam \â€‹
    --namespace foo
```

### Example: Grant a user read/write access at the cluster scope

If a user wishes to install a chart that installs cluster-scope resources
(namespaces, roles, custom resource definitions, etc.), they will require
cluster-scope write access.

To do that, grant the user either `admin` or `cluster-admin` access.

Granting a user `cluster-admin` access grants them access to absolutely every
resource available in Kubernetes, including node access with `kubectl drain` and
other administrative tasks. It is highly recommended to consider providing the
user `admin` access instead, or to create a custom ClusterRole tailored to their
needs.

```console
$ kubectl create clusterrolebinding sam-view
    --clusterrole view \â€‹
    --user sam

$ kubectl create clusterrolebinding sam-secret-reader
    --clusterrole secret-reader \â€‹
    --user sam
```

### Example: Grant a user read-only access to a particular namespace

You might've noticed that there is no ClusterRole available for viewing secrets.
The `view` ClusterRole does not grant a user read access to Secrets due to
escalation concerns. Helm stores release metadata as Secrets by default.

In order for a user to run `helm list`, they need to be able to read these
secrets. For that, we will create a special `secret-reader` ClusterRole.

Create the file `cluster-role-secret-reader.yaml` and write the following
content into the file:

```yaml
apiVersion: rbac.authorization.k8s.io/v1â€‹
kind: ClusterRoleâ€‹
metadata:â€‹
  name: secret-readerâ€‹
rules:â€‹
- apiGroups: [""]â€‹
  resources: ["secrets"]â€‹
  verbs: ["get", "watch", "list"]
```

Then, create the ClusterRole using

```console
$ kubectl create -f clusterrole-secret-reader.yamlâ€‹
```

Once that's done, we can grant a user read access to most resources, and then
grant them read access to secrets:

```console
$ kubectl create namespace foo

$ kubectl create rolebinding sam-view
    --clusterrole view \â€‹
    --user sam \â€‹
    --namespace foo

$ kubectl create rolebinding sam-secret-reader
    --clusterrole secret-reader \â€‹
    --user sam \â€‹
    --namespace foo
```

### Example: Grant a user read-only access at the cluster scope

In certain scenarios, it may be beneficial to grant a user cluster-scope access.
For example, if a user wants to run the command `helm list --all-namespaces`,
the API requires the user has cluster-scope read access.

To do that, grant the user both `view` and `secret-reader` access as described
above, but with a ClusterRoleBinding.

```console
$ kubectl create clusterrolebinding sam-view
    --clusterrole view \â€‹
    --user sam

$ kubectl create clusterrolebinding sam-secret-reader
    --clusterrole secret-reader \â€‹
    --user sam
```

## Additional Thoughts

The examples shown above utilize the default ClusterRoles provided with
Kubernetes. For more fine-grained control over what resources users are granted
access to, have a look at [the Kubernetes
documentation](https://kubernetes.io/docs/reference/access-authn-authz/rbac/) on
creating your own custom Roles and ClusterRoles.
</file>

<file path="topics/registries.mdx">
---
title: Use OCI-based registries
description: Describes how to use OCI for Chart distribution.
sidebar_position: 7
---

import Helm4 from "/docs/_v4-in-progress.mdx"

<Helm4/>

It is recommended to use container registries with [OCI](https://www.opencontainers.org/) support to store and share chart packages.

## Using an OCI-based registry

### Helm repositories in OCI-based registries

A [Helm repository](/topics/chart_repository.md) is a way to house and distribute packaged Helm charts. An OCI-based registry can contain zero or more Helm repositories and each of those repositories can contain zero or more packaged Helm charts.

### Use hosted registries

There are several hosted container registries with OCI support that you can use for your Helm charts. For example:

- [Amazon ECR](https://docs.aws.amazon.com/AmazonECR/latest/userguide/push-oci-artifact.html)
- [Azure Container Registry](https://docs.microsoft.com/azure/container-registry/container-registry-helm-repos#push-chart-to-registry-as-oci-artifact)
- [Cloudsmith](https://help.cloudsmith.io/docs/oci-repository)
- [Docker Hub](https://docs.docker.com/docker-hub/oci-artifacts/)
- [Google Artifact Registry](https://cloud.google.com/artifact-registry/docs/helm/manage-charts)
- [Harbor](https://goharbor.io/docs/main/administration/user-defined-oci-artifact/)
- [IBM Cloud Container Registry](https://cloud.ibm.com/docs/Registry?topic=Registry-registry_helm_charts)
- [JFrog Artifactory](https://jfrog.com/help/r/jfrog-artifactory-documentation/helm-oci-repositories)
- [RepoFlow](https://docs.repoflow.io/PackageTypes/helm#oci-helm-support)
  

Follow the hosted container registry provider's documentation to create and configure a registry with OCI support. 

**Note:**  You can run [Docker Registry](https://docs.docker.com/registry/deploying/) or [`zot`](https://github.com/project-zot/zot), which are OCI-based registries, on your development computer. Running an OCI-based registry on your development computer should only be used for testing purposes.

### Using sigstore to sign OCI-based charts

The [`helm-sigstore`](https://github.com/sigstore/helm-sigstore) plugin allows using [Sigstore](https://sigstore.dev/) to sign Helm charts with the same tools used to sign container images.  This provides an alternative to the [GPG-based provenance](/topics/provenance.mdx) supported by classic [chart repositories](/topics/chart_repository.md).

For more details on using the `helm sigstore` plugin, see [that project's documentation](https://github.com/sigstore/helm-sigstore/blob/main/USAGE.md).

## Commands for working with registries

### The `registry` subcommand

#### `login`

login to a registry (with manual password entry)

```console
$ helm registry login -u myuser localhost:5000
Password:
Login succeeded
```

#### `logout`

logout from a registry

```console
$ helm registry logout localhost:5000
Logout succeeded
```

### The `push` subcommand

Upload a chart to an OCI-based registry:

```console
$ helm push mychart-0.1.0.tgz oci://localhost:5000/helm-charts
Pushed: localhost:5000/helm-charts/mychart:0.1.0
Digest: sha256:ec5f08ee7be8b557cd1fc5ae1a0ac985e8538da7c93f51a51eff4b277509a723
```

The `push` subcommand can only be used against `.tgz` files
created ahead of time using `helm package`.

When using `helm push` to upload a chart an OCI registry, the reference
must be prefixed with `oci://` and must not contain the basename or tag.

The registry reference basename is inferred from the chart's name,
and the tag is inferred from the chart's semantic version. This is
currently a strict requirement.

Certain registries require the repository and/or namespace (if specified)
to be created beforehand. Otherwise, an error will be produced during the
 `helm push` operation.

If you have created a [provenance file](/topics/provenance.mdx) (`.prov`), and it is present next to the chart `.tgz` file, it will
automatically be uploaded to the registry upon `push`. This results in
an extra layer on [the Helm chart manifest](#helm-chart-manifest).

Users of the [helm-push plugin](https://github.com/chartmuseum/helm-push) (for uploading charts to [ChartMuseum](/topics/chart_repository.md#chartmuseum-repository-server))
may experience issues, since the plugin conflicts with the new, built-in `push`.
As of version v0.10.0, the plugin has been renamed to `cm-push`.

### Other subcommands

Support for the `oci://` protocol is also available in various other subcommands.
Here is a complete list:

- `helm pull`
- `helm push`
- `helm show `
- `helm template`
- `helm install`
- `helm upgrade`

The basename (chart name) of the registry reference *is*
included for any type of action involving chart download
(vs. `helm push` where it is omitted).

Here are a few examples of using the subcommands listed above against
OCI-based charts:

```
$ helm pull oci://localhost:5000/helm-charts/mychart --version 0.1.0
Pulled: localhost:5000/helm-charts/mychart:0.1.0
Digest: sha256:0be7ec9fb7b962b46d81e4bb74fdcdb7089d965d3baca9f85d64948b05b402ff

$ helm show all oci://localhost:5000/helm-charts/mychart --version 0.1.0
apiVersion: v2
appVersion: 1.16.0
description: A Helm chart for Kubernetes
name: mychart
...

$ helm template myrelease oci://localhost:5000/helm-charts/mychart --version 0.1.0
---
# Source: mychart/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
...

$ helm install myrelease oci://localhost:5000/helm-charts/mychart --version 0.1.0
NAME: myrelease
LAST DEPLOYED: Wed Oct 27 15:11:40 2021
NAMESPACE: default
STATUS: deployed
REVISION: 1
NOTES:
...

$ helm upgrade myrelease oci://localhost:5000/helm-charts/mychart --version 0.2.0
Release "myrelease" has been upgraded. Happy Helming!
NAME: myrelease
LAST DEPLOYED: Wed Oct 27 15:12:05 2021
NAMESPACE: default
STATUS: deployed
REVISION: 2
NOTES:
...
```

## Specifying dependencies

Dependencies of a chart can be pulled from a registry using the `dependency update` subcommand.

The `repository` for a given entry in `Chart.yaml` is specified as the registry reference without the basename:

```
dependencies:
  - name: mychart
    version: "2.7.0"
    repository: "oci://localhost:5000/myrepo"
```
This will fetch `oci://localhost:5000/myrepo/mychart:2.7.0` when `dependency update` is executed.

## Helm chart manifest

Example Helm chart manifest as represented in a registry
(note the `mediaType` fields):
```json
{
  "schemaVersion": 2,
  "config": {
    "mediaType": "application/vnd.cncf.helm.config.v1+json",
    "digest": "sha256:8ec7c0f2f6860037c19b54c3cfbab48d9b4b21b485a93d87b64690fdb68c2111",
    "size": 117
  },
  "layers": [
    {
      "mediaType": "application/vnd.cncf.helm.chart.content.v1.tar+gzip",
      "digest": "sha256:1b251d38cfe948dfc0a5745b7af5ca574ecb61e52aed10b19039db39af6e1617",
      "size": 2487
    }
  ]
}
```

The following example contains a
[provenance file](/topics/provenance.mdx)
(note the extra layer):

```json
{
  "schemaVersion": 2,
  "config": {
    "mediaType": "application/vnd.cncf.helm.config.v1+json",
    "digest": "sha256:8ec7c0f2f6860037c19b54c3cfbab48d9b4b21b485a93d87b64690fdb68c2111",
    "size": 117
  },
  "layers": [
    {
      "mediaType": "application/vnd.cncf.helm.chart.content.v1.tar+gzip",
      "digest": "sha256:1b251d38cfe948dfc0a5745b7af5ca574ecb61e52aed10b19039db39af6e1617",
      "size": 2487
    },
    {
      "mediaType": "application/vnd.cncf.helm.chart.provenance.v1.prov",
      "digest": "sha256:3e207b409db364b595ba862cdc12be96dcdad8e36c59a03b7b3b61c946a5741a",
      "size": 643
    }
  ]
}
```

## Migrating from chart repos

Migrating from classic [chart repositories](/topics/chart_repository.md)
(index.yaml-based repos) is as simple using `helm pull`, then using `helm push` to upload the resulting `.tgz` files to a registry.
</file>

<file path="topics/release_policy.md">
---
title: "Release schedule policy"
description: "Describes Helm's release schedule policy."
---

For the benefit of its users, Helm defines and announces release dates in
advance.  This document describes the policy governing Helm's release schedule.

## Release calendar

A public calendar showing the upcoming Helm releases can be found [here](https://helm.sh/calendar/release).
## Semantic versioning

Helm versions are expressed as `x.y.z`, where `x` is the major version, `y` is
the minor version, and `z` is the patch version, following [Semantic
Versioning](https://semver.org/spec/v2.0.0.html) terminology.

## Patch releases

Patch releases provide users with bug fixes and security fixes.  They do not
contain new features.

A new patch release relating to the latest minor/major release will normally be
done once a month on the second Wednesday of each month.

A patch release to fix a high priority regression or security issue can be done
whenever needed.

A patch release will be cancelled for any of the following reasons:
- if there is no new content since the previous release
- if the patch release date falls within one week before the first release candidate (RC1) of an upcoming minor release
- if the patch release date falls within four weeks following a minor release

## Minor releases

Minor releases contain security and bug fixes as well as new features.  They
are backwards compatible with respect to the API and the CLI usage.

To align with Kubernetes releases, a minor helm release will be done every
4 months (3 releases a year).

Extra minor releases can be done if needed but will not affect the timeline of
an announced future release, unless the announced release is less than 7 days
away.

At the same time as a release is published, the date of the next minor release
will be announced and posted to Helm's main web page.

## Major releases

Major releases contain breaking changes.  Such releases are rare but are
sometimes necessary to allow helm to continue to evolve in important new
directions.

Major releases can be difficult to plan.  With that in mind, a final release
date will only be chosen and announced once the first beta version of such a
release is available.
</file>

<file path="topics/version_skew.mdx">
---
title: "Helm Version Support Policy"
description: "Describes Helm's patch release policy as well as the maximum version skew supported between Helm and Kubernetes."
---

This document describes the maximum version skew supported between Helm 4 and
Kubernetes.

## Supported Versions

Helm versions are expressed as `x.y.z`, where `x` is the major version, `y` is
the minor version, and `z` is the patch version, following [Semantic
Versioning](https://semver.org/spec/v2.0.0.html) terminology.

The Helm project maintains a release branch for the most recent minor release.
Applicable fixes, including security fixes, are cherry-picked into the release
branch, depending on severity and feasibility. More details can be found in
[Helm's release policy](/topics/release_policy.md).

## Supported Version Skew

When a new version of Helm is released, it is compiled against a particular
minor version of Kubernetes. For example, Helm v4.0.0 interacts with Kubernetes
using the Kubernetes 1.34.1 client, so it is compatible with Kubernetes 1.34.

As of Helm 4, Helm is assumed to be compatible with `n-3` versions of Kubernetes
it was compiled against.

For example, if you are using a version of Helm 4 that was compiled against the
Kubernetes v1.35 client APIs, then it should be safe to use with Kubernetes v1.35,
v1.34, v1.33, and v1.32.

It is not recommended to use Helm with a version of Kubernetes that is newer
than the version it was compiled against, as Helm does not make any forward
compatibility guarantees.

If you choose to use Helm with a version of Kubernetes that it does not support,
you are using it at your own risk.

Please refer to the table below to determine what version of Helm is compatible
with your cluster.

| Helm Version | Supported Kubernetes Versions |
|--------------|-------------------------------|
| 4.0.x        | 1.34.x - 1.31.x               |
</file>

<file path="_v4-in-progress.mdx">
:::warning
This page has not yet been updated for Helm 4. Some of the content might be inaccurate or not applicable to Helm 4. For more information about the Helm 4 new features, improvements, and breaking changes, see [Helm 4 Overview](/overview.md).
:::
</file>

<file path="changelog.md">
---
sidebar_position: 2
sidebar_label: Full Changelog
---

# Helm 4 Full Changelog

**Scope**: 290 PRs from (`v4.0.0-rc.1`) compared to `v3.19.0`
**v4-only**: 257 PRs (33 backported to v3 excluded)

See the [Overview](/overview.md) for an actionable summary of these changes.

## New Features

New features in Helm 4 that were not backported to v3

| PR | Date | Author | Title |
|---|---|---|---|
| #31435 | 2025-11-03 | matheuscscp | Introduce a context for canceling wait operations |
| #31389 | 2025-10-30 | TerryHowe | chore: fix pkg/registry warnings to reduce noise |
| #31338 | 2025-10-21 | yzewei | Add loongarch64 support |
| #31351 | 2025-10-21 | gjenkins8 | feat: `helm version` print Kubernetes (client-go) version |
| #31376 | 2025-10-21 | benoittgt | Do not ignore *.yml file on linting while accepting *.yaml |
| #31362 | 2025-10-21 | fabiocarneiro | Clarify the intent of the resource instructions |
| #31392 | 2025-10-16 | TerryHowe | feature: create copilot structured context |
| #31295 | 2025-10-13 | TerryHowe | Fix make helm list show all by default |
| #31372 | 2025-10-10 | mattfarina | Enable Releases To Have Multiple Versions |
| #31254 | 2025-09-23 | benoittgt | Warn when we fallback to a different version on `helm pull` |
| #31275 | 2025-09-10 | benoittgt | Extend --skip-schema-validation for lint command |
| #31116 | 2025-09-02 | banjoh | chore: check if go modules are tidy before build |
| #31217 | 2025-09-01 | scottrigby | <span class="breaking">BREAKING CHANGE:</span> [HIP-0026] Move Postrenderer to a plugin type |
| #31196 | 2025-08-31 | scottrigby | <span class="breaking">BREAKING CHANGE:</span> [HIP-0026] Remove unnecessary file i/o operations from signing and verifying |
| #31176 | 2025-08-30 | scottrigby | <span class="breaking">BREAKING CHANGE:</span> [HIP-0026] Plugin packaging, signing, and verification |
| #31194 | 2025-08-28 | gjenkins8 | <span class="breaking">BREAKING CHANGE:</span> [HIP-0026] Plugin extism/v1 runtime |
| #30812 | 2025-08-27 | gjenkins8 | <span class="breaking">BREAKING CHANGE:</span> HIP-0023: Helm support server-side apply |
| #31174 | 2025-08-26 | scottrigby | <span class="breaking">BREAKING CHANGE:</span> [HIP-0026] Plugin tarball support for HTTP and local installers |
| #31172 | 2025-08-26 | scottrigby | <span class="breaking">BREAKING CHANGE:</span> [HIP-0026] Plugin OCI installer |
| #31146 | 2025-08-23 | scottrigby | <span class="breaking">BREAKING CHANGE:</span> [HIP-0026] Plugin types and plugin apiVersion v1 |
| #31145 | 2025-08-22 | scottrigby | <span class="breaking">BREAKING CHANGE:</span> [HIP-0026] Plugin runtime interface |
| #31142 | 2025-08-21 | gjenkins8 | <span class="breaking">BREAKING CHANGE:</span> [HIP-0026] Move pkg/plugin -> internal/plugin |
| #31030 | 2025-08-14 | gjenkins8 | <span class="breaking">BREAKING CHANGE:</span> HIP-0023: Kube client support server-side apply |
| #12624 | 2025-08-13 | papdaniel | show crds command output separated by document separator |
| #13111 | 2025-08-13 | rawtaz | style(pkg/chartutil): add missing dots and indentation to defaultValues |
| #31076 | 2025-08-11 | matheuscscp | pkg/registry: Login option for passing TLS config in memory |
| #31034 | 2025-08-05 | Mazafard | Feat: Add color output functionality and tests for release statuses |
| #31057 | 2025-07-18 | danilobuerger | Pass credentials when either chart repo or repo dont specify a port but it matches the default port of that scheme |
| #31019 | 2025-07-17 | zachburg | Return early when linting if the `templates/` directory does not exist |
| #31011 | 2025-07-17 | yalosev | feature: add labels to metadata |
| #31015 | 2025-07-17 | zachburg | Add linter support for the `crds/` directory |
| #13154 | 2025-07-10 | carloslima | Allow post-renderer to process hooks |
| #13586 | 2025-06-04 | jessesimpson36 | feat: add formatting for errors to make multiline stacktraces in helm templates |
| #30553 | 2025-05-07 | Zhanweelee | feat: Add mustToYaml and mustToJson template functions |
| #30734 | 2025-04-21 | ipaqsa | feat(pkg/engine): add support for custom template funcs |
| #13283 | 2025-04-14 | win-t | adding support for JSON Schema 2020 |
| #30751 | 2025-04-13 | benoittgt | Add detailed debug logging for resource readiness states |
| #30708 | 2025-04-11 | benoittgt | Migrate pkg to slog |
| #13604 | 2025-04-05 | AustinAbro321 | Introduce kstatus watcher |
| #13617 | 2025-02-27 | AustinAbro321 | <span class="breaking">BREAKING CHANGE:</span>  Refactor cmd/helm to allow library usage |
| #30571 | 2025-02-24 | yardenshoham | feat: error out when post-renderer produces no output |
| #13655 | 2025-02-20 | LuBingtan | feat: support multi-document values files |
| #13471 | 2025-02-19 | wangjingcun | Use a more direct and less error-prone return value |
| #30294 | 2025-02-19 | Zhanweelee | Supports json arguments |
| #13538 | 2025-01-17 | godhanipayal | Add Contextual Error Messages to RunWithContext |
| #12588 | 2024-11-22 | rynowak | Make the authorizer and registry authorizer configurable |

## Bug Fixes

Fixes in Helm 4 that were not backported to v3

| PR | Date | Author | Title |
|---|---|---|---|
| #31323 | 2025-10-29 | mattfarina | Reproducible chart archive builds |
| #31411 | 2025-10-29 | banjoh | fix: reinstate logger parameter to actions package |
| #31204 | 2025-10-22 | benoittgt | Avoid panic in helm.sh/helm/v3/pkg/chartutil.ValidateAgainstSchema |
| #31337 | 2025-10-22 | rachelvweber | Fixing rollback and uninstall client WaitStrategy |
| #31393 | 2025-10-21 | benoittgt | Return errors during upgrade when the deletion of resources fails |
| #31406 | 2025-10-21 | jessesimpson36 | fix: kube client should return empty results objects instead of nil |
| #31375 | 2025-10-13 | TerryHowe | fix: release info time parsing |
| #31349 | 2025-10-07 | TerryHowe | fix: flakey lint test on shuffle |
| #31327 | 2025-10-07 | TerryHowe | fix: broken `--html` flag to coverage script |
| #31354 | 2025-10-07 | TerryHowe | fix: flake upgrade test |
| #31227 | 2025-10-03 | evankanderson | Use filepath.Path when handling directory names |
| #31307 | 2025-10-02 | TerryHowe | fix: Ignore absolute path when RepoUrl is provided |
| #31334 | 2025-09-30 | fleaz | Fix typo in bug-report  issue template |
| #31330 | 2025-09-25 | mattfarina | Restore lint rule for excluding meaningless name |
| #31320 | 2025-09-25 | kosiew | provenance: allow RSA signing when ed25519 keys are present (switch to ProtonMail/go-crypto) |
| #31285 | 2025-09-12 | bennsimon | fix: remove leftover debugging line that outputs invalid YAML for helm template command |
| #31277 | 2025-09-11 | benoittgt | Fix deprecation warning for spf13/pflag from 1.0.7 to 1.0.10 |
| #31272 | 2025-09-09 | TerryHowe | fix: idea gitignore entry |
| #31252 | 2025-09-05 | kamilswiec | fix:chartfile tests - semver2 error message |
| #31199 | 2025-09-05 | TerryHowe | fix: flaky registry data race on mockdns close |
| #31200 | 2025-09-05 | TerryHowe | fix: installer action goroutine count |
| #31222 | 2025-09-03 | benoittgt | Prevent failing `helm push` on ghcr.io using standard GET auth token flow |
| #31191 | 2025-08-26 | TerryHowe | fix: send logging to stderr |
| #31138 | 2025-08-19 | islewis | fix(helm-lint): Add HTTP/HTTPS URL support for json schema references |
| #31152 | 2025-08-18 | TerryHowe | fix: enable shuffle in Makefile for unit tests |
| #12968 | 2025-08-13 | sjeandeaux | helm uninstall dry run support `--ignore-not-found` |
| #31126 | 2025-08-12 | paologallinaharbur | fix(transport): leverage same tls config |
| #31109 | 2025-08-06 | carlossg | fix: prevent panic when ChartDownloader.getOciURI |
| #31074 | 2025-07-18 | joejulian | add missing template directory to badcrdfile testdata |
| #31042 | 2025-07-10 | TerryHowe | fix: test teardown dns data race |
| #30898 | 2025-07-06 | AshmitBhardwaj | Fix issue 13198 |
| #31021 | 2025-07-05 | zachburg | Update tests in create_test.go and package_test.go to work in a temp directory |
| #31024 | 2025-07-03 | gjenkins8 | fix: 'TestRunLinterRule' stateful test |
| #30900 | 2025-06-23 | unguiculus | Add timeout flag to repo add and update commands |
| #30981 | 2025-06-15 | TerryHowe | fix: lint test SetEnv errors |
| #30973 | 2025-06-12 | manslaughter03 | fix: wrap run release test error in case GetPodLogs failed. |
| #30972 | 2025-06-10 | TerryHowe | fix: kube client create mutex |
| #30958 | 2025-06-06 | TerryHowe | fix: repo update cmd mutex |
| #30955 | 2025-06-04 | carloslima | Fix tests deleting XDG_DATA_HOME |
| #30939 | 2025-06-03 | TerryHowe | fix: action hooks delete policy mutex |
| #12581 | 2025-06-03 | MichaelMorrisEst | Consider full GroupVersionKind when matching resources |
| #30930 | 2025-05-28 | benoittgt | Fix flaky TestFindChartURL due to non-deterministic map iteration |
| #30884 | 2025-05-21 | mattfarina | Reverting fix "renders int as float" |
| #30862 | 2025-05-20 | OmriSteiner | fix: correctly concat absolute URIs in repo cache |
| #30864 | 2025-05-16 | jessesimpson36 | fix: remove duplicate error message |
| #30842 | 2025-05-15 | ayushontop | Fix : No repository is not an error,use the helm repo list command ,if there is no repository,it should not be an error #30606 |
| #30800 | 2025-04-25 | mmorel-35 | fix: dep fs errors |
| #30803 | 2025-04-25 | mattfarina | Fixing windows build |
| #30783 | 2025-04-23 | rpolishchuk | fix: chart icon presence test |
| #30777 | 2025-04-23 | ryanhockstad | fix: null merge |
| #9175 | 2025-04-23 | dastrobu | fix: copy dependencies on aliasing to avoid sharing chart references on multiply aliased dependencies |
| #12382 | 2025-04-20 | edbmiller | fix(pkg/lint): unmarshals Chart.yaml strictly |
| #30766 | 2025-04-17 | benoittgt | Fix main branch by defining wait strategy parameter on hooks |
| #30718 | 2025-04-16 | klihub | Allow signing multiple charts with a single passphrase from stdin. |
| #30752 | 2025-04-16 | benoittgt | Bump golangci lint to last major version and fix static-check errors |
| #30737 | 2025-04-11 | rpolishchuk | fix: order dependent test |
| #9318 | 2025-04-07 | wahabmk | Fix issue with helm pull failing if pulling from a repository that redirects to another domain |
| #13119 | 2025-04-05 | idsulik | fix(concurrency): Use channel for repoFailList errors in updateCharts |
| #30618 | 2025-03-04 | AustinAbro321 | Fix namespace flag not registering |
| #30590 | 2025-03-01 | SantalScript | fix:add proxy support when mTLS configured |
| #30572 | 2025-02-25 | yardenshoham | fix: error when more than one post-renderer is specified |
| #30576 | 2025-02-23 | felipecrs | Fix flaky TestDedupeRepos |
| #30562 | 2025-02-20 | robertsirc | fixing error handling from a previous PR |
| #13656 | 2025-02-03 | gjenkins8 | fix: Bind repotest server to `localhost` |
| #13633 | 2025-01-17 | mattfarina | Ensuring the file paths are clean prior to passing to securejoin |
| #13425 | 2024-11-15 | MathieuCesbron | Fix typo "re-use" to "reuse" |

## Refactor/Cleanup

Code quality improvements and modernization

| PR | Date | Author | Title |
|---|---|---|---|
| #31440 | 2025-10-29 | mattfarina | Updating Go and golangci-lint versions |
| #31408 | 2025-10-21 | AndiDog | Improve error message when plugin source cannot be determined or a non-directory is passed |
| #31390 | 2025-10-21 | TerryHowe | fix: improve pkg/cmd/list test coverage |
| #31365 | 2025-10-21 | reddaisyy | refactor: use reflect.TypeFor |
| #31395 | 2025-10-21 | wyrapeseed | chore: fix some comment format |
| #31401 | 2025-10-17 | TerryHowe | refactor: remove unused err from pkg/registry/client.go |
| #31391 | 2025-10-15 | TerryHowe | chore: rename test registry |
| #31302 | 2025-10-13 | TerryHowe | fix: helm verify Run signature |
| #31270 | 2025-10-13 | TerryHowe | chore: registry utils clean up |
| #31383 | 2025-10-13 | dirkmueller | Avoid accessing .Items on nil object |
| #31379 | 2025-10-13 | TerryHowe | fix: clean up coverage script temp file |
| #30980 | 2025-10-10 | gjenkins8 | cleanup: Remove/consolidate redundant kube client Interfaces |
| #30712 | 2025-10-10 | gjenkins8 | cleanup: Remove extra lint/rules.Template functions |
| #30833 | 2025-10-09 | gjenkins8 | refactor/cleanup: Replace action 'DryRun' string with DryRunStrategy type + deprecations |
| #31326 | 2025-10-07 | TerryHowe | Update sign tests to use testify |
| #31312 | 2025-10-01 | gjenkins8 | Remove unused 'Settings' from plugin schema |
| #31143 | 2025-09-25 | TerryHowe | fix: remove redundant error check |
| #31249 | 2025-09-25 | banjoh | chore: add additional logging to plugin installer |
| #31321 | 2025-09-24 | juejinyuxitu | chore: fix some typos in comment |
| #31297 | 2025-09-22 | TerryHowe | fix: hide notes in helm test command |
| #31315 | 2025-09-22 | benoittgt | Remove unused golangci-lint rules that produce warning |
| #31294 | 2025-09-19 | TerryHowe | Remove implicit support for helm lint current directory |
| #31301 | 2025-09-19 | TerryHowe | chore: remove helm version `--client` option |
| #31303 | 2025-09-18 | mattfarina | Update the action interfaces for chart apiversions |
| #31198 | 2025-09-16 | TerryHowe | refactor: replace pkg/engine regular expressions with parser |
| #31293 | 2025-09-16 | TerryHowe | chore: remove pkg/time which is no longer needed |
| #31287 | 2025-09-16 | miledxz | improve fileutil test coverage |
| #31292 | 2025-09-16 | reddaisyy | refactor: use strings.builder |
| #31286 | 2025-09-12 | yajianggroup | refactor: use strings.CutPrefix |
| #31258 | 2025-09-08 | StephanieHhnbrg | Refactor unreachableKubeClient for testing into failingKubeClient |
| #31259 | 2025-09-07 | StephanieHhnbrg | Adapt test-coverage command to be able to run for a certain package |
| #31225 | 2025-09-02 | mattfarina | <span class="breaking">BREAKING CHANGE:</span> Move lint pkg to be part of each chart version |
| #31220 | 2025-09-02 | gjenkins8 | <span class="breaking">BREAKING CHANGE:</span> refactor: utilize `pluginTypesIndex` for config unmarshalling  |
| #31219 | 2025-09-02 | gjenkins8 | <span class="breaking">BREAKING CHANGE:</span> Remove 'SetupPluginEnv' |
| #31216 | 2025-09-02 | mattfarina | <span class="breaking">BREAKING CHANGE:</span> Move to versioned packages |
| #31224 | 2025-09-01 | gjenkins8 | fix: Adjust PostRenderer plugin output to value |
| #31218 | 2025-09-01 | gjenkins8 | <span class="breaking">BREAKING CHANGE:</span> Remove legacy Command/Hooks from v1 Subprocess (#23) |
| #31151 | 2025-08-30 | TerryHowe | fix: make file whitespace |
| #31178 | 2025-08-28 | mattfarina | Add content cache to helm env |
| #31165 | 2025-08-22 | mattfarina | <span class="breaking">BREAKING CHANGE:</span> Initial addition of content based cache |
| #13629 | 2025-08-22 | gjenkins8 | <span class="breaking">BREAKING CHANGE:</span> Rename 'atomic' -> 'rollback-on-failure' |
| #31175 | 2025-08-21 | cuiweixie | pkg/register: refactor to use atomic.Uint64 |
| #31132 | 2025-08-19 | joemicky | refactor: replace []byte(fmt.Sprintf) with fmt.Appendf  |
| #31133 | 2025-08-14 | joemicky | refactor: replace HasPrefix+TrimPrefix with CutPrefix |
| #31134 | 2025-08-14 | joemicky | refactor: omit unnecessary reassignment |
| #11700 | 2025-08-13 | suzaku | Refactor, use sort.Slice to reduce boilerplate code |
| #31058 | 2025-08-07 | farazkhawaja | Add test coverage for get_values/metadata.go |
| #31107 | 2025-08-06 | Pavanipogula | test(pkg/kube): Add unit tests to wait and roundtripper files. |
| #31106 | 2025-08-05 | irikeish | test(pkg/kube): add test for Client.isReachable |
| #30982 | 2025-08-05 | gjenkins8 | <span class="breaking">BREAKING CHANGE:</span> Rename 'force' to 'force-replace' |
| #31094 | 2025-08-04 | mikelolasagasti | chore(deps): remove phayes/freeport module |
| #31101 | 2025-07-30 | banjoh | feat: switch yaml library to go.yaml.in/yaml/v3 |
| #31081 | 2025-07-25 | mattfarina | <span class="breaking">BREAKING CHANGE:</span> Initial addition of v3 charts |
| #31079 | 2025-07-22 | gjenkins8 | cleanup: Remove plugin deprecated 'UseTunnelDeprecated' |
| #31060 | 2025-07-18 | yumeiyin | refactor: replace Split in loops with more efficient SplitSeq |
| #31065 | 2025-07-15 | TerryHowe | chore: improve OCI debug logging |
| #31033 | 2025-07-14 | navinag1989 | test: increase test coverage for pkg/cli/options.go file |
| #31029 | 2025-07-07 | gjenkins8 | chore(refactor): Privatize 'k8sYamlStruct' |
| #31023 | 2025-07-03 | gjenkins8 | <span class="breaking">BREAKING CHANGE:</span> Remove deprecated '--create-pods' flag |
| #31009 | 2025-07-02 | tpresa | test: increase test coverage for pkg/pusher |
| #31018 | 2025-07-01 | mattfarina | Move logging setup to be configurable |
| #30909 | 2025-06-03 | jinjiadu | refactor: replace HasPrefix+TrimPrefix with CutPrefix |
| #30809 | 2025-06-03 | mmorel-35 | chore: enable usetesting linter |
| #30865 | 2025-05-22 | mmorel-35 | refactor: update json-patch import path and add gomodguard settings |
| #30871 | 2025-05-20 | gjenkins8 | Run test OCI registry localhost |
| #30866 | 2025-05-20 | mmorel-35 | chore: enable thelper linter |
| #30863 | 2025-05-16 | mattfarina | Adding test for list command |
| #30850 | 2025-05-12 | yetyear | refactor: use maps.Copy for cleaner map handling |
| #30829 | 2025-05-09 | TerryHowe | Increase pkg/time test coverage |
| #30810 | 2025-05-08 | mmorel-35 | chore: enable usestdlibvars linter |
| #30844 | 2025-05-08 | TerryHowe | fix: rename slave replica |
| #30827 | 2025-05-06 | findnature | refactor: use slices.Contains to simplify code |
| #13460 | 2025-04-23 | justenstall | fix: replace "github.com/pkg/errors" with stdlib "errors" package |
| #30788 | 2025-04-23 | stephenpmurray | ref(helm): Export Chart Not Found error |
| #30781 | 2025-04-22 | mmorel-35 | chore: remove `github.com/hashicorp/go-multierror` dependency |
| #13578 | 2025-04-18 | gjenkins8 | refactor: Remove ChartRepository `[]ChartPaths` |
| #30760 | 2025-04-16 | robertsirc | adding slog debug to a few points |
| #30713 | 2025-04-11 | gjenkins8 | cleanup: Remove Helm v2 template lint rules |
| #30749 | 2025-04-11 | mattfarina | <span class="breaking">BREAKING CHANGE:</span> Removing the alpine test chart |
| #30686 | 2025-04-11 | mattfarina | <span class="breaking">BREAKING CHANGE:</span> Remove deprecated code |
| #30736 | 2025-04-09 | robertsirc | manually updating go.mod file |
| #13458 | 2025-04-05 | thudi | <span class="breaking">BREAKING CHANGE:</span> #13449 Resolves: Replacing NewSimpleClientSet to NewClientSet due to deprecation |
| #30684 | 2025-03-21 | twz123 | Remove ClientOptResolver from OCI Client |
| #30603 | 2025-03-21 | robertsirc | converting inline log to slog |
| #30699 | 2025-03-21 | mattfarina | Error when failed repo update. |
| #30592 | 2025-02-28 | robertsirc | changing from log to slog |
| #30589 | 2025-02-26 | mattfarina | <span class="breaking">BREAKING CHANGE:</span> Move pkg/release to pkg/release/v1 to support v3 charts |
| #30586 | 2025-02-25 | mattfarina | <span class="breaking">BREAKING CHANGE:</span> Move pkg/chart to pkg/chart/v2 to prepare for v3 charts |
| #30585 | 2025-02-25 | robertsirc | removing old apis |
| #30580 | 2025-02-24 | mattfarina | <span class="breaking">BREAKING CHANGE:</span> Move pkg/releaseutil to pkg/release/util |
| #11112 | 2025-02-22 | felipecrs | perf(dep-up): do not update the same repo multiple times |
| #30567 | 2025-02-21 | mattfarina | <span class="breaking">BREAKING CHANGE:</span> Moving chartutil to chart/util |
| #30566 | 2025-02-21 | robertsirc | remove unused config.go |
| #30470 | 2025-02-19 | gjenkins8 | Cleanup `repotest.Server` constructors |
| #30550 | 2025-02-19 | mattfarina | Moving to SetOut and SetErr for Cobra |
| #30546 | 2025-02-19 | hugehope | refactor: using slices.Contains to simplify the code |
| #13535 | 2025-02-05 | gjenkins8 | refactor: tlsutil use options pattern |
| #13665 | 2025-02-05 | gjenkins8 | chore: Remove unused `WaitAndGetCompletedPodPhase` |
| #13579 | 2025-02-05 | gjenkins8 | refactor: Remove duplicate `FindChartIn*RepoURL` functions |
| #13516 | 2025-01-24 | TerryHowe | chore: fix problems with latest lint |
| #13494 | 2025-01-18 | gjenkins8 | <span class="breaking">BREAKING CHANGE:</span> Remove deprecated `repo add --no-update` flag |
| #13602 | 2025-01-17 | crystalstall | refactor: using slices.Contains to simplify the code |
| #13600 | 2025-01-14 | gjenkins8 | cleanup: `NewShowWithConfig` -> `NewShow` |
| #13601 | 2025-01-09 | gjenkins8 | cleanup: Remove superseded 'lint/rules.Values' function |
| #13611 | 2025-01-07 | mattfarina | <span class="breaking">BREAKING CHANGE:</span> Updating the internal version to v4 |
| #13576 | 2025-01-07 | gjenkins8 | refactor: Consolidate lint package Run() functions |
| #13577 | 2025-01-07 | gjenkins8 | refactor: Remove redundant `NewPullWithOpts` |
| #13599 | 2025-01-07 | gjenkins8 | cleanup: `ProcessDependenciesWithMerge` -> `ProcessDependencies` |
| #13573 | 2024-12-27 | mattfarina | <span class="breaking">BREAKING CHANGE:</span> Updating to helm.sh/helm/v4 |
| #13444 | 2024-12-07 | justenstall | refactor(status): remove --show-desc and --show-resources flags |

## Other

Infrastructure and project management improvements

| PR | Date | Author | Title |
|---|---|---|---|
| #31197 | 2025-09-03 | tzchenxixi | chore: fix function name |
| #31150 | 2025-08-18 | TerryHowe | Feature add stale pr workflow |
| #31149 | 2025-08-18 | TerryHowe | fix: stale issue workflow |
| #31077 | 2025-07-21 | gaspergrom | fix: LFX health score badge link |
| #31047 | 2025-07-10 | jingchanglu | chore: fix typo in pkg/repo/chartrepo.go |
| #31004 | 2025-06-26 | andreped | fix(docs): Typofix in README |
| #31002 | 2025-06-26 | curlwget | chore: fix function in comment |
| #30912 | 2025-06-17 | Bhargavkonidena | Fix #30893 - issue templates |
| #30957 | 2025-06-04 | acceptacross | chore: fix some function names in comment |
| #30914 | 2025-05-27 | benoittgt | Fix dependabot upgrade of jsonschema to v6.0.2 |
| #30904 | 2025-05-23 | benoittgt | [Doc] Help users avoid specifying URL scheme and path with `helm registry` |
| #30882 | 2025-05-20 | caniszczyk | Add new LFX Insights Health Score Badge |
| #30872 | 2025-05-20 | benoittgt | Bump golangci-lint version to match last golangci-lint-action |
| #30824 | 2025-05-05 | adharsh277 | Fix bug in .golangci.yml configuration |
| #30786 | 2025-04-25 | mmorel-35 | refactor: reorganize .golangci.yml for better clarity and structure |
| #30785 | 2025-04-23 | mmorel-35 | fix: govulncheck workflow |
| #30784 | 2025-04-22 | scottrigby | chore(OWNERS): Add TerryHowe as Triage Maintainer |
| #30773 | 2025-04-18 | wangcundashang | chore: fix function name in comment |
| #30754 | 2025-04-16 | mattfarina | Simplify the JSON Schema checking |
| #30693 | 2025-03-20 | linghuying | chore: make function comment match function name |
| #30665 | 2025-03-13 | mattfarina | Updating to 0.37.0 for x/net |
| #30611 | 2025-03-04 | gjenkins8 | chore: Remove 'coveralls' |
| #30612 | 2025-03-04 | gjenkins8 | fix: Fix go report card badge reference/link |
| #30508 | 2025-02-19 | eimhin-rover | Update version option description with more accurate info |
| #30497 | 2025-02-12 | robertsirc | adding-my-key |
| #30295 | 2025-02-07 | edithturn | Add Percona to the list of organizations using Helm |
| #13653 | 2025-01-23 | petercover | chore: fix some comments |
| #13625 | 2025-01-13 | shahbazaamir | ading info to install helm , referring the documentation |
| #13563 | 2024-12-21 | gjenkins8 | Run `build-test` action on `dev-v3` branch |
| #13552 | 2024-12-20 | gjenkins8 | Fix `dependabot.yml` `target-branch` typo |
| #13529 | 2024-12-15 | godhanipayal | Adding Oracle to the adopters list |
| #13509 | 2024-12-06 | gjenkins8 | Dependabot update `dev-v3` branch go modules |
| #13212 | 2024-12-01 | mbianchidev | Update ADOPTERS.md |
| #13465 | 2024-11-20 | banjoh | Add precommit config to .gitignore |
| #13443 | 2024-11-15 | mattfarina | Updating docs around v3 and v4 |

## v4 Changes Also Backported to v3

These PRs were included in v4 but were also backported to v3 releases

### New Features (Backported)

| PR | Date | Author | Title |
|---|---|---|---|
| #30696 | 2025-03-24 | benoittgt | Inform about time spent waiting resources to be ready in slog format |
| #12912 | 2025-03-11 | hegerdes | feat: add httproute from gateway-api to create chart template |
| #10309 | 2025-02-21 | Bez625 | Add hook annotation to output hook logs to client on error |
| #13481 | 2025-02-18 | banjoh | feat: Enable CPU and memory profiling |
| #12690 | 2025-01-01 | TerryHowe | feat: OCI install by digest |
| #13232 | 2024-12-20 | dnskr | ref(create): don't render empty resource fields |
| #12962 | 2024-12-04 | stevehipwell | feat: Added multi-platform plugin hook support |
| #13343 | 2024-11-19 | niladrih | Add annotations and dependencies to get metadata output |

### Bug Fixes (Backported)

| PR | Date | Author | Title |
|---|---|---|---|
| #31064 | 2025-09-05 | kamilswiec | lint: throw warning when chart version is not semverv2 |
| #31156 | 2025-08-22 | estroz | fix: set repo authorizer in registry.Client.Resolve() |
| #30992 | 2025-08-18 | TerryHowe | fix: force bearer oauth for if registry requests bearer auth |
| #31115 | 2025-08-18 | banjoh | fix: use username and password if provided |
| #30891 | 2025-08-13 | gjenkins8 | fix: Port pluginCommand & command warning |
| #31050 | 2025-08-08 | heyLu | Fix `helm pull` untar dir check with repo urls |
| #31078 | 2025-07-24 | 8tomat8 | fix: k8s version parsing to match original |
| #30979 | 2025-06-17 | TerryHowe | fix: OAuth username password login for v4 |
| #30917 | 2025-06-01 | TerryHowe | fix: add debug logging to oci transport |
| #30937 | 2025-05-30 | TerryHowe | fix: legacy docker support broken for login |
| #30928 | 2025-05-28 | TerryHowe | fix: plugin installer test with no Internet |
| #30905 | 2025-05-23 | robertsirc | forward porting 30902 |
| #30894 | 2025-05-23 | benoittgt | Prevent push cmd failure in 3.18 by handling version tag resolution in ORAS memory store |
| #30697 | 2025-04-17 | p-se | Fix --take-ownership for custom resources - closes #30622 |
| #30673 | 2025-04-16 | nvanthao | fix: Process all hook deletions on failure |
| #30701 | 2025-04-11 | zanuka | updates mutate and validate web hook configs |
| #13583 | 2025-01-15 | jiashengz | fix: check group for resource info match |

### Refactor/Cleanup (Backported)

| PR | Date | Author | Title |
|---|---|---|---|
| #30677 | 2025-04-18 | dongjiang1989 | chore: Update Golang to v1.24 |
| #30741 | 2025-04-11 | benoittgt | Bumps github.com/distribution/distribution/v3 from 3.0.0-rc.3 to 3.0.0 |
| #13382 | 2025-02-03 | TerryHowe | chore(oci): migrate to ORAS Golang library v2 |
| #13546 | 2024-12-19 | mattfarina | Update to Go 1.23 |
| #13499 | 2024-12-06 | gjenkins8 | Shadow ORAS remote.Client interface |

### Other (Backported)

| PR | Date | Author | Title |
|---|---|---|---|
| #30775 | 2025-04-19 | benoittgt | Bump toml |
| #13533 | 2025-01-24 | althmoha | fix: (toToml) renders int as float |
| #13581 | 2024-12-31 | ldlb9527 | Upgrade golang.org/x/net to v0.33.0 to address CVE-2024-45338 |
</file>

<file path="index.mdx">
---
title: Docs Home
description: Everything you need to know about how the documentation is organized.
sidebar_position: 1
---

# Welcome

Welcome to the [Helm](https://helm.sh/) documentation. Helm is the package
manager for Kubernetes, and you can read detailed background information in the
[CNCF Helm Project Journey
report](https://www.cncf.io/cncf-helm-project-journey/).

import DocCardList from "@theme/DocCardList";

<DocCardList />
</file>

<file path="overview.md">
---
sidebar_position: 1
sidebar_label: Helm 4 Overview
---

# Helm 4 Overview

Helm v4 represents a significant evolution from v3, introducing breaking changes, new architectural patterns, and enhanced functionality while maintaining backwards compatibility for charts.

For more information about the planned Helm 4 release phases, see [Path to Helm v4](https://helm.sh/blog/path-to-helm-v4/).

## What's New

This section provides an overview of what's new in Helm 4, including breaking changes, major new features, and other improvements. For complete technical details, see the [Full Changelog](./changelog.md).

### Summary

- **New features**: Wasm-based plugins, kstatus watcher, OCI digest support, multi-doc values, JSON arguments
- **Architecture changes**: Plugin system completely redesigned, package restructuring, CLI flag renaming, move to versioned packages, chart v3 support, content-based caching
- **Modernization**: slog migration, Go 1.24 update, dependency cleanup
- **Security**: Enhanced OCI/registry support, TLS improvements

### Breaking Changes

#### Post-renderers implemented as plugins
Post-renderers are implemented as plugins. With this change, it is no longer possible to pass an executable directly to `helm render --post-renderer`, but a plugin name must be passed. This might require updates to any existing post-renderer workflows.

#### Registry login does not accept full URLs
The `helm registry login` command must be done with the domain name only in v4.
This is so login can be scoped at different levels on a registry in the future.

### New Features

#### Plugin System Overhaul
Helm 4 introduces an optional WebAssembly-based runtime for enhanced security and expanded capabilities. Existing plugins continue to work, but the new runtime opens up more of Helm's core behavior for plugin customization. Helm 4 launches with three plugin types: CLI plugins, getter plugins, and post-renderer plugins, plus a system that enables new plugin types for customizing additional core functionality. See [HIP-0026 plugin system](https://github.com/helm/community/blob/main/hips/hip-0026.md) and [Helm 4 example plugins](https://github.com/scottrigby/h4-example-plugins).

:::tip
Existing plugins work as before. The new WebAssembly runtime is optional but recommended for enhanced security.
:::

#### Better resource monitoring
New kstatus integration shows detailed status of your deployments. Test with complex applications to see if it catches issues better.

#### Enhanced OCI Support
Install charts by digest for better supply chain security. For example, `helm install myapp oci://registry.example.com/charts/app@sha256:abc123...`. Charts with non-matching digests are not installed.

#### Multi-Document Values
Split complex values across multiple YAML files. Perfect for testing different environment configs.

#### Server-Side Apply
Better conflict resolution when multiple tools manage the same resources. Test in environments with operators or other controllers.

#### Custom Template Functions
Extend Helm's templating with your own functions through plugins. Great for organization-specific templating needs.

#### Post-Renderers as Plugins
Post-renderers are implemented as plugins, providing better integration and more capabilities.

#### Stable SDK API
API breaking changes are now complete. Test it, break it, give us feedback! The API also enables additional chart versions, opening possibilities for new features in the upcoming Charts v3.

#### Charts v3

Coming soon. v2 charts continue to work unchanged.

### Improvements

#### Performance
Faster dependency resolution and new content-based chart caching.

#### Error Messages
Clearer, more helpful error output.

#### Registry Authentication
Better OAuth and token support for private registries.

#### CLI Flags renamed

Some common CLI flags are renamed to better clarify their operation.
The existing flags remain, but emit a deprecated warning:

- `--atomic` â†’ `--rollback-on-failure`
- `--force` â†’ `--force-replace`

Update any automation that uses these renamed CLI flags.

## Upgrading to Helm 4

While we work hard to make Helm 4 rock-solid for everyone, Helm 4 is brand new. To that end, before upgrading, we've added some tips below for specific things to look out for when testing Helm 4 with your existing workflows. As always, we welcome all feedback about what works, what breaks, and what could be better.

### High Priority
* Test your existing charts and releases to verify that they still work with v4.
* Test all 3 plugin types (CLI, getter, post-renderer).
* Try building WebAssembly plugins with the new runtime (see [example plugins](https://github.com/scottrigby/h4-example-plugins))
* SDK users: test the now-stable API. Try to break it and share your feedback.
* Test your CI/CD pipelines and fix any script errors from the renamed CLI flags.
* Test your post-renderer integrations.
* Test registry authentication and chart installation in your OCI workflows.

### Other
* Test other new features, including multi-document values, digest-based installs, and custom template functions.
* Test the performance of Helm 4 with large, complex charts to see if it is noticeably faster for your workloads.
* Try breaking things intentionally to see if the updated error messages are helpful.

### Feedback
* What other plugin types would you like to see added to customize Helm core functionality?
* With the API supporting additional chart versions, what new features would you want in Charts v3?

## How to Give Feedback

Find issues? Have suggestions? We want to hear from you before the November release:

### GitHub Issues

Review the [list of open issues and feature requests](https://github.com/helm/helm/issues) in the Helm repo. Add comments on the existing items, or [create new](https://github.com/helm/helm/issues/new/choose) issues and requests.

### Community Slack

Join [Kubernetes Slack](https://slack.kubernetes.io/) channels:
- `#helm-dev` for development discussions
- `#helm-users` for user support and testing feedback

### Weekly Dev Meetings

Join live discussion with maintainers every Thursday 9:30am PT on [Zoom](https://zoom.us/j/696660622?pwd=MGsraXZ1UkVlTkJLc1B5U05KN053QT09).

For more options, see the Helm community [communication details](https://github.com/helm/community/blob/main/communication.md).
</file>

</files>
